[
  {
    "name": "TupleTypeDefinition",
    "expressions": [],
    "properties": ["elements"]
  },
  {
    "name": "ActualObjectParameter",
    "expressions": [],
    "properties": [
      "value",
      "classTypeDefinitions",
      "owningClassTypeDefinition",
      "formalObjectParameter"
    ]
  },
  {
    "name": "Association",
    "expressions": [
      {
        "operations": {
          "size": 1,
          "<": 1
        },
        "name": "AtMostOneOrderedEnd",
        "body": "self.ends->select(ae|ae.type.ordered)->size() < 2",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "data::classes::Association::ends",
          "data::classes::AssociationEnd::type",
          "data::classes::Multiplicity::ordered"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "implies": 1,
          "=": 1
        },
        "name": "UniquenessOnBothEndsMustBeTheSame",
        "body": "self.ends->forAll( e1, e2 : AssociationEnd |\r\n              e1 <> e2 implies e1.type.unique = e2.type.unique)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "data::classes::Association::ends",
          "data::classes::Multiplicity::unique",
          "data::classes::AssociationEnd::type"
        ]
      },
      {
        "operations": {
          "size": 1,
          "<": 1
        },
        "name": "AtMostOneCompositeEnd",
        "body": "self.ends->select(composite)->size() < 2",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::Association::ends",
          "data::classes::AssociationEnd::composite"
        ]
      },
      {
        "operations": {
          "size": 1,
          "and": 1,
          "<": 1
        },
        "name": "AtMostOneEqualityContributionForTwoValueClasses",
        "body": "self.ends->select(contributesToEquality and type.clazz.valueType)->size() < 2",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "data::classes::Association::ends",
          "data::classes::SapClass::valueType",
          "data::classes::AssociationEnd::type",
          "data::classes::ClassTypeDefinition::clazz",
          "data::classes::AssociationEnd::contributesToEquality"
        ]
      },
      {
        "operations": {"notEmpty": 1},
        "name": "AtLeastOneNavigableEnd",
        "body": "self.ends->select(ae:AssociationEnd | ae.navigable)->notEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::Association::ends",
          "data::classes::AssociationEnd::navigable"
        ]
      }
    ],
    "properties": [
      "ends",
      "abapAnnotation",
      "timeDependency",
      "package_"
    ]
  },
  {
    "name": "AbapSignatureImplementationAnnotation",
    "expressions": [],
    "properties": ["Signature"]
  },
  {
    "name": "LinkAddition",
    "expressions": [{
      "operations": {
        "at": 2,
        "size": 1,
        "oclIsKindOf": 1,
        "getType": 2,
        "and": 3,
        "isEmpty": 1,
        "oclAsSet": 1,
        "oclAsType": 1,
        "=": 2
      },
      "name": "AdditionInputTypeMatchEndType",
      "body": "self.implements_.output->isEmpty() and\r\n  self.implements_.input->size() = 1 and \r\n  self.implements_.input->at(1).getType().oclIsKindOf(ClassTypeDefinition) and \r\n  self.implements_.input->at(1).getType().oclAsType(ClassTypeDefinition).clazz = self.end.type.clazz",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 14,
        "VariableExpImpl": 5,
        "IntegerLiteralExpImpl": 3,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 12
      },
      "properties": [
        "data::classes::AssociationEndSignatureImplementation::end",
        "data::classes::Signature::input",
        "data::classes::AssociationEnd::type",
        "data::classes::SignatureImplementation::implements_",
        "data::classes::ClassTypeDefinition::clazz",
        "data::classes::Signature::output"
      ]
    }],
    "properties": []
  },
  {
    "name": "AbapAssociationImplementationAnnotation",
    "expressions": [],
    "properties": ["Association"]
  },
  {
    "name": "Delegation",
    "expressions": [{
      "operations": {
        "and": 1,
        "otherEnd": 2,
        "=": 2
      },
      "name": "ToEndMustHaveMultiplicityOfOne",
      "body": "self.from.otherEnd().type.lowerMultiplicity = 1 and\r\n  self.from.otherEnd().type.upperMultiplicity = 1",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 5,
        "IntegerLiteralExpImpl": 2,
        "PropertyCallExpImpl": 6
      },
      "properties": [
        "data::classes::AssociationEnd::type",
        "data::classes::Delegation::from",
        "data::classes::Multiplicity::lowerMultiplicity",
        "data::classes::Multiplicity::upperMultiplicity"
      ]
    }],
    "properties": [
      "from",
      "allFeatures"
    ]
  },
  {
    "name": "Signature",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 2,
          "getImplementedAnonymousFunctionExpression": 1,
          "oclAsType": 3,
          "getOwningClass": 1
        },
        "name": "getOwningClass",
        "body": "if self.oclIsKindOf(MethodSignature) then\n    let owner:SignatureOwner = self.oclAsType(MethodSignature).owner in\n    if owner.oclIsKindOf(SapClass) then\n      owner.oclAsType(SapClass)\n    else\n      null    -- e.g., TypeAdapter\n    endif\n  else\n    self.oclAsType(FunctionSignature).getImplementedAnonymousFunctionExpression().getOwningClass()\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 7,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 5,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::MethodSignature::owner"]
      },
      {
        "operations": {
          "at": 4,
          "size": 6,
          "oclIsKindOf": 2,
          "getType": 2,
          "and": 6,
          "oclAsSet": 5,
          "conformsToExcluding": 2,
          "implies": 2,
          "=": 4,
          "oclAsType": 2,
          "asSequence": 2
        },
        "name": "conformsToExcluding",
        "body": "if s = self then\n    true\n  else\n    let nameConforms:Boolean = self.oclIsKindOf(MethodSignature) and s.oclIsKindOf(MethodSignature) \n       implies s.oclAsType(MethodSignature).name = self.oclAsType(MethodSignature).name in\n    nameConforms and\n    (s.sideEffectFree implies self.sideEffectFree) and\n    s.input->size() = self.input->size() and\n    Sequence{1..self.input->size()}->\n      forAll(i | s.input->at(i).getType().conformsToExcluding(self.input->at(i).getType(), excludingConforming, excludingTo)) and\n    s.output->size() = self.output->size() and\n    Sequence{1..self.output->size()}->\n      forAll(i | self.output->asSequence()->at(i).conformsToExcluding(s.output->asSequence()->at(i), excludingConforming, excludingTo))\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 37,
          "VariableExpImpl": 27,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 4,
          "CollectionLiteralExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 14,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "modelmanagement::NamedElement::name",
          "data::classes::Signature::sideEffectFree",
          "data::classes::Signature::input",
          "data::classes::Signature::output"
        ]
      },
      {
        "operations": {
          "conformsToExcluding": 1,
          "=": 1
        },
        "name": "conformsTo",
        "body": "if self = s then\n    true\n  else\n    self.conformsToExcluding(s, Sequence{}, Sequence{})\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 4,
          "CollectionLiteralExpImpl": 2,
          "IfExpImpl": 1,
          "BooleanLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "asSet": 1,
          "getOwningClass": 1
        },
        "name": "getNamedValuesInScope",
        "body": "self.getOwningClass().formalObjectParameters->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::SapClass::formalObjectParameters"]
      },
      {
        "operations": {
          "at": 1,
          "size": 1,
          "oclAsSet": 2,
          "+": 1,
          "implies": 1,
          "notEmpty": 2,
          "indexOf": 1
        },
        "name": "OnlyTrailingOptionalParameters",
        "body": "self.input->forAll(p | p.defaultValue->notEmpty() implies Sequence{(self.input->indexOf(p)+1)..self.input->size()}->forAll(\r\n    i | self.input->at(i).defaultValue->notEmpty()))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 9,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "data::classes::Parameter::defaultValue",
          "data::classes::Signature::input"
        ]
      }
    ],
    "properties": [
      "ownedTypeDefinitions",
      "abapAnnotation",
      "FunctionSignatureTypeDefinition",
      "proxy",
      "sideEffectFree",
      "preconditions",
      "faults",
      "input",
      "typeDefinition",
      "postconditions",
      "output"
    ]
  },
  {
    "name": "SignatureImplementation",
    "expressions": [{
      "operations": {
        "oclIsKindOf": 1,
        "oclAsSet": 1,
        "notEmpty": 1,
        "oclAsType": 2
      },
      "name": "getImplementedSignature",
      "body": "if self.oclIsKindOf(FunctionSignatureImplementation) then\n    if self.oclAsType(FunctionSignatureImplementation).functionSignature->notEmpty() then\n      self.oclAsType(FunctionSignatureImplementation).functionSignature\n    else\n      self.implements_\n    endif\n  else\n    self.implements_\n  endif",
      "type": "OperationImpl",
      "constructs": {
        "OperationCallExpImpl": 5,
        "VariableExpImpl": 5,
        "TypeExpImpl": 3,
        "IfExpImpl": 2,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "data::classes::SignatureImplementation::implements_",
        "data::classes::FunctionSignatureImplementation::functionSignature"
      ]
    }],
    "properties": ["implements_"]
  },
  {
    "name": "InScope",
    "expressions": [{
      "operations": {
        "not": 1,
        "union": 1,
        "asSet": 1,
        "=": 1
      },
      "name": "addNamedValuesWithNewNames",
      "body": "inner->union(outer->select(o | not inner->exists(i | i.name = o.name))->asSet())",
      "type": "OperationImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "VariableExpImpl": 5,
        "OperationCallExpImpl": 4,
        "PropertyCallExpImpl": 2
      },
      "properties": ["modelmanagement::NamedElement::name"]
    }],
    "properties": []
  },
  {
    "name": "LinkManipulationAtPosition",
    "expressions": [],
    "properties": ["at"]
  },
  {
    "name": "ParameterizedClassInstantiation",
    "expressions": [
      {
        "operations": {},
        "name": "getClassParameterization",
        "body": "parameterizedClass.parameterization",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::SapClass::parameterization",
          "data::generics::ParameterizedClassInstantiation::parameterizedClass"
        ]
      },
      {
        "operations": {
          "at": 2,
          "size": 3,
          "and": 1,
          "=": 2
        },
        "name": "ActualTypeParametersMatchSignature",
        "body": "self.actualTypeParametersForInstantiation->size() = self.parameterizedClass.parameterization.formalTypeParameters->size() and\r\n  Sequence{1..self.actualTypeParametersForInstantiation->size()}->forAll(i:Integer|\r\n    self.actualTypeParametersForInstantiation->at(i).formalTypeParameter =\r\n    self.parameterizedClass.parameterization.formalTypeParameters->at(i))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 7,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "data::classes::SapClass::parameterization",
          "data::generics::ParameterizedClassInstantiation::parameterizedClass",
          "data::generics::ClassParameterization::formalTypeParameters",
          "data::generics::ActualTypeParameter::formalTypeParameter",
          "data::generics::ParameterizedClassInstantiation::actualTypeParametersForInstantiation"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "ClassMustBeParameterized",
        "body": "self.parameterizedClass.parameterization->notEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::SapClass::parameterization",
          "data::generics::ParameterizedClassInstantiation::parameterizedClass"
        ]
      },
      {
        "operations": {
          "at": 1,
          "=": 1,
          "asSequence": 1
        },
        "name": "resolveFormalTypeParameter",
        "body": "self.actualTypeParametersForInstantiation->select(atp:ActualTypeParameter |\n    atp.formalTypeParameter = ftp)->asSequence()->at(1).type",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "data::generics::ActualTypeParameter::type",
          "data::generics::ActualTypeParameter::formalTypeParameter",
          "data::generics::ParameterizedClassInstantiation::actualTypeParametersForInstantiation"
        ]
      }
    ],
    "properties": [
      "parameterizedClass",
      "actualTypeParametersForInstantiation"
    ]
  },
  {
    "name": "TypedElement",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "getType": 2,
          "conformsTo": 1,
          "=": 1
        },
        "name": "conformsTo",
        "body": "self = typedElement or\n  self.getType().conformsTo(typedElement.getType())",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5
        },
        "properties": []
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 20,
          "getSignature": 1,
          "+": 1,
          "union": 2,
          "oclAsType": 67,
          "-": 1,
          "at": 1,
          "getType": 22,
          "and": 2,
          "oclAsSet": 15,
          "conformsTo": 1,
          "notEmpty": 13,
          "asSet": 3,
          "=": 1,
          "indexOf": 1
        },
        "name": "getType",
        "body": "if self.ownedTypeDefinition->notEmpty() then\n    self.ownedTypeDefinition\n  else\n    if self.oclIsKindOf(behavioral::actions::Variable) then\n      self.oclAsType(behavioral::actions::Variable).initExpression.getType()\n    else if self.oclIsKindOf(behavioral::actions::Constant) then\n      if self.oclAsType(behavioral::actions::Constant).initExpression->notEmpty() then\n        self.oclAsType(behavioral::actions::Constant).initExpression.getType()\n      else\n         if self.oclAsType(behavioral::actions::Constant)._iterate->notEmpty() then\n           self.oclAsType(behavioral::actions::Constant)._iterate.iteratorExpression.getType()\n         else\n           null\n         endif\n      endif\n    else if self.oclIsKindOf(behavioral::actions::Iterator) then\n      if self.oclAsType(behavioral::actions::Iterator).boundToFor->notEmpty() then\n        if self.oclAsType(behavioral::actions::Iterator).boundToFor.collection.getType().oclIsKindOf(data::classes::NestedTypeDefinition) then\n          -- if the selection's object has a nested type definition, un-nest by one level\n          self.oclAsType(behavioral::actions::Iterator).boundToFor.collection.getType().oclAsType(data::classes::NestedTypeDefinition).type\n        else\n          -- the tool should infer a better match; this as a better default than \"null\"\n          self.oclAsType(behavioral::actions::Iterator).boundToFor.collection.getType()\n        endif\n      else\n        let selection:Set(dataaccess::expressions::Expression)=self.oclAsType(behavioral::actions::Iterator).selection.object->asSet() in\n        let groupby:Set(dataaccess::expressions::Expression)=self.oclAsType(behavioral::actions::Iterator).factOfGroupBy.object->asSet() in\n        let iterateexp:Set(dataaccess::expressions::Expression)=self.oclAsType(behavioral::actions::Iterator)._iterate.source->asSet() in\n        let iteratesource:Set(dataaccess::expressions::Expression)=selection->union(groupby)->union(iterateexp) in\n        if iteratesource->notEmpty() then\n          if iteratesource->any(true).getType().oclIsKindOf(data::classes::NestedTypeDefinition) then\n            -- if the Selection's/GroupBy's object has a nested type definition, un-nest by one level\n            iteratesource->any(true).getType().oclAsType(data::classes::NestedTypeDefinition).type\n          else\n            -- In this case the tool should create a cloned tpye definition with multiplicities set to 1;\n            -- Just in case the tool doesn't do this and for the case where the object has upper\n            -- multiplicity 1, use the object's type as the default for the \"self\" iterator\n            iteratesource->any(true).getType()\n          endif\n        else\n          if self.oclAsType(behavioral::actions::Iterator).groupedFactsOfGroupBy->notEmpty() then\n            -- the groups of a group-by expression can re-used the facts type\n            self.oclAsType(behavioral::actions::Iterator).factOfGroupBy.object.getType()\n          else\n            if self.oclAsType(behavioral::actions::Iterator).dimension->notEmpty() then\n              -- the DimensionDefinition's expression defines the dimension iterator's type\n              self.oclAsType(behavioral::actions::Iterator).dimension.expression.getType()\n            else\n              -- Then we have no idea how to infer the Iterator's type\n              null\n            endif\n          endif\n        endif\n      endif\n    else if self.oclIsKindOf(dataaccess::expressions::collectionexpressions::Including) or self.oclIsKindOf(dataaccess::expressions::collectionexpressions::Excluding) then\n      self.oclAsType(dataaccess::expressions::collectionexpressions::CollectionExpression).source.getType()\n    else if self.oclIsKindOf(dataaccess::expressions::collectionexpressions::Iterate) then\n      self.oclAsType(dataaccess::expressions::collectionexpressions::Iterate).iteratorExpression.getType()\n    else if self.oclIsKindOf(Parameter) then\n      if self.oclAsType(Parameter).defaultValue->notEmpty() then\n        self.oclAsType(Parameter).defaultValue.getType()\n      else\n        if self.oclAsType(Parameter).ownerSignature.oclIsKindOf(MethodSignature) and\n        self.oclAsType(Parameter).ownerSignature.oclAsType(MethodSignature).implementation->notEmpty() and\n        self.oclAsType(Parameter).ownerSignature.oclAsType(MethodSignature).implementation.oclIsKindOf(AssociationEndSignatureImplementation) then\n  \tlet impl:AssociationEndSignatureImplementation = self.oclAsType(Parameter).ownerSignature.oclAsType(MethodSignature).implementation.oclAsType(AssociationEndSignatureImplementation) in\n            impl.end.type\n        else\n          if self.oclAsType(Parameter).ownerSignature.oclIsKindOf(FunctionSignature) then\n            if self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).dimension->notEmpty() then\n              self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).dimension.cellSet.factsType\n            else\n              if self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForValueFunction->notEmpty() then\n                self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForValueFunction.factsType\n              else\n                if self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForAggregationFunction->notEmpty() then\n                  if self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForAggregationFunction.valueFunction->notEmpty() then\n                    self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForAggregationFunction.valueFunction.output\n                  else\n                    self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).cellSetForAggregationFunction.factsType\n                  endif\n                else\n                  if self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).implementation.oclIsKindOf(dataaccess::analytics::CellSet) then\n                    let pos:Integer = self.oclAsType(Parameter).ownerSignature.input->indexOf(self.oclAsType(Parameter)) in\n                    if pos = 1 then\n                      self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).implementation.oclAsType(dataaccess::analytics::CellSet).factsType\n                    else\n                      self.oclAsType(Parameter).ownerSignature.oclAsType(FunctionSignature).implementation.oclAsType(dataaccess::analytics::CellSet).\n                          dimensions->at(-1+pos).characteristicFunction.output\n                    endif\n                  else\n                    null\n                  endif\n                endif\n              endif\n            endif\n          else\n            null\n          endif\n        endif\n      endif\n    else if self.oclIsKindOf(dataaccess::analytics::DimensionExpression) then\n      -- TODO Here, the multiplicity would have to be forced to 0..*\n      self.oclAsType(dataaccess::analytics::DimensionExpression).dimensionParameter.getType()\n    else if self.oclIsKindOf(dataaccess::expressions::VariableExpression) then\n      self.oclAsType(dataaccess::expressions::VariableExpression).variable.getType()\n    else if self.oclIsKindOf(dataaccess::expressions::SignatureCallExpression) then\n      self.oclAsType(dataaccess::expressions::SignatureCallExpression).getSignature().output\n    else if self.oclIsKindOf(dataaccess::expressions::AssociationEndNavigationExpression) then\n      self.oclAsType(dataaccess::expressions::AssociationEndNavigationExpression).toEnd.type\n    else if self.oclIsKindOf(dataaccess::expressions::Replace) then\n      self.oclAsType(dataaccess::expressions::Replace).object.getType()\n    else if self.oclIsKindOf(dataaccess::expressions::Ternary) then\n      -- Find the \"least\" TypeDefinition to which both, trueExpr.getType() and falseExpr.getType() conform.\n      -- We determine the more general of the two types; we cannot synthesize a new TypeDefinition in OCL.\n      -- Doing so would have to be done by explicit typing, setting the ownedTypeDefinition explicitly\n      if self.oclAsType(dataaccess::expressions::Ternary).trueExpr.getType().conformsTo(self.oclAsType(dataaccess::expressions::Ternary).falseExpr.getType()) then\n        self.oclAsType(dataaccess::expressions::Ternary).falseExpr.getType()\n      else\n        self.oclAsType(dataaccess::expressions::Ternary).trueExpr.getType()\n      endif\n    else if self.oclIsKindOf(dataaccess::query::Selection) then\n      self.oclAsType(dataaccess::query::Selection).object.getType()\n    else\n      null\n    endif\n    endif\n    endif\n    endif\n    endif\n    endif\n    endif\n    endif\n    endif\n    endif\n    endif\n    endif\n    endif\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 152,
          "VariableExpImpl": 74,
          "LetExpImpl": 6,
          "NullLiteralExpImpl": 5,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 87,
          "IfExpImpl": 32,
          "PropertyCallExpImpl": 89,
          "BooleanLiteralExpImpl": 3
        },
        "properties": [
          "behavioral::actions::Constant::iterate",
          "dataaccess::expressions::collectionexpressions::CollectionExpression::source",
          "dataaccess::expressions::collectionexpressions::Iterate::iteratorExpression",
          "dataaccess::analytics::CellSet::dimensions",
          "data::classes::AssociationEnd::type",
          "behavioral::actions::Iterator::selection",
          "dataaccess::expressions::ObjectBasedExpression::object",
          "dataaccess::expressions::Ternary::trueExpr",
          "data::classes::MethodSignature::implementation",
          "dataaccess::analytics::Dimension::cellSet",
          "behavioral::actions::Iterator::dimension",
          "data::classes::Parameter::defaultValue",
          "data::classes::FunctionSignature::dimension",
          "dataaccess::analytics::CellSet::factsType",
          "data::classes::TypedElement::ownedTypeDefinition",
          "data::classes::Signature::output",
          "behavioral::actions::Iterator::factOfGroupBy",
          "dataaccess::analytics::Dimension::characteristicFunction",
          "data::classes::FunctionSignature::implementation",
          "data::classes::FunctionSignature::cellSetForAggregationFunction",
          "behavioral::actions::Iterator::boundToFor",
          "dataaccess::expressions::Ternary::falseExpr",
          "data::classes::FunctionSignature::cellSetForValueFunction",
          "dataaccess::analytics::CellSet::valueFunction",
          "data::classes::Parameter::ownerSignature",
          "data::classes::AssociationEndSignatureImplementation::end",
          "behavioral::actions::Iterator::iterate",
          "dataaccess::analytics::DimensionDefinition::expression",
          "behavioral::actions::Iterator::groupedFactsOfGroupBy",
          "dataaccess::expressions::VariableExpression::variable",
          "data::classes::Signature::input",
          "dataaccess::analytics::DimensionExpression::dimensionParameter",
          "dataaccess::expressions::AssociationEndNavigationExpression::toEnd",
          "behavioral::actions::Foreach::collection",
          "behavioral::actions::NamedValueWithOptionalInitExpression::initExpression",
          "data::classes::NestedTypeDefinition::type"
        ]
      }
    ],
    "properties": ["ownedTypeDefinition"]
  },
  {
    "name": "NativeImpl",
    "expressions": [],
    "properties": ["platformSpecificImplementaiton"]
  },
  {
    "name": "Dummy",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ExtentModifyingAssociationEndSignatureImplementation",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "implies": 1
        },
        "name": "MustNotModifyExtentIfEqualityRelevantForValueClass",
        "body": "end.association.ends->forAll(ae:AssociationEnd |\r\n    ae.contributesToEquality implies not ae.type.clazz.valueType)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "data::classes::Association::ends",
          "data::classes::AssociationEndSignatureImplementation::end",
          "data::classes::AssociationEnd::association",
          "data::classes::AssociationEnd::type",
          "data::classes::SapClass::valueType",
          "data::classes::ClassTypeDefinition::clazz",
          "data::classes::AssociationEnd::contributesToEquality"
        ]
      },
      {
        "operations": {"not": 1},
        "name": "MustNotImplementSideEffectFreeOperation",
        "body": "not self.implements_.sideEffectFree",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::Signature::sideEffectFree",
          "data::classes::SignatureImplementation::implements_"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "NamedValue",
    "expressions": [{
      "operations": {
        "getNamedValuesInScope": 5,
        "oclIsKindOf": 3,
        "union": 2,
        "asSet": 2,
        "oclAsType": 4
      },
      "name": "getNamedValuesInScope",
      "body": "self.owner.getNamedValuesInScope()->union(\n    if self.oclIsKindOf(Parameter) then\n      self.oclAsType(Parameter).ownerSignature.getNamedValuesInScope()\n    else\n      if self.oclIsKindOf(behavioral::actions::Iterator) then\n        self.oclAsType(behavioral::actions::Iterator).boundToFor.getNamedValuesInScope()->asSet()->union(\n        self.oclAsType(behavioral::actions::Iterator)._iterate.getNamedValuesInScope()->asSet())\n      else\n        if self.oclIsKindOf(behavioral::actions::Constant) then\n          self.oclAsType(behavioral::actions::Constant)._iterate.getNamedValuesInScope()\n        else\n          Set{}    -- TODO further cases?\n        endif\n      endif\n    endif\n    )",
      "type": "OperationImpl",
      "constructs": {
        "OperationCallExpImpl": 16,
        "VariableExpImpl": 8,
        "TypeExpImpl": 7,
        "CollectionLiteralExpImpl": 1,
        "IfExpImpl": 3,
        "PropertyCallExpImpl": 5
      },
      "properties": [
        "data::classes::NamedValue::owner",
        "behavioral::actions::Constant::iterate",
        "data::classes::Parameter::ownerSignature",
        "behavioral::actions::Iterator::iterate",
        "behavioral::actions::Iterator::boundToFor"
      ]
    }],
    "properties": ["owner"]
  },
  {
    "name": "ConverterBetweenParametrizations",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "isAbstract": 1
        },
        "name": "MustHaveConcreteMethod",
        "body": "not self.conversionMethod.isAbstract()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::ConverterBetweenParametrizations::conversionMethod"]
      },
      {
        "operations": {
          "at": 2,
          "size": 3,
          "and": 1,
          "conformsTo": 1,
          "=": 1
        },
        "name": "FormalObjectParametersConformToMethodParameters",
        "body": "self.conversionMethod.input->size() = self.clazz.formalObjectParameters->size() and\r\n  Sequence{1..self.conversionMethod.input->size()}->forAll(i |\r\n    self.clazz.formalObjectParameters->at(i).conformsTo(self.conversionMethod.input->at(i)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 7,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "data::classes::ConverterBetweenParametrizations::conversionMethod",
          "data::classes::Signature::input",
          "data::classes::SapClass::formalObjectParameters",
          "data::classes::ConverterBetweenParametrizations::clazz"
        ]
      }
    ],
    "properties": [
      "conversionMethod",
      "clazz"
    ]
  },
  {
    "name": "FormalTypeParameter",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 4,
          "getTypeUsage": 1,
          "and": 7,
          "oclAsSet": 2,
          "notEmpty": 2,
          "implies": 1,
          "oclAsType": 7,
          "=": 3
        },
        "name": "UseInSignaturesOfOwningParamerizedClassOnly",
        "body": "self.elementsOfType.getTypeUsage()->forAll(s | s.oclIsKindOf(data::classes::Parameter) implies \r\n   (s.oclAsType(data::classes::Parameter).ownerSignature.oclIsKindOf(data::classes::MethodSignature) and\r\n    s.oclAsType(data::classes::Parameter).ownerSignature.oclAsType(data::classes::MethodSignature).owner=self.parameterOf .owningClassDefinition)) and\r\n  self.elementsOfType.signaturesWithOutput->forAll(s| s.oclIsKindOf(data::classes::MethodSignature) and \r\n    s.oclAsType(data::classes::MethodSignature).owner->notEmpty() and\r\n    s.oclAsType(data::classes::MethodSignature).owner=self.parameterOf.owningClassDefinition) and\r\n  self.signaturesWithFault->forAll(s| s.oclIsKindOf(data::classes::MethodSignature)  and \r\n    s.oclAsType(data::classes::MethodSignature).owner->notEmpty() and\r\n    s.oclAsType(data::classes::MethodSignature).owner=self.parameterOf.owningClassDefinition)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 5,
          "OperationCallExpImpl": 27,
          "VariableExpImpl": 17,
          "TypeExpImpl": 11,
          "PropertyCallExpImpl": 17
        },
        "properties": [
          "data::generics::ClassParameterization::owningClassDefinition",
          "data::generics::FormalTypeParameter::parameterOf",
          "data::classes::SapClass::elementsOfType",
          "data::classes::Parameter::ownerSignature",
          "data::classes::MethodSignature::owner",
          "data::classes::TypeDefinition::signaturesWithOutput",
          "data::classes::SapClass::signaturesWithFault"
        ]
      },
      {
        "operations": {
          "otherEnd": 1,
          "=": 1
        },
        "name": "UseInAssociationsOfOwningParameterizedClassOnly",
        "body": "self.elementsOfType.associationEnd->\r\n    forAll(ae | ae.otherEnd().type.clazz = self.parameterOf.owningClassDefinition)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "data::generics::ClassParameterization::owningClassDefinition",
          "data::classes::SapClass::elementsOfType",
          "data::generics::FormalTypeParameter::parameterOf",
          "data::classes::ClassTypeDefinition::associationEnd",
          "data::classes::AssociationEnd::type",
          "data::classes::ClassTypeDefinition::clazz"
        ]
      }
    ],
    "properties": [
      "parameterOf",
      "typeConstraint",
      "actualTypeParameters"
    ]
  },
  {
    "name": "LinkRemoval",
    "expressions": [{
      "operations": {
        "at": 2,
        "size": 1,
        "getType": 2,
        "oclIsKindOf": 1,
        "and": 3,
        "oclAsSet": 1,
        "isEmpty": 1,
        "=": 2,
        "oclAsType": 1
      },
      "name": "RemovalTypeMatchEndType",
      "body": "self.implements_.output->isEmpty() and\r\n  self.implements_.input->size() = 1 and \r\n  self.implements_.input->at(1).getType().oclIsKindOf(ClassTypeDefinition) and \r\n  self.implements_.input->at(1).getType().oclAsType(ClassTypeDefinition).clazz = self.end.type.clazz",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 5,
        "OperationCallExpImpl": 14,
        "IntegerLiteralExpImpl": 3,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 12
      },
      "properties": [
        "data::classes::AssociationEndSignatureImplementation::end",
        "data::classes::Signature::input",
        "data::classes::AssociationEnd::type",
        "data::classes::SignatureImplementation::implements_",
        "data::classes::ClassTypeDefinition::clazz",
        "data::classes::Signature::output"
      ]
    }],
    "properties": []
  },
  {
    "name": "AssociationEndSignatureImplementation",
    "expressions": [{
      "operations": {
        "or": 1,
        "oclIsKindOf": 2,
        "and": 2,
        "otherEnd": 2,
        "conformsTo": 2,
        "oclAsType": 2
      },
      "name": "OnlyOnOtherEndsClassOrClassConformingToItOrAdapterAdaptingToIt",
      "body": "(self.implements_.owner.oclIsKindOf(SapClass) and\r\n    self.implements_.owner.oclAsType(SapClass).conformsTo(self.end.otherEnd().type.clazz))\r\n  or   (self.implements_.owner.oclIsKindOf(TypeAdapter) and\r\n    self.implements_.owner.oclAsType(TypeAdapter).adapted.conformsTo(self.end.otherEnd().type.clazz))",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 6,
        "OperationCallExpImpl": 11,
        "TypeExpImpl": 4,
        "PropertyCallExpImpl": 15
      },
      "properties": [
        "data::classes::AssociationEndSignatureImplementation::end",
        "data::classes::MethodSignature::owner",
        "data::classes::AssociationEnd::type",
        "data::classes::SignatureImplementation::implements_",
        "data::classes::TypeAdapter::adapted",
        "data::classes::ClassTypeDefinition::clazz"
      ]
    }],
    "properties": ["end"]
  },
  {
    "name": "ClassTypeDefinition",
    "expressions": [
      {
        "operations": {
          "<=": 1,
          "at": 2,
          "size": 5,
          "and": 2,
          "isEmpty": 1,
          "oclAsSet": 1,
          "=": 1,
          ">=": 1
        },
        "name": "ActualObjectsParametersMatchSignature",
        "body": "let numberOfMandatoryParameters:Integer =\r\n    self.clazz.formalObjectParameters->select(p|p.defaultValue->isEmpty())->size()\r\n  in\r\n  self.objectParameters->size() >= numberOfMandatoryParameters and\r\n  self.objectParameters->size() <= self.clazz.formalObjectParameters->size() and\r\n  Sequence{1..self.objectParameters->size()}->forAll(i:Integer|\r\n    self.objectParameters->at(i).formalObjectParameter =\r\n    self.clazz.formalObjectParameters->at(i))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 14,
          "VariableExpImpl": 11,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "data::classes::Parameter::defaultValue",
          "data::classes::ClassTypeDefinition::objectParameters",
          "data::classes::SapClass::formalObjectParameters",
          "data::classes::ClassTypeDefinition::clazz",
          "data::classes::ActualObjectParameter::formalObjectParameter"
        ]
      },
      {
        "operations": {
          "evaluatesToEqualAs": 1,
          "at": 2,
          "or": 1,
          "size": 3,
          "oclAsSet": 1,
          "effectiveObjectParameters": 5,
          "notEmpty": 1,
          "=": 1
        },
        "name": "objectParametersConformTo",
        "body": "if self.effectiveObjectParameters()->size()  = ctd.effectiveObjectParameters()->size() then\n    self.clazz.converterBetweenParametrizations->notEmpty() or\n    Sequence{1..self.effectiveObjectParameters()->size()}->forAll(i |\n      self.effectiveObjectParameters()->at(i).evaluatesToEqualAs(ctd.effectiveObjectParameters()->at(i)))\n  else\n    false\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 8,
          "OperationCallExpImpl": 15,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 2,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "data::classes::SapClass::converterBetweenParametrizations",
          "data::classes::ClassTypeDefinition::clazz"
        ]
      },
      {
        "operations": {
          "flatten": 3,
          "at": 1,
          "size": 2,
          "oclAsSet": 1,
          "+": 1,
          "union": 1,
          "asSequence": 3
        },
        "name": "effectiveObjectParameters",
        "body": "self.objectParameters.value->flatten()->asSequence()->union(\n     Sequence{(self.objectParameters->size()+1)..(self.clazz.formalObjectParameters->size())}->collect(i | \n             self.clazz.formalObjectParameters->at(i).defaultValue->flatten()->asSequence()))->flatten()->asSequence()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 12,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "data::classes::ActualObjectParameter::value",
          "data::classes::Parameter::defaultValue",
          "data::classes::ClassTypeDefinition::objectParameters",
          "data::classes::SapClass::formalObjectParameters",
          "data::classes::ClassTypeDefinition::clazz"
        ]
      }
    ],
    "properties": [
      "ownedObjectParameters",
      "objectParameters",
      "associationEnd",
      "clazz"
    ]
  },
  {
    "name": "ObjectState",
    "expressions": [],
    "properties": []
  },
  {
    "name": "AbapClassImplementationAnnotation",
    "expressions": [],
    "properties": ["SapClass"]
  },
  {
    "name": "ClassParameterization",
    "expressions": [{
      "operations": {
        "<>": 2,
        "implies": 1
      },
      "name": "DistinctFormalTypeParameterNames",
      "body": "self.formalTypeParameters->forAll(i,j|i<>j implies i.name<>j.name)",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 5,
        "OperationCallExpImpl": 3,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "modelmanagement::NamedElement::name",
        "data::generics::ClassParameterization::formalTypeParameters"
      ]
    }],
    "properties": [
      "owningClassDefinition",
      "package_",
      "formalTypeParameters"
    ]
  },
  {
    "name": "AssociationEnd",
    "expressions": [
      {
        "operations": {
          "otherEnd": 1,
          "=": 1
        },
        "name": "ExposingClassesEqualOppositeEndsType",
        "body": "self.signatureImplementations.implements_.owner->forAll(c:SignatureOwner | c = self.otherEnd().type.clazz)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 5,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "data::classes::MethodSignature::owner",
          "data::classes::AssociationEnd::type",
          "data::classes::SignatureImplementation::implements_",
          "data::classes::ClassTypeDefinition::clazz",
          "data::classes::AssociationEnd::signatureImplementations"
        ]
      },
      {
        "operations": {
          "not": 1,
          "implies": 1
        },
        "name": "NoCompositionWithValueClass",
        "body": "self.composite implies self.association.ends.type->forAll(ctd:ClassTypeDefinition | not ctd.clazz.valueType)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "data::classes::Association::ends",
          "data::classes::AssociationEnd::association",
          "data::classes::SapClass::valueType",
          "data::classes::AssociationEnd::type",
          "data::classes::ClassTypeDefinition::clazz",
          "data::classes::AssociationEnd::composite"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "getAssociationEnds": 1,
          "and": 3,
          "implies": 1,
          "isMany": 1
        },
        "name": "EqualityContributingEndOnValueMustHaveUnlimitedUpperBounds",
        "body": "(self.type.clazz.valueType and self.contributesToEquality and\r\n   self.type.clazz.getAssociationEnds()->exists(ae |\r\n     ae <> self and ae.contributesToEquality)) implies\r\n  self.type.isMany()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 7,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "data::classes::SapClass::valueType",
          "data::classes::AssociationEnd::type",
          "data::classes::ClassTypeDefinition::clazz",
          "data::classes::AssociationEnd::contributesToEquality"
        ]
      },
      {
        "operations": {
          "and": 1,
          "otherEnd": 2,
          "notEmpty": 1,
          "implies": 1
        },
        "name": "EqualityContributionsMustBeExposedAndNavigable",
        "body": "self.contributesToEquality implies (self.otherEnd().signatureImplementations->notEmpty() and self.otherEnd().navigable)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "data::classes::AssociationEnd::navigable",
          "data::classes::AssociationEnd::contributesToEquality",
          "data::classes::AssociationEnd::signatureImplementations"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "first": 1
        },
        "name": "otherEnd",
        "body": "association.ends->select(ae|ae <> self)->first()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::Association::ends",
          "data::classes::AssociationEnd::association"
        ]
      }
    ],
    "properties": [
      "association",
      "navigable",
      "type",
      "delegation",
      "composite",
      "abapAnnotation",
      "contributesToEquality",
      "signatureImplementations",
      "valueInit"
    ]
  },
  {
    "name": "NestedTypeDefinition",
    "expressions": [{
      "operations": {"isMany": 1},
      "name": "NestedIsAlwaysMany",
      "body": "self.isMany()",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 1
      },
      "properties": []
    }],
    "properties": [
      "ownedTypeDefinition",
      "op",
      "type"
    ]
  },
  {
    "name": "TupleElement",
    "expressions": [],
    "properties": ["TupleTypeDefinition"]
  },
  {
    "name": "Dummy",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Multiplicity",
    "expressions": [{
      "operations": {
        "or": 1,
        "=": 1,
        "-": 1,
        ">": 1
      },
      "name": "isMany",
      "body": "self.upperMultiplicity > 1 or self.upperMultiplicity = -1",
      "type": "OperationImpl",
      "constructs": {
        "OperationCallExpImpl": 4,
        "VariableExpImpl": 2,
        "IntegerLiteralExpImpl": 2,
        "PropertyCallExpImpl": 2
      },
      "properties": ["data::classes::Multiplicity::upperMultiplicity"]
    }],
    "properties": [
      "unique",
      "lowerMultiplicity",
      "upperMultiplicity",
      "ordered"
    ]
  },
  {
    "name": "ActualTypeParameter",
    "expressions": [{
      "operations": {
        "oclAsSet": 1,
        "conformsTo": 1,
        "implies": 1,
        "notEmpty": 1
      },
      "name": "TypeConformsWithFormalParametersTypeConstraint",
      "body": "self.formalTypeParameter.typeConstraint->notEmpty() implies\r\n    self.type.conformsTo(self.formalTypeParameter.typeConstraint)",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 4,
        "PropertyCallExpImpl": 5
      },
      "properties": [
        "data::generics::FormalTypeParameter::typeConstraint",
        "data::generics::ActualTypeParameter::type",
        "data::generics::ActualTypeParameter::formalTypeParameter"
      ]
    }],
    "properties": [
      "parameterizedClassInstantiation",
      "type",
      "formalTypeParameter"
    ]
  },
  {
    "name": "AbapAssociationEndImplementationAnnotation",
    "expressions": [],
    "properties": ["AssociationEnd"]
  },
  {
    "name": "SeverityInState",
    "expressions": [],
    "properties": [
      "state",
      "severity"
    ]
  },
  {
    "name": "MethodSignature",
    "expressions": [{
      "operations": {
        "oclAsSet": 1,
        "isEmpty": 1
      },
      "name": "isAbstract",
      "body": "self.implementation->isEmpty()",
      "type": "OperationImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["data::classes::MethodSignature::implementation"]
    }],
    "properties": [
      "implementation",
      "producer",
      "owner",
      "converter"
    ]
  },
  {
    "name": "FunctionSignatureImplementation",
    "expressions": [{
      "operations": {
        "oclIsKindOf": 2,
        "oclAsType": 2,
        "localIsSideEffectFree": 2
      },
      "name": "isSideEffectFree",
      "body": "if self.oclIsKindOf(behavioral::actions::Block) then\n    self.oclAsType(behavioral::actions::Block).localIsSideEffectFree()\n  else\n    if self.oclIsKindOf(dataaccess::analytics::CellSet) then\n      self.oclAsType(dataaccess::analytics::CellSet).localIsSideEffectFree()\n    else\n      false\n    endif\n  endif",
      "type": "OperationImpl",
      "constructs": {
        "VariableExpImpl": 4,
        "OperationCallExpImpl": 6,
        "TypeExpImpl": 4,
        "IfExpImpl": 2,
        "BooleanLiteralExpImpl": 1
      },
      "properties": []
    }],
    "properties": ["functionSignature"]
  },
  {
    "name": "SapClass",
    "expressions": [
      {
        "operations": {
          "flatten": 1,
          "including": 1,
          "delegatesTo": 1,
          "count": 1,
          "asSet": 1,
          "=": 1,
          "signaturesWithDelegationExcluding": 1
        },
        "name": "delegatedSignaturesExcluding",
        "body": "if excluding->count(self)=0 then\n  self.delegatesTo().signaturesWithDelegationExcluding(excluding->including(self))->flatten()->asSet()\nelse\n  Set{}\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 6,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "IfExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "implies": 1,
          "notEmpty": 1
        },
        "name": "OnlyValueClassesCanHaveObjectParameters",
        "body": "self.formalObjectParameters->notEmpty() implies self.valueType",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::SapClass::valueType",
          "data::classes::SapClass::formalObjectParameters"
        ]
      },
      {
        "operations": {"allSignaturesExcluding": 1},
        "name": "allSignatures",
        "body": "self.allSignaturesExcluding(Set{})",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "CollectionLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "getAssociationEnds": 1,
          "asSet": 1,
          "getConformsToClasses": 1
        },
        "name": "getConformsToAssociationEnds",
        "body": "self.getConformsToClasses().getAssociationEnds()->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {
          "including": 1,
          "asSet": 1,
          "getConformsToClasses": 1
        },
        "name": "getConformsToClasses",
        "body": "self.adapters.to.getConformsToClasses()->including(self)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::SapClass::adapters",
          "data::classes::TypeAdapter::to"
        ]
      },
      {
        "operations": {
          "flatten": 2,
          "including": 3,
          "oclIsKindOf": 2,
          "delegatesTo": 1,
          "oclAsSet": 1,
          "count": 1,
          "union": 1,
          "asSet": 2,
          "=": 1,
          "oclAsType": 2,
          "signaturesWithDelegationExcluding": 3
        },
        "name": "signaturesWithDelegationExcluding",
        "body": "if excluding->count(self)=0 then \n    if self.oclIsKindOf(data::generics::ParameterizedClassInstantiation) then\n      self.oclAsType(data::generics::ParameterizedClassInstantiation).parameterizedClass.signaturesWithDelegationExcluding(excluding->including(self))\n    else\n      if self.oclIsKindOf(data::generics::FormalTypeParameter) then\n        self.oclAsType(data::generics::FormalTypeParameter).typeConstraint->collect(c:SapClass | c.signaturesWithDelegationExcluding(excluding->including(self)))->flatten()->asSet()\n      else\n        self.ownedSignatures->union(self.delegatesTo().signaturesWithDelegationExcluding(excluding->including(self)))->flatten()->asSet()\n      endif\n    endif\nelse\n  Set{}\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 16,
          "OperationCallExpImpl": 19,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 4,
          "CollectionLiteralExpImpl": 1,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "data::classes::SignatureOwner::ownedSignatures",
          "data::generics::FormalTypeParameter::typeConstraint",
          "data::generics::ParameterizedClassInstantiation::parameterizedClass"
        ]
      },
      {
        "operations": {
          "oclIsUndefined": 1,
          "conformsToExcluding": 1
        },
        "name": "conformsTo",
        "body": "if self.oclIsUndefined() then\n    false\n  else\n    self.conformsToExcluding(type, Sequence{}, Sequence{})\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "CollectionLiteralExpImpl": 2,
          "IfExpImpl": 1,
          "BooleanLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {"getAssociationEnds": 1},
        "name": "getEqualityRelevantAssociationEnds",
        "body": "self.getAssociationEnds()->select(ae|ae.contributesToEquality)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::AssociationEnd::contributesToEquality"]
      },
      {
        "operations": {
          "flatten": 2,
          "not": 1,
          "including": 3,
          "adaptedSignaturesExcluding": 2,
          "allSignaturesExcluding": 1,
          "oclIsKindOf": 2,
          "oclAsSet": 1,
          "count": 1,
          "conformsTo": 1,
          "asSet": 2,
          "=": 1,
          "oclAsType": 2
        },
        "name": "adaptedSignaturesExcluding",
        "body": "if excluding->count(self)=0 then\n    if self.oclIsKindOf(data::generics::ParameterizedClassInstantiation) then\n      self.oclAsType(data::generics::ParameterizedClassInstantiation).parameterizedClass.adaptedSignaturesExcluding(excluding->including(self))\n    else\n      if self.oclIsKindOf(data::generics::FormalTypeParameter) then\n        self.oclAsType(data::generics::FormalTypeParameter).typeConstraint->collect(c:SapClass | c.adaptedSignaturesExcluding(excluding->including(self)))->flatten()->asSet()\n      else\n        self.adapters.allSignaturesExcluding(excluding->including(self))\n          ->select(s | not self.ownedSignatures->exists(os | os.conformsTo(s)))\n          ->flatten()->asSet()\n      endif\n    endif\n  else\n    Set{}\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 19,
          "VariableExpImpl": 18,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 4,
          "CollectionLiteralExpImpl": 1,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "data::classes::SapClass::adapters",
          "data::generics::FormalTypeParameter::typeConstraint",
          "data::classes::SignatureOwner::ownedSignatures",
          "data::generics::ParameterizedClassInstantiation::parameterizedClass"
        ]
      },
      {
        "operations": {
          "flatten": 1,
          "getAssociationEnds": 1,
          "oclIsKindOf": 2,
          "delegatesTo": 2,
          "oclAsSet": 2,
          "otherEnd": 1,
          "asSet": 2,
          "notEmpty": 1,
          "oclAsType": 2,
          "=": 1
        },
        "name": "delegatesTo",
        "body": "if self.oclIsKindOf(data::generics::ParameterizedClassInstantiation) then\n    self.oclAsType(data::generics::ParameterizedClassInstantiation).parameterizedClass.delegatesTo()\n  else\n    if self.oclIsKindOf(data::generics::FormalTypeParameter) then\n      self.oclAsType(data::generics::FormalTypeParameter).typeConstraint->collect(c:SapClass | c.delegatesTo())->flatten()->asSet()\n    else\n      -- TODO improve OCL impact analysis algorithm so that this doesn't kill performance:\n      -- Set{}  -- use this for good performance\n      self.getAssociationEnds().otherEnd()->select(delegation->notEmpty()).type.clazz->reject(c|c=self)->asSet()    -- currently bad performance\n    endif\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "OperationCallExpImpl": 15,
          "VariableExpImpl": 12,
          "TypeExpImpl": 4,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "data::generics::FormalTypeParameter::typeConstraint",
          "data::classes::AssociationEnd::type",
          "data::generics::ParameterizedClassInstantiation::parameterizedClass",
          "data::classes::AssociationEnd::delegation",
          "data::classes::ClassTypeDefinition::clazz"
        ]
      },
      {
        "operations": {
          "not": 2,
          "allSignatures": 1,
          "isAbstract": 1
        },
        "name": "isAbstract",
        "body": "not (self.allSignatures()->forAll(s:MethodSignature | not s.isAbstract()))",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {"signaturesWithDelegationExcluding": 1},
        "name": "signaturesWithDelegation",
        "body": "self.signaturesWithDelegationExcluding(Set{})",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "CollectionLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {},
        "name": "NoRecursionForObjectParameters",
        "body": "true  --  TODO implement this",
        "type": "ConstraintImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "flatten": 1,
          "delegatesTo": 1,
          "signaturesWithDelegation": 1,
          "asSet": 1
        },
        "name": "delegatedSignatures",
        "body": "self.delegatesTo().signaturesWithDelegation()->flatten()->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4
        },
        "properties": []
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "isParameterizedClassDefinition",
        "body": "self.parameterization->notEmpty()",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::SapClass::parameterization"]
      },
      {
        "operations": {
          "getAssociationEnds": 1,
          "otherEnd": 1,
          "asSet": 1,
          "getConformsToClasses": 1
        },
        "name": "getConformsToCompositeChildAssociationEnds",
        "body": "self.getConformsToClasses().getAssociationEnds()->select(ae|ae.otherEnd().composite)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::AssociationEnd::composite"]
      },
      {
        "operations": {
          "oclIsUndefined": 1,
          "including": 4,
          "or": 1,
          "oclIsKindOf": 1,
          "oclAsType": 2,
          "asSequence": 2,
          "at": 2,
          "size": 1,
          "and": 1,
          "oclAsSet": 1,
          "conformsToExcluding": 2,
          "notEmpty": 1,
          "=": 3
        },
        "name": "conformsToExcluding",
        "body": "if oclIsUndefined() then\n    false\n  else\n  if self = type then\n   true\n  else\n    if Sequence{1..excludingConforming->size()}->exists(i|\n        excludingConforming->asSequence()->at(i) = self and excludingTo->asSequence()->at(i) = type) then\n     true\n  else\n    self.adapters->exists(a|a.to.conformsToExcluding(type, excludingConforming->including(self), excludingTo->including(type))) or\n    (if self.oclIsKindOf(data::generics::FormalTypeParameter) then\n        if self.oclAsType(data::generics::FormalTypeParameter).typeConstraint->notEmpty() then\n            self.oclAsType(data::generics::FormalTypeParameter).typeConstraint.conformsToExcluding(type, excludingConforming->including(self), excludingTo->including(type))\n        else\n            false\n        endif\n    else\n        false\n    endif)\n  endif\n  endif\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 25,
          "OperationCallExpImpl": 22,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 3,
          "CollectionLiteralExpImpl": 1,
          "IfExpImpl": 5,
          "PropertyCallExpImpl": 4,
          "BooleanLiteralExpImpl": 5
        },
        "properties": [
          "data::classes::SapClass::adapters",
          "data::generics::FormalTypeParameter::typeConstraint",
          "data::classes::TypeAdapter::to"
        ]
      },
      {
        "operations": {
          "flatten": 1,
          "including": 2,
          "adaptedSignaturesExcluding": 1,
          "allSignaturesExcluding": 2,
          "oclIsKindOf": 2,
          "count": 1,
          "oclAsSet": 1,
          "union": 1,
          "asSet": 1,
          "oclAsType": 2,
          "=": 1,
          "signaturesWithDelegationExcluding": 1
        },
        "name": "allSignaturesExcluding",
        "body": "if excluding->count(self)=0 then\n    if self.oclIsKindOf(data::generics::ParameterizedClassInstantiation) then\n      self.oclAsType(data::generics::ParameterizedClassInstantiation).parameterizedClass.allSignaturesExcluding(excluding->including(self))\n    else\n      if self.oclIsKindOf(data::generics::FormalTypeParameter) then\n        self.oclAsType(data::generics::FormalTypeParameter).typeConstraint->collect(c:SapClass | c.allSignaturesExcluding(excluding->including(self)))->flatten()->asSet()\n      else\n        self.signaturesWithDelegationExcluding(excluding)->union(self.adaptedSignaturesExcluding(excluding))\n      endif\n    endif\n  else\n    Set{}    \n  endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 16,
          "VariableExpImpl": 15,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 4,
          "CollectionLiteralExpImpl": 1,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::generics::FormalTypeParameter::typeConstraint",
          "data::generics::ParameterizedClassInstantiation::parameterizedClass"
        ]
      },
      {
        "operations": {
          "including": 1,
          "getConformingClasses": 1,
          "asSet": 1
        },
        "name": "getConformingClasses",
        "body": "self.adaptedBy.adapted.getConformingClasses()->including(self)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::TypeAdapter::adapted",
          "data::classes::SapClass::adaptedBy"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 2,
          "implies": 1
        },
        "name": "OnlyObjectParameterizedClassesCanHaveConverter",
        "body": "self.converterBetweenParametrizations->notEmpty() implies self.formalObjectParameters->notEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::SapClass::converterBetweenParametrizations",
          "data::classes::SapClass::formalObjectParameters"
        ]
      },
      {
        "operations": {
          "at": 1,
          "size": 1,
          "oclAsSet": 2,
          "+": 1,
          "notEmpty": 2,
          "implies": 1,
          "indexOf": 1
        },
        "name": "OnlyTrailingOptionalParameters",
        "body": "self.formalObjectParameters->forAll(p | p.defaultValue->notEmpty() implies Sequence{(self.formalObjectParameters->indexOf(p)+1)..self.formalObjectParameters->size()}->forAll(\r\n    i | self.formalObjectParameters->at(i).defaultValue->notEmpty()))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 7,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "data::classes::Parameter::defaultValue",
          "data::classes::SapClass::formalObjectParameters"
        ]
      },
      {
        "operations": {"adaptedSignaturesExcluding": 1},
        "name": "adaptedSignatures",
        "body": "self.adaptedSignaturesExcluding(Set{})",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "CollectionLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "getAssociationEnds": 1,
          "getConformsToClasses": 1,
          "asSet": 1
        },
        "name": "getConformsToCompositeParentAssociationEnds",
        "body": "self.getConformsToClasses().getAssociationEnds()->select(ae|ae.composite)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::AssociationEnd::composite"]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "asSet": 2
        },
        "name": "getAssociationEnds",
        "body": "self.elementsOfType->collect(associationEnd->asSet())->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::SapClass::elementsOfType",
          "data::classes::ClassTypeDefinition::associationEnd"
        ]
      }
    ],
    "properties": [
      "samStatusVariables",
      "Context",
      "subscription",
      "elementsOfType",
      "adapters",
      "abapAnnotation",
      "behaviouralModel",
      "samDerivators",
      "samStatusSchema",
      "adaptedBy",
      "formalObjectParameters",
      "FormalTypeParameter",
      "signaturesWithFault",
      "parameterization",
      "objectLiteral",
      "actualTypeParametersOfClass",
      "package_",
      "ParameterizedClassInstantiation",
      "converterBetweenParametrizations",
      "timeDependency",
      "samActions",
      "valueType",
      "constraints"
    ]
  },
  {
    "name": "TypeDefinition",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "+": 1,
          "getNestingLevel": 1,
          "oclAsType": 1
        },
        "name": "getNestingLevel",
        "body": "if self.oclIsKindOf(NestedTypeDefinition) then\n    self.oclAsType(NestedTypeDefinition).type.getNestingLevel() + 1\n  else\n    0\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::NestedTypeDefinition::type"]
      },
      {
        "operations": {
          "conformsToIgnoringMultiplicityExcluding": 1,
          "=": 1
        },
        "name": "conformsToIgnoringMultiplicity",
        "body": "if self = typeDef then\n   true\n  else\n    self.conformsToIgnoringMultiplicityExcluding(typeDef, Sequence{}, Sequence{})\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 4,
          "CollectionLiteralExpImpl": 2,
          "IfExpImpl": 1,
          "BooleanLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "<=": 1,
          "not": 2,
          "<>": 1,
          "or": 5,
          "and": 5,
          "isMany": 1,
          "=": 3,
          "-": 2,
          ">=": 1
        },
        "name": "multiplicityConformsTo",
        "body": "-- check for multiplicity conformance\n    -- multiplicity of td must include multiplicity of td\n    td.lowerMultiplicity <= self.lowerMultiplicity\n    and\n    (\n        td.upperMultiplicity = -1\n        or \n        ( td.upperMultiplicity >= self.upperMultiplicity and self.upperMultiplicity <> -1 ) \n    ) \n    \n    -- check for conformance of orderedness and uniqueness\n    -- orderedness/uniqueness of td must be same or more relaxed than self's\n    and\n    (\n       not self.isMany()\n        or\n        ( ( self.ordered = td.ordered ) and ( self.unique = td.unique ) )\n        or\n        ( self.ordered and self.unique )\n        or\n        ( not ( td.ordered or td.unique ) )\n    )",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 15,
          "OperationCallExpImpl": 21,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 14
        },
        "properties": [
          "data::classes::Multiplicity::unique",
          "data::classes::Multiplicity::lowerMultiplicity",
          "data::classes::Multiplicity::upperMultiplicity",
          "data::classes::Multiplicity::ordered"
        ]
      },
      {
        "operations": {
          "oclIsUndefined": 1,
          "multiplicityConformsTo": 1,
          "and": 1,
          "conformsToIgnoringMultiplicityExcluding": 1,
          "=": 1
        },
        "name": "conformsToExcluding",
        "body": "if oclIsUndefined() then\n    false\n  else\n  if self = td then\n    true\n  else\n   self.multiplicityConformsTo(td) and\n   self.conformsToIgnoringMultiplicityExcluding(td, excludingConforming, excludingTo)\n  endif\n endif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 9,
          "OperationCallExpImpl": 5,
          "IfExpImpl": 2,
          "BooleanLiteralExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {
          "getNamedValuesInScope": 3,
          "oclIsKindOf": 3,
          "and": 1,
          "oclAsSet": 2,
          "union": 1,
          "notEmpty": 2,
          "oclAsType": 3
        },
        "name": "getNamedValuesInScope",
        "body": "-- find owner of type definition and collect the named values in scope for the owner\n  (let ownerSig:Signature = self.ownerSignature in\n  if ownerSig->notEmpty() and ownerSig.oclIsKindOf(Signature) then\n    ownerSig.oclAsType(Signature).getNamedValuesInScope()\n  else\n    Set{}   -- some boundary case such as TupleElement or ValueSet not currently supported\n  endif)->union(\n\n  if self.ownerTypedElement->notEmpty() then\n    if self.ownerTypedElement.oclIsKindOf(dataaccess::expressions::Expression) then\n      self.ownerTypedElement.oclAsType(dataaccess::expressions::Expression).getNamedValuesInScope()\n    else\n      if self.ownerTypedElement.oclIsKindOf(NamedValue) then\n        self.ownerTypedElement.oclAsType(NamedValue).getNamedValuesInScope()\n      else\n        Set{}   -- some boundary case such as TupleElement or ValueSet not currently supported\n      endif\n    endif\n  else\n    Set{}\n  endif)",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 15,
          "VariableExpImpl": 9,
          "LetExpImpl": 1,
          "TypeExpImpl": 6,
          "CollectionLiteralExpImpl": 3,
          "IfExpImpl": 4,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "data::classes::TypeDefinition::ownerTypedElement",
          "data::classes::TypeDefinition::ownerSignature"
        ]
      },
      {
        "operations": {
          "oclIsUndefined": 1,
          "conformsToExcluding": 1,
          "=": 1
        },
        "name": "conformsTo",
        "body": "if self.oclIsUndefined() then\n    false\n  else if self = typeDef then\n    true\n  else\n    self.conformsToExcluding(typeDef, Sequence{}, Sequence{})\n  endif\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "CollectionLiteralExpImpl": 2,
          "IfExpImpl": 2,
          "BooleanLiteralExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {
          "oclIsKindOf": 5,
          "and": 4,
          "objectParametersConformTo": 1,
          "conformsToExcluding": 3,
          "oclAsType": 8,
          "=": 1
        },
        "name": "conformsToIgnoringMultiplicityExcluding",
        "body": "if self = td then\n    true\n  else\n   if self.oclIsKindOf(ClassTypeDefinition) then\n    td.oclIsKindOf(ClassTypeDefinition) and\n    self.oclAsType(ClassTypeDefinition).clazz.conformsToExcluding(\n                td.oclAsType(ClassTypeDefinition).clazz, excludingConforming, excludingTo) and\n    self.oclAsType(ClassTypeDefinition).objectParametersConformTo(td.oclAsType(ClassTypeDefinition))\n  else\n    if self.oclIsKindOf(FunctionSignatureTypeDefinition) then\n      td.oclIsKindOf(FunctionSignatureTypeDefinition) and\n      self.oclAsType(FunctionSignatureTypeDefinition).signature.conformsToExcluding(\n           td.oclAsType(FunctionSignatureTypeDefinition).signature, excludingConforming, excludingTo)\n    else\n      td.oclIsKindOf(NestedTypeDefinition) and\n      self.oclAsType(NestedTypeDefinition).type.conformsToExcluding(\n          td.oclAsType(NestedTypeDefinition).type, excludingConforming, excludingTo)\n    endif\n  endif\n endif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 22,
          "VariableExpImpl": 21,
          "TypeExpImpl": 13,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 6,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "data::classes::FunctionSignatureTypeDefinition::signature",
          "data::classes::ClassTypeDefinition::clazz",
          "data::classes::NestedTypeDefinition::type"
        ]
      },
      {
        "operations": {
          "getType": 1,
          "allInstances": 1,
          "=": 1
        },
        "name": "getTypeUsage",
        "body": "TypedElement.allInstances()->select(te | te.getType() = self)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "TypeExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "getInnermost": 1,
          "oclIsKindOf": 1,
          "oclAsType": 1
        },
        "name": "getInnermost",
        "body": "if self.oclIsKindOf(NestedTypeDefinition) then\n    self.oclAsType(NestedTypeDefinition).type.getInnermost()\n  else\n    self\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::NestedTypeDefinition::type"]
      }
    ],
    "properties": [
      "cellSet",
      "ownerTypedElement",
      "ownerSignature",
      "owningNestedTypeDefinition",
      "signaturesWithOutput",
      "NestedTypeDefinition"
    ]
  },
  {
    "name": "LinkSetting",
    "expressions": [{
      "operations": {
        "at": 2,
        "size": 1,
        "getType": 2,
        "oclIsKindOf": 1,
        "and": 3,
        "oclAsSet": 1,
        "isEmpty": 1,
        "=": 2,
        "oclAsType": 1
      },
      "name": "InputTypeMatchEndType",
      "body": "self.implements_.output->isEmpty() and\r\n  self.implements_.input->size() = 1 and \r\n  self.implements_.input->at(1).getType().oclIsKindOf(ClassTypeDefinition) and \r\n  self.implements_.input->at(1).getType().oclAsType(ClassTypeDefinition).clazz = self.end.type.clazz",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 14,
        "VariableExpImpl": 5,
        "IntegerLiteralExpImpl": 3,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 12
      },
      "properties": [
        "data::classes::AssociationEndSignatureImplementation::end",
        "data::classes::Signature::input",
        "data::classes::AssociationEnd::type",
        "data::classes::SignatureImplementation::implements_",
        "data::classes::ClassTypeDefinition::clazz",
        "data::classes::Signature::output"
      ]
    }],
    "properties": []
  },
  {
    "name": "Expression",
    "expressions": [],
    "properties": [
      "Constraint",
      "Parameter",
      "Context"
    ]
  },
  {
    "name": "Parameter",
    "expressions": [{
      "operations": {
        "getType": 2,
        "oclAsSet": 1,
        "conformsTo": 1,
        "notEmpty": 1,
        "implies": 1
      },
      "name": "DefaultValueType",
      "body": "self.defaultValue->notEmpty() implies self.defaultValue.getType().conformsTo(self.getType())",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 3,
        "PropertyCallExpImpl": 2
      },
      "properties": ["data::classes::Parameter::defaultValue"]
    }],
    "properties": [
      "ownerSignature",
      "defaultValue",
      "ActualObjectParameter",
      "parameterOfClass"
    ]
  },
  {
    "name": "Constraint",
    "expressions": [
      {
        "operations": {
          "or": 3,
          "oclAsSet": 4,
          "notEmpty": 4
        },
        "name": "MustBeOwned",
        "body": "self.constrainedType->notEmpty() or\n  self.theContext->notEmpty() or\n  self.preconditionForSignature->notEmpty() or\n  self.postconditionForSignature->notEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "data::constraints::Constraint::theContext",
          "OclInvalid::oclBadProperty",
          "data::constraints::Constraint::constrainedType"
        ]
      },
      {
        "operations": {
          "getType": 3,
          "oclIsKindOf": 1,
          "and": 2,
          "oclAsType": 1,
          "=": 2
        },
        "name": "ExpressionTypeMustBeBoolean",
        "body": "self.constraintExpression.getType().upperMultiplicity = 1 and\r\n  self.constraintExpression.getType().oclIsKindOf(data::classes::ClassTypeDefinition) and\r\n  self.constraintExpression.getType().oclAsType(data::classes::ClassTypeDefinition).clazz.name = 'Boolean'",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 9,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "data::constraints::Constraint::constraintExpression",
          "modelmanagement::NamedElement::name",
          "data::classes::ClassTypeDefinition::clazz",
          "data::classes::Multiplicity::upperMultiplicity"
        ]
      }
    ],
    "properties": [
      "theContext",
      "constraintExpression",
      "constrainedType",
      "severityInState"
    ]
  },
  {
    "name": "TypeAdapter",
    "expressions": [
      {
        "operations": {
          "allSignatures": 1,
          "conformsToExcluding": 1,
          "signaturesWithDelegation": 1
        },
        "name": "conformsTo",
        "body": "type.signaturesWithDelegation()->forAll(typeSig:MethodSignature |\n    self.allSignatures()->exists(selfSig:MethodSignature |\n       selfSig.conformsToExcluding(typeSig, Sequence{self.to}, Sequence{type})))",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 3,
          "CollectionLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::TypeAdapter::to"]
      },
      {
        "operations": {"=": 1},
        "name": "ValuesToValues_EntitiesToEntities",
        "body": "self.adapted.valueType = self.to.valueType",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "data::classes::SapClass::valueType",
          "data::classes::TypeAdapter::adapted",
          "data::classes::TypeAdapter::to"
        ]
      },
      {
        "operations": {
          "not": 1,
          "allSignaturesExcluding": 1,
          "union": 1,
          "conformsTo": 1
        },
        "name": "allSignaturesExcluding",
        "body": "self.to.allSignaturesExcluding(excluding)->select(s |\n    not self.ownedSignatures->exists(os | os.conformsTo(s)))->union(\n  self.ownedSignatures)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 4,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "data::classes::SignatureOwner::ownedSignatures",
          "data::classes::TypeAdapter::to"
        ]
      },
      {
        "operations": {
          "or": 1,
          "signaturesWithDelegation": 2,
          "conformsTo": 2
        },
        "name": "IsFullAdaptationToTo",
        "body": "self.to.signaturesWithDelegation()->forAll(toSig|\r\n    self.adapted.signaturesWithDelegation()->exists(adaptedSig|\r\n      adaptedSig.conformsTo(toSig))\r\n    or self.ownedSignatures->exists(ownedSig|\r\n      ownedSig.conformsTo(toSig)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 5,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "data::classes::SignatureOwner::ownedSignatures",
          "data::classes::TypeAdapter::adapted",
          "data::classes::TypeAdapter::to"
        ]
      },
      {
        "operations": {
          "at": 2,
          "or": 1,
          "size": 1,
          "allSignatures": 1,
          "and": 1,
          "signaturesWithDelegation": 1,
          "conformsToExcluding": 1,
          "=": 2,
          "append": 2,
          "asSequence": 4
        },
        "name": "conformsToExcluding",
        "body": "Sequence{1..excludingConforming->size()}->exists(i|\n  excludingConforming->asSequence()->at(i) = self.to and excludingTo->asSequence()->at(i) = type) or\n  type.signaturesWithDelegation()->forAll(typeSig:MethodSignature |\n         self.allSignatures()->exists(selfSig:MethodSignature |\n            selfSig.conformsToExcluding(typeSig,\n                    excludingConforming->asSequence()->append(self.to),\n                    excludingTo->asSequence()->append(type))))",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 15,
          "OperationCallExpImpl": 16,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["data::classes::TypeAdapter::to"]
      },
      {
        "operations": {
          "signaturesWithDelegation": 1,
          "conformsTo": 1
        },
        "name": "AllSignatureConforms",
        "body": "self.ownedSignatures->forAll(selfSig:MethodSignature |\r\n    self.to.signaturesWithDelegation()->exists(toSig:MethodSignature |\r\n       selfSig.conformsTo(toSig)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::SignatureOwner::ownedSignatures",
          "data::classes::TypeAdapter::to"
        ]
      },
      {
        "operations": {
          "not": 1,
          "isAbstract": 1
        },
        "name": "SignaturesCannotBeAbstract",
        "body": "self.ownedSignatures->forAll(selfSig:MethodSignature | not selfSig.isAbstract())",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::SignatureOwner::ownedSignatures"]
      },
      {
        "operations": {"allSignaturesExcluding": 1},
        "name": "allSignatures",
        "body": "self.allSignaturesExcluding(Set{})",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "CollectionLiteralExpImpl": 1
        },
        "properties": []
      }
    ],
    "properties": [
      "adapted",
      "to"
    ]
  },
  {
    "name": "Severity",
    "expressions": [],
    "properties": []
  },
  {
    "name": "FunctionSignature",
    "expressions": [
      {
        "operations": {
          "isEmpty": 1,
          "oclAsSet": 1
        },
        "name": "isAbstract",
        "body": "self.implementation->isEmpty()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["data::classes::FunctionSignature::implementation"]
      },
      {
        "operations": {
          "at": 1,
          "isEmpty": 1,
          "oclAsType": 1,
          "asSequence": 1
        },
        "name": "getImplementedAnonymousFunctionExpression",
        "body": "let candidates:Sequence(dataaccess::expressions::fp::AnonymousFunctionExpr) =\n         self.typeDefinition.ownerTypedElement.oclAsType(dataaccess::expressions::fp::AnonymousFunctionExpr)->asSequence() in\n  if candidates->isEmpty() then\n    null\n  else\n    candidates->at(1)\n  endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 4,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::TypeDefinition::ownerTypedElement",
          "data::classes::Signature::typeDefinition"
        ]
      }
    ],
    "properties": [
      "implementation",
      "dimension",
      "cellSetForAggregationFunction",
      "cellSetForValueFunction"
    ]
  },
  {
    "name": "Context",
    "expressions": [
      {
        "operations": {
          "getType": 3,
          "oclIsKindOf": 1,
          "and": 2,
          "=": 2,
          "oclAsType": 1
        },
        "name": "ConditionMustBeBoolean",
        "body": "self.condition.getType().upperMultiplicity = 1 and\r\n  self.condition.getType().oclIsKindOf(ClassTypeDefinition) and\r\n  self.condition.getType().oclAsType(ClassTypeDefinition).clazz.name = 'Boolean'",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "modelmanagement::NamedElement::name",
          "data::classes::Context::condition",
          "data::classes::ClassTypeDefinition::clazz",
          "data::classes::Multiplicity::upperMultiplicity"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "ConstraintForRightClass",
        "body": "self.constraints->forAll(c | c.constrainedType = self.for_)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "data::classes::Context::for_",
          "data::classes::Context::constraints",
          "data::constraints::Constraint::constrainedType"
        ]
      }
    ],
    "properties": [
      "for_",
      "constraints",
      "condition"
    ]
  },
  {
    "name": "LinkTraversal",
    "expressions": [
      {
        "operations": {},
        "name": "MustBeNavigable",
        "body": "self.end.navigable",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "data::classes::AssociationEndSignatureImplementation::end",
          "data::classes::AssociationEnd::navigable"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 2,
          "isEmpty": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "OutputTypeMatchEndType",
        "body": "self.implements_.input->isEmpty() and\r\n  self.implements_.output.oclIsKindOf(ClassTypeDefinition) and \r\n  self.implements_.output.oclAsType(ClassTypeDefinition).clazz = self.end.type.clazz",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 4,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "data::classes::AssociationEndSignatureImplementation::end",
          "data::classes::Signature::input",
          "data::classes::AssociationEnd::type",
          "data::classes::SignatureImplementation::implements_",
          "data::classes::ClassTypeDefinition::clazz",
          "data::classes::Signature::output"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "PlatformSpecificImplementation",
    "expressions": [],
    "properties": [
      "implementation",
      "targetPlatform",
      "NativeImpl"
    ]
  },
  {
    "name": "SignatureOwner",
    "expressions": [],
    "properties": ["ownedSignatures"]
  },
  {
    "name": "FunctionSignatureTypeDefinition",
    "expressions": [],
    "properties": [
      "signature",
      "ownedSignature"
    ]
  },
  {
    "name": "TimeDependency",
    "expressions": [{
      "operations": {">=": 1},
      "name": "RecordCutoffGreaterOrEqualZero",
      "body": "self.recordCutoffInMilliseconds >= 0",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["data::timedependency::TimeDependency::recordCutoffInMilliseconds"]
    }],
    "properties": [
      "theClass",
      "recordCutoffInMilliseconds",
      "canChangePast",
      "timespan",
      "association"
    ]
  }
]
