[
  {
    "name": "HaxeVariableDeclarationExpression",
    "expressions": [],
    "properties": ["groups"]
  },
  {
    "name": "HaxePackageAccess",
    "expressions": [],
    "properties": [
      "HaxePackageAccess",
      "qualifier"
    ]
  },
  {
    "name": "HaxeTryExpression",
    "expressions": [],
    "properties": [
      "catchClauses",
      "theBody"
    ]
  },
  {
    "name": "HaxeTypedElement",
    "expressions": [],
    "properties": ["type"]
  },
  {
    "name": "HaxeInfixExpression",
    "expressions": [],
    "properties": [
      "operator",
      "extendedSide"
    ]
  },
  {
    "name": "HaxeTarget",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeConstant",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeNumberLiteral",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "HaxeExpression",
    "expressions": [],
    "properties": [
      "HaxeSwitch",
      "HaxeCastingExpression",
      "HaxeFieldDeclaration",
      "HaxeIfStatement",
      "HaxeArrayAccess",
      "HaxeArrayAccess",
      "HaxeLoopStatement",
      "HaxeLoopStatement",
      "HaxeExpressionStatement",
      "HaxeCase",
      "HaxeCallExpression",
      "HaxeUnaryExpression",
      "HaxeVariableDeclarationGroup",
      "HaxeCatchClause",
      "HaxeInExpression",
      "HaxeMethodInvocation",
      "HaxeConditionalExpression",
      "HaxeBinaryExpression",
      "HaxeCallExpression",
      "HaxeArrayInitializer",
      "HaxeSwitch",
      "HaxeBinaryExpression",
      "HaxeCase",
      "HaxeMetadata",
      "HaxeParenthizedExpression",
      "HaxeFieldAccess",
      "HaxeVariableDeclaration",
      "HaxeTypeCheckExpression",
      "HaxeTernaryExpression",
      "HaxeUnsafeCastExpression",
      "HaxeArrayCreation",
      "HaxeBlock",
      "HaxeInfixExpression",
      "HaxeAbstractMethodInvocation",
      "HaxeTryExpression",
      "HaxeSingleVariableAccess",
      "HaxeAbstractFunction",
      "HaxeConditionalExpression"
    ]
  },
  {
    "name": "HaxeComment",
    "expressions": [],
    "properties": [
      "prefixOfParent",
      "HaxeType",
      "enclosedByParent",
      "lineComment",
      "HaxeModule",
      "HaxeType",
      "HaxeASTNode",
      "content"
    ]
  },
  {
    "name": "HaxeConstructor",
    "expressions": [{
      "operations": {"oclAsType": 1},
      "name": "constructedClass",
      "body": "fieldContainer.oclAsType(HaxeClass)",
      "type": "PropertyImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["haxe::HaxeField::fieldContainer"]
    }],
    "properties": [
      "HaxeClassifier",
      "constructedClass"
    ]
  },
  {
    "name": "HaxeModelElement",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeFieldContainer",
    "expressions": [],
    "properties": ["haxeFields"]
  },
  {
    "name": "HaxePrefixExpression",
    "expressions": [],
    "properties": ["operator"]
  },
  {
    "name": "HaxeSuperConstructorInvocation",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeMetadata",
    "expressions": [],
    "properties": [
      "parameters",
      "usedIn",
      "compilerMetadata"
    ]
  },
  {
    "name": "HaxePostfixExpression",
    "expressions": [],
    "properties": ["isIncrement"]
  },
  {
    "name": "HaxeSwitch",
    "expressions": [],
    "properties": [
      "cases",
      "expression",
      "default"
    ]
  },
  {
    "name": "HaxeTextElement",
    "expressions": [],
    "properties": ["text"]
  },
  {
    "name": "HaxeEmptyStatement",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeFunctionExpression",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeArrayAccess",
    "expressions": [],
    "properties": [
      "array",
      "index"
    ]
  },
  {
    "name": "HaxeMetadataContainer",
    "expressions": [],
    "properties": ["metadata"]
  },
  {
    "name": "HaxeUnaryExpression",
    "expressions": [],
    "properties": ["operand"]
  },
  {
    "name": "HaxeVariableDeclarationGroup",
    "expressions": [],
    "properties": [
      "initializer",
      "fragments",
      "container"
    ]
  },
  {
    "name": "HaxeSingleVariableAccess",
    "expressions": [],
    "properties": [
      "qualifier",
      "variable",
      "HaxeFieldAccess"
    ]
  },
  {
    "name": "HaxeParenthizedExpression",
    "expressions": [],
    "properties": ["expression"]
  },
  {
    "name": "HaxeTypeCheckExpression",
    "expressions": [],
    "properties": [
      "expression",
      "type"
    ]
  },
  {
    "name": "HaxeAbstract",
    "expressions": [{
      "operations": {"matches": 1},
      "name": "abstractNameRegex",
      "body": "name.matches('[A-Z][A-Za-z_-]*')",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["haxe::HaxeNamedElement::name"]
    }],
    "properties": [
      "directCastingToType",
      "directCastingFromType",
      "underlyingType"
    ]
  },
  {
    "name": "HaxeSingleVariableDeclaration",
    "expressions": [],
    "properties": [
      "isOptional",
      "HaxeAbstractFunction",
      "HaxeEnumConstructor",
      "HaxeInExpression",
      "catchClause",
      "HaxeForStatement"
    ]
  },
  {
    "name": "HaxeOperation",
    "expressions": [],
    "properties": [
      "macro",
      "HaxeAttribute",
      "HaxeAttribute",
      "HaxeClassifier"
    ]
  },
  {
    "name": "HaxeImportDeclaration",
    "expressions": [{
      "operations": {
        "oclAsSet": 1,
        "notEmpty": 1
      },
      "name": "isAStaticElement",
      "body": "if (self.staticElement\n\t\t\t\t->notEmpty())\n\t\t\tthen self.staticElement.isStatic\n\t\t\telse true\n\t\t\tendif",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 2,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 3,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "haxe::HaxeImportDeclaration::staticElement",
        "haxe::HaxeField::isStatic"
      ]
    }],
    "properties": ["staticElement"]
  },
  {
    "name": "HaxeHaxedocComment",
    "expressions": [],
    "properties": ["tags"]
  },
  {
    "name": "HaxeWhileStatement",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeSuperMethodInvocation",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeVariableDeclarationFragment",
    "expressions": [],
    "properties": ["variablesContainer"]
  },
  {
    "name": "HaxeAbstractMethodInvocation",
    "expressions": [],
    "properties": [
      "arguments",
      "typeArguments",
      "method"
    ]
  },
  {
    "name": "HaxeModel",
    "expressions": [
      {
        "operations": {
          "size": 1,
          ">": 1
        },
        "name": "targetFolderNotEmpty",
        "body": "targetFolder.size() > 0",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeModel::targetFolder"]
      },
      {
        "operations": {
          "size": 1,
          ">": 1
        },
        "name": "sourceFolderNotEmpty",
        "body": "sourceFolder.size() > 0",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeModel::sourceFolder"]
      },
      {
        "operations": {
          "size": 1,
          ">": 1
        },
        "name": "nameNotEmpty",
        "body": "name.size() > 0",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeModel::name"]
      },
      {
        "operations": {"<>": 1},
        "name": "nameNotNull",
        "body": "name <> null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeModel::name"]
      },
      {
        "operations": {
          "not": 1,
          "and": 2,
          "isEmpty": 2,
          "matches": 1
        },
        "name": "mainClassHasMainMethod",
        "body": "not (mainClass.haxeOperations\n\t\t\t->select(x : HaxeOperation | (x.name.matches('main') and x.isStatic and x.formalParameters\n\t\t\t\t->isEmpty()))\n\t\t\t->isEmpty())",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 4,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "haxe::HaxeNamedElement::name",
          "haxe::HaxeClassifier::haxeOperations",
          "haxe::HaxeModel::mainClass",
          "haxe::HaxeField::isStatic",
          "haxe::HaxeAbstractFunction::formalParameters"
        ]
      }
    ],
    "properties": [
      "elements",
      "mainClass",
      "name",
      "targetFolder",
      "haxeModules",
      "referenced",
      "sourceFolder",
      "target"
    ]
  },
  {
    "name": "HaxeUnsafeCastExpression",
    "expressions": [],
    "properties": ["expression"]
  },
  {
    "name": "HaxeExpressionStatement",
    "expressions": [],
    "properties": ["expression"]
  },
  {
    "name": "HaxeCallExpression",
    "expressions": [],
    "properties": [
      "expression",
      "arguments"
    ]
  },
  {
    "name": "HaxeAttributeProperty",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeAssignment",
    "expressions": [],
    "properties": ["operator"]
  },
  {
    "name": "HaxePrefixOperators",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeType",
    "expressions": [],
    "properties": [
      "private",
      "commentsAfterDeclaration",
      "typeParameters",
      "extern",
      "commentsBeforeDeclaration",
      "HaxePackage",
      "containerModule"
    ]
  },
  {
    "name": "HaxeTypedef",
    "expressions": [],
    "properties": ["refType"]
  },
  {
    "name": "HaxeFieldAccess",
    "expressions": [],
    "properties": [
      "expression",
      "field"
    ]
  },
  {
    "name": "HaxeTypeParameter",
    "expressions": [],
    "properties": [
      "HaxeAbstractFunction",
      "bounds",
      "HaxeType"
    ]
  },
  {
    "name": "HaxeField",
    "expressions": [],
    "properties": [
      "isStatic",
      "HaxeImportDeclaration",
      "fieldContainer",
      "HaxeUsingDeclaration",
      "isPrivate"
    ]
  },
  {
    "name": "HaxeEnumConstructor",
    "expressions": [{
      "operations": {
        "oclAsSet": 1,
        "isEmpty": 1
      },
      "name": "noInitializer",
      "body": "initializer->isEmpty()",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["haxe::HaxeVariableDeclaration::initializer"]
    }],
    "properties": [
      "parameters",
      "HaxeEnum"
    ]
  },
  {
    "name": "HaxeInExpression",
    "expressions": [],
    "properties": [
      "expression",
      "variable"
    ]
  },
  {
    "name": "HaxeCatchClause",
    "expressions": [],
    "properties": [
      "theBody",
      "HaxeTryExpression",
      "exception"
    ]
  },
  {
    "name": "HaxeVariableDeclaration",
    "expressions": [{
      "operations": {"matches": 1},
      "name": "variableNameRegex",
      "body": "name.matches('[a-zA-Z_][a-zA-Z0-9_]*')",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["haxe::HaxeNamedElement::name"]
    }],
    "properties": [
      "initializer",
      "usageInVariableAccess"
    ]
  },
  {
    "name": "HaxeInfixOperators",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeEnum",
    "expressions": [
      {
        "operations": {"oclIsTypeOf": 1},
        "name": "onlyLiterals",
        "body": "self.haxeFields->forAll(x|x.oclIsTypeOf(HaxeEnumConstructor))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeFieldContainer::haxeFields"]
      },
      {
        "operations": {
          "oclIsTypeOf": 1,
          "oclAsType": 1
        },
        "name": "literals",
        "body": "self.haxeFields->select(e : HaxeField | e.oclIsTypeOf(HaxeEnumConstructor)).oclAsType(HaxeEnumConstructor)",
        "type": "PropertyImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeFieldContainer::haxeFields"]
      }
    ],
    "properties": ["literals"]
  },
  {
    "name": "HaxeClass",
    "expressions": [
      {
        "operations": {
          "oclIsUndefined": 1,
          "and": 1,
          "isEmpty": 1,
          "implies": 1
        },
        "name": "interfaceMethods",
        "body": "(isInterface) implies (haxeConstructors\n\t\t\t->isEmpty() and haxeOperations\n\t\t\t->forAll(x : HaxeOperation | x.theBody.oclIsUndefined()))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "haxe::HaxeClassifier::haxeOperations",
          "haxe::HaxeClassifier::haxeConstructors",
          "haxe::HaxeAbstractFunction::theBody",
          "haxe::HaxeClass::isInterface"
        ]
      },
      {
        "operations": {"matches": 1},
        "name": "classNameRegex",
        "body": "name.matches('[A-Z][A-Za-z_-]*')",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeNamedElement::name"]
      },
      {
        "operations": {
          "not": 1,
          "size": 1,
          "<": 1,
          "implies": 1
        },
        "name": "oneOrZeroConstructors",
        "body": "(not extern) implies haxeConstructors\n\t\t\t->size() < 2",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "haxe::HaxeClassifier::haxeConstructors",
          "haxe::HaxeType::extern"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsUndefined": 2,
          "and": 1,
          "oclAsSet": 2,
          "implies": 1
        },
        "name": "externDeclaration",
        "body": "extern implies (haxeOperations\n\t\t\t->forAll(x : HaxeOperation | not x.type\n\t\t\t\t->oclIsUndefined() and x.theBody\n\t\t\t\t->oclIsUndefined()))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "haxe::HaxeClassifier::haxeOperations",
          "haxe::HaxeAbstractFunction::theBody",
          "haxe::HaxeType::extern",
          "haxe::HaxeTypedElement::type"
        ]
      }
    ],
    "properties": [
      "HaxeConstructor",
      "generalization",
      "HaxeModel",
      "isInterface",
      "implementation"
    ]
  },
  {
    "name": "HaxeStringLiteral",
    "expressions": [],
    "properties": ["escapedValue"]
  },
  {
    "name": "HaxeBooleanLiteral",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "HaxeUsingDeclaration",
    "expressions": [{
      "operations": {},
      "name": "isAStaticElement",
      "body": "self.staticField.isStatic",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "haxe::HaxeUsingDeclaration::staticField",
        "haxe::HaxeField::isStatic"
      ]
    }],
    "properties": ["staticField"]
  },
  {
    "name": "HaxeObjectDeclaration",
    "expressions": [],
    "properties": [
      "extendsType",
      "fields"
    ]
  },
  {
    "name": "HaxeBlock",
    "expressions": [{
      "operations": {"isEmpty": 1},
      "name": "isEmpty",
      "body": "statements->isEmpty()",
      "type": "OperationImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["haxe::HaxeBlock::statements"]
    }],
    "properties": ["statements"]
  },
  {
    "name": "HaxeTernaryExpression",
    "expressions": [],
    "properties": ["elseExpression"]
  },
  {
    "name": "HaxeForStatement",
    "expressions": [],
    "properties": ["parameter"]
  },
  {
    "name": "HaxeNullLiteral",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeIdentifierLiteral",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "HaxeLoopStatement",
    "expressions": [],
    "properties": [
      "expression",
      "theBody"
    ]
  },
  {
    "name": "HaxeRegexLiteral",
    "expressions": [],
    "properties": [
      "options",
      "pattern"
    ]
  },
  {
    "name": "HaxeFieldDeclaration",
    "expressions": [],
    "properties": [
      "HaxeObjectDeclaration",
      "value"
    ]
  },
  {
    "name": "HaxeClassifier",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsType": 1
        },
        "name": "haxeAttribute",
        "body": "self.haxeFields\n\t\t\t\t->select(e : HaxeField | e.oclIsKindOf(HaxeAttribute)).oclAsType(HaxeAttribute)",
        "type": "PropertyImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeFieldContainer::haxeFields"]
      },
      {
        "operations": {
          "oclIsTypeOf": 1,
          "oclAsType": 1
        },
        "name": "haxeOperations",
        "body": "self.haxeFields\n\t\t\t\t->select(e : HaxeField | e.oclIsTypeOf(HaxeOperation)).oclAsType(HaxeOperation)",
        "type": "PropertyImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeFieldContainer::haxeFields"]
      },
      {
        "operations": {"oclIsUndefined": 1},
        "name": "containerPackage",
        "body": "if (containerModule.oclIsUndefined())\n\t\t\t\tthen null\n\t\t\t\telse containerModule.thePackage\n\t\t\t\tendif",
        "type": "PropertyImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "haxe::HaxeModule::thePackage",
          "haxe::HaxeType::containerModule"
        ]
      },
      {
        "operations": {
          "oclIsTypeOf": 1,
          "oclAsType": 1
        },
        "name": "haxeConstructors",
        "body": "haxeFields\n\t\t\t\t->select(m : HaxeField | m.oclIsTypeOf(HaxeConstructor)).oclAsType(HaxeConstructor)",
        "type": "PropertyImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeFieldContainer::haxeFields"]
      }
    ],
    "properties": [
      "haxeOperations",
      "haxeConstructors",
      "containerPackage",
      "haxeAttribute"
    ]
  },
  {
    "name": "HaxeThisExpression",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeAbstractFunction",
    "expressions": [],
    "properties": [
      "theBody",
      "typeParameters",
      "formalParameters"
    ]
  },
  {
    "name": "HaxeCase",
    "expressions": [],
    "properties": [
      "expression",
      "HaxeSwitch",
      "values"
    ]
  },
  {
    "name": "HaxeArrayInitializer",
    "expressions": [],
    "properties": [
      "HaxeArrayCreation",
      "expressions"
    ]
  },
  {
    "name": "HaxePathReferentiable",
    "expressions": [],
    "properties": [
      "parentReference",
      "HaxeModel",
      "referencedIn",
      "HaxeModel"
    ]
  },
  {
    "name": "HaxeDependencyDeclaration",
    "expressions": [],
    "properties": ["HaxeModule"]
  },
  {
    "name": "HaxeBinaryExpression",
    "expressions": [],
    "properties": [
      "leftSide",
      "rightSide"
    ]
  },
  {
    "name": "HaxeThrowExpression",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeTypeAccess",
    "expressions": [],
    "properties": [
      "HaxeAbstract",
      "HaxeArrayCreation",
      "HaxeAbstract",
      "HaxeAbstract",
      "HaxeCastingExpression",
      "HaxeTypedElement",
      "HaxeFunctionTypeAccess",
      "HaxeTypeCheckExpression",
      "HaxeTypedef",
      "HaxeFunctionTypeAccess",
      "HaxeClassifierAccess",
      "HaxeObjectDeclaration",
      "HaxeAbstractMethodInvocation",
      "HaxeTypeParameter"
    ]
  },
  {
    "name": "HaxeFunctionTypeAccess",
    "expressions": [],
    "properties": [
      "argumentTypes",
      "returnType"
    ]
  },
  {
    "name": "HaxeConditionalExpression",
    "expressions": [],
    "properties": [
      "expression",
      "thenStatement"
    ]
  },
  {
    "name": "HaxePackage",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsType": 1
        },
        "name": "containedTypes",
        "body": "childrenReferences\n\t\t\t\t->select(x | x.oclIsKindOf(HaxeType))\n\t\t\t\t->collect(x | x.oclAsType(HaxeType))",
        "type": "PropertyImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxePackage::childrenReferences"]
      },
      {
        "operations": {"matches": 1},
        "name": "packageNameRegex",
        "body": "name.matches('[a-z][A-Z0-9a-z_-]*')",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxeNamedElement::name"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsType": 1
        },
        "name": "childrenPackages",
        "body": "childrenReferences\n\t\t\t\t->select(x | x.oclIsKindOf(HaxePackage))\n\t\t\t\t->collect(x | x.oclAsType(HaxePackage))",
        "type": "PropertyImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["haxe::HaxePackage::childrenReferences"]
      }
    ],
    "properties": [
      "childrenPackages",
      "childrenReferences",
      "containedTypes",
      "HaxeModule",
      "HaxePackage",
      "HaxeClassifier"
    ]
  },
  {
    "name": "HaxeClassifierAccess",
    "expressions": [],
    "properties": [
      "parameterMapping",
      "HaxeClass",
      "HaxeClass"
    ]
  },
  {
    "name": "HaxeASTNode",
    "expressions": [],
    "properties": [
      "comments",
      "HaxeTagElement"
    ]
  },
  {
    "name": "HaxeReturn",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeBreak",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeTagElement",
    "expressions": [],
    "properties": [
      "fragments",
      "HaxeHaxedocComment",
      "tagName"
    ]
  },
  {
    "name": "HaxeArrayCreation",
    "expressions": [],
    "properties": [
      "dimensions",
      "initializer",
      "type"
    ]
  },
  {
    "name": "HaxePathReference",
    "expressions": [],
    "properties": ["referencedTerminal"]
  },
  {
    "name": "HaxeMethodInvocation",
    "expressions": [],
    "properties": ["expression"]
  },
  {
    "name": "HaxeAssignmentOperator",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeNamedElement",
    "expressions": [{
      "operations": {
        "size": 1,
        ">": 1
      },
      "name": "nameNotEmpty",
      "body": "name.size() > 0",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 2,
        "IntegerLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["haxe::HaxeNamedElement::name"]
    }],
    "properties": ["name"]
  },
  {
    "name": "HaxeCastingExpression",
    "expressions": [],
    "properties": [
      "expression",
      "type"
    ]
  },
  {
    "name": "HaxeDoWhileStatement",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeModule",
    "expressions": [{
      "operations": {"matches": 1},
      "name": "moduleNameRegex",
      "body": "name.matches('[A-Z][A-Z0-9a-z_-]*')",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["haxe::HaxeNamedElement::name"]
    }],
    "properties": [
      "commentList",
      "thePackage",
      "HaxeModel",
      "dependencies",
      "theElements"
    ]
  },
  {
    "name": "HaxeAbstractOperation",
    "expressions": [],
    "properties": [
      "isInline",
      "HaxeAbstractMethodInvocation",
      "overrides"
    ]
  },
  {
    "name": "HaxeContinue",
    "expressions": [],
    "properties": []
  },
  {
    "name": "HaxeIfStatement",
    "expressions": [],
    "properties": ["elseStatement"]
  },
  {
    "name": "HaxeAttribute",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "oclIsUndefined": 1,
          "concat": 1,
          "implies": 1,
          "matches": 1,
          "=": 1
        },
        "name": "coherentSetter",
        "body": "(setterProperty = HaxeAttributeProperty::method) implies if (not\n\t\t\t\tself.setter.oclIsUndefined())\n\t\t\tthen (setter.name).matches('set_'.concat(name))\n\t\t\telse true\n\t\t\tendif",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 4,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 5,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "haxe::HaxeNamedElement::name",
          "haxe::HaxeAttribute::setter",
          "haxe::HaxeAttribute::setterProperty"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsUndefined": 1,
          "concat": 1,
          "implies": 1,
          "=": 1,
          "matches": 1
        },
        "name": "coherentGetter",
        "body": "(getterProperty = HaxeAttributeProperty::method) implies if (not\n\t\t\t\tself.getter.oclIsUndefined())\n\t\t\tthen (getter.name).matches('get_'.concat(name))\n\t\t\telse true\n\t\t\tendif",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 4,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 5,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "haxe::HaxeNamedElement::name",
          "haxe::HaxeAttribute::getter",
          "haxe::HaxeAttribute::getterProperty"
        ]
      }
    ],
    "properties": [
      "HaxeClassifier",
      "setter",
      "setterProperty",
      "getter",
      "getterProperty"
    ]
  }
]
