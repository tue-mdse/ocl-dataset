[
  {
    "name": "ValueSpecification",
    "expressions": [],
    "properties": [
      "InteractionOperand",
      "Message",
      "ExecutionStatement",
      "ParameterValueMapping",
      "Constraint"
    ]
  },
  {
    "name": "FragmentContainer",
    "expressions": [],
    "properties": ["fragments"]
  },
  {
    "name": "AssociationEnd",
    "expressions": [
      {
        "operations": {
          "<>": 2,
          "and": 1
        },
        "name": "uniqueName",
        "body": "Tuple {\n\tmessage : String = 'AssociationEnds of a class must be unique',\n\tstatus : Boolean = self.classifier.associationEnds->select(associationEnd : AssociationEnd | associationEnd.name <> null and associationEnd.name <> '')->isUnique(name)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "ram::Classifier::associationEnds",
          "ram::NamedElement::name",
          "$$::Tuple::status",
          "ram::AssociationEnd::classifier"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "at": 1
        },
        "name": "getType",
        "body": "self.assoc.ends->select(end : AssociationEnd | end <> self)->at(1).classifier",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::Association::ends",
          "ram::AssociationEnd::classifier",
          "ram::AssociationEnd::assoc"
        ]
      }
    ],
    "properties": [
      "navigable",
      "classifier",
      "assoc"
    ]
  },
  {
    "name": "RInt",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Integer'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getName",
        "body": "'int'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "ImplementationClass",
    "expressions": [],
    "properties": [
      "instanceClassName",
      "interface"
    ]
  },
  {
    "name": "LiteralInteger",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "MessageOccurrenceSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ParameterValueMapping",
    "expressions": [{
      "operations": {
        "not": 1,
        "oclIsUndefined": 1,
        "oclIsTypeOf": 4,
        "getType": 1,
        "oclIsKindOf": 1,
        "oclAsType": 4,
        "oclType": 1
      },
      "name": "validParameterValue",
      "body": "Tuple {\n\tmessage : String = 'Type of value must match the type of the parameter',\n\tstatus : Boolean = if self.value.oclIsTypeOf(StructuralFeatureValue) then let value : StructuralFeatureValue = self.value.oclAsType(StructuralFeatureValue).value in if not value.oclIsUndefined() then let type : Type = if value.oclIsTypeOf(Attribute) then value.oclAsType(Attribute).type else if value.oclIsTypeOf(Reference) then value.oclAsType(Reference).type else value.oclAsType(AssociationEnd).getType() endif endif in type.oclIsTypeOf(self.parameter.type.oclType()) else true endif else if self.value.oclIsKindOf(LiteralSpecification) then false else true endif endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 11,
        "OperationCallExpImpl": 13,
        "LetExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "TypeExpImpl": 8,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 5,
        "PropertyCallExpImpl": 9,
        "BooleanLiteralExpImpl": 3
      },
      "properties": [
        "ram::ParameterValueMapping::parameter",
        "ram::Attribute::type",
        "$$::Tuple::status",
        "ram::Reference::type",
        "ram::StructuralFeatureValue::value",
        "ram::ParameterValueMapping::value",
        "ram::Parameter::type"
      ]
    }],
    "properties": [
      "parameter",
      "Message",
      "value"
    ]
  },
  {
    "name": "TransitionSubstitution",
    "expressions": [],
    "properties": [
      "from",
      "to"
    ]
  },
  {
    "name": "InteractionFragment",
    "expressions": [{
      "operations": {
        "not": 1,
        "size": 1,
        "oclIsTypeOf": 1,
        "and": 1,
        "notEmpty": 1,
        "=": 1
      },
      "name": "validCoveredMultiplicity",
      "body": "Tuple {\n\tmessage : String = 'InteractionFragment may only have one Lifeline it covers (except CombinedFragment)',\n\tstatus : Boolean = if not self.oclIsTypeOf(CombinedFragment) and covered->notEmpty() then covered->size() = 1 else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 3,
        "TupleLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 3,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "$$::Tuple::status",
        "ram::InteractionFragment::covered"
      ]
    }],
    "properties": [
      "container",
      "covered"
    ]
  },
  {
    "name": "RFloat",
    "expressions": [
      {
        "operations": {},
        "name": "getName",
        "body": "'float'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Float'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "StructuralFeatureValue",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "StateView",
    "expressions": [],
    "properties": [
      "stateMachines",
      "Aspect",
      "specifies"
    ]
  },
  {
    "name": "Association",
    "expressions": [],
    "properties": [
      "ends",
      "StructuralView"
    ]
  },
  {
    "name": "LiteralBoolean",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "MappableElement",
    "expressions": [],
    "properties": ["Aspect"]
  },
  {
    "name": "PrimitiveType",
    "expressions": [],
    "properties": ["Attribute"]
  },
  {
    "name": "RCollection",
    "expressions": [{
      "operations": {
        "lastIndexOf": 1,
        "oclIsUndefined": 1,
        "or": 1,
        "size": 1,
        "oclIsTypeOf": 2,
        "and": 2,
        "toString": 1,
        "+": 5,
        "oclAsType": 2,
        "substring": 1,
        "oclType": 1
      },
      "name": "getName",
      "body": "let partial : String = if type.oclIsTypeOf(Class) and type.oclAsType(Class).partial or type.oclIsTypeOf(Operation) and type.oclAsType(Operation).partial then '|' else '' endif in let typeName : String = self.oclType().toString() in let name : String = typeName.substring(typeName.lastIndexOf(':') + 2, typeName.size()) in if type.name.oclIsUndefined() then name else name + '<' + partial + type.name + '>' endif",
      "type": "OperationImpl",
      "constructs": {
        "VariableExpImpl": 13,
        "OperationCallExpImpl": 18,
        "LetExpImpl": 3,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 4,
        "StringLiteralExpImpl": 5,
        "IfExpImpl": 2,
        "PropertyCallExpImpl": 10
      },
      "properties": [
        "ram::RCollection::type",
        "ram::NamedElement::name",
        "ram::Operation::partial",
        "ram::Class::partial"
      ]
    }],
    "properties": ["type"]
  },
  {
    "name": "MessageSort",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Visibility",
    "expressions": [],
    "properties": []
  },
  {
    "name": "RString",
    "expressions": [
      {
        "operations": {},
        "name": "getName",
        "body": "'String'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.String'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "Classifier",
    "expressions": [],
    "properties": [
      "StructuralView",
      "StateView",
      "associationEnds",
      "Class",
      "typeParameters",
      "ClassifierMapping",
      "operations",
      "ClassifierMapping"
    ]
  },
  {
    "name": "REnumLiteral",
    "expressions": [],
    "properties": ["enum"]
  },
  {
    "name": "Parameter",
    "expressions": [{
      "operations": {
        "not": 1,
        "oclIsTypeOf": 1
      },
      "name": "notVoid",
      "body": "Tuple {\n\tmessage : String = 'The type of the parameter may not be void',\n\tstatus : Boolean = not self.type.oclIsTypeOf(RVoid)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "$$::Tuple::status",
        "ram::Parameter::type"
      ]
    }],
    "properties": [
      "Operation",
      "ParameterValueMapping",
      "ParameterValue",
      "ParameterMapping",
      "ParameterMapping",
      "type"
    ]
  },
  {
    "name": "OpaqueExpression",
    "expressions": [],
    "properties": [
      "body",
      "language"
    ]
  },
  {
    "name": "ExecutionStatement",
    "expressions": [],
    "properties": ["specification"]
  },
  {
    "name": "EObject",
    "expressions": [],
    "properties": [
      "ContainerMap",
      "ElementMap"
    ]
  },
  {
    "name": "NamedElement",
    "expressions": [{
      "operations": {
        "<>": 1,
        "oclIsTypeOf": 1,
        "and": 1,
        "=": 1,
        "oclAsType": 1
      },
      "name": "validName",
      "body": "Tuple {\n\tmessage : String = 'Name of RAM elements may not be empty',\n\tstatus : Boolean = if self.oclIsTypeOf(AssociationEnd) and self.oclAsType(AssociationEnd).navigable = false then true else self.name <> '' endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 5,
        "VariableExpImpl": 3,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 2,
        "TypeExpImpl": 2,
        "IfExpImpl": 1,
        "BooleanLiteralExpImpl": 2,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "ram::AssociationEnd::navigable",
        "ram::NamedElement::name",
        "$$::Tuple::status"
      ]
    }],
    "properties": ["name"]
  },
  {
    "name": "OccurrenceSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "State",
    "expressions": [],
    "properties": [
      "StateMachine",
      "StateMachine",
      "outgoings",
      "incomings"
    ]
  },
  {
    "name": "RVoid",
    "expressions": [{
      "operations": {},
      "name": "getName",
      "body": "'void'",
      "type": "OperationImpl",
      "constructs": {"StringLiteralExpImpl": 1},
      "properties": []
    }],
    "properties": []
  },
  {
    "name": "Gate",
    "expressions": [],
    "properties": ["Interaction"]
  },
  {
    "name": "RSequence",
    "expressions": [],
    "properties": []
  },
  {
    "name": "LayoutElement",
    "expressions": [],
    "properties": [
      "ElementMap",
      "x",
      "y"
    ]
  },
  {
    "name": "RAny",
    "expressions": [{
      "operations": {},
      "name": "getName",
      "body": "'*'",
      "type": "OperationImpl",
      "constructs": {"StringLiteralExpImpl": 1},
      "properties": []
    }],
    "properties": []
  },
  {
    "name": "MessageEnd",
    "expressions": [],
    "properties": [
      "Message",
      "Message",
      "message"
    ]
  },
  {
    "name": "StructuralView",
    "expressions": [
      {
        "operations": {},
        "name": "noTwoClassesWithSameName",
        "body": "Tuple {\n\tmessage : String = 'Name of a class has to be unique',\n\tstatus : Boolean = self.classes->isUnique(name)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::NamedElement::name",
          "$$::Tuple::status",
          "ram::StructuralView::classes"
        ]
      },
      {
        "operations": {},
        "name": "uniqueTypes",
        "body": "Tuple {\n\tmessage : String = 'There may be only one type of the same type',\n\tstatus : Boolean = self.types->isUnique(name)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::NamedElement::name",
          "$$::Tuple::status",
          "ram::StructuralView::types"
        ]
      }
    ],
    "properties": [
      "associations",
      "types",
      "classes",
      "Aspect"
    ]
  },
  {
    "name": "ContainerMap",
    "expressions": [],
    "properties": [
      "value",
      "key",
      "Layout"
    ]
  },
  {
    "name": "RChar",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Character'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getName",
        "body": "'char'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "DestructionOccurrenceSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Message",
    "expressions": [
      {
        "operations": {
          "not": 2,
          "<>": 1,
          "oclIsUndefined": 2,
          "size": 2,
          "oclIsKindOf": 1,
          "and": 4,
          "includes": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "argumentsSpecified",
        "body": "Tuple {\n\tmessage : String = 'All arguments of the operation must be specified',\n\tstatus : Boolean = if self.messageSort <> MessageSort::reply and not self.sendEvent.oclIsUndefined() and self.sendEvent.oclIsKindOf(MessageOccurrenceSpecification) and not self.signature.oclIsUndefined() then let container : FragmentContainer = self.sendEvent.oclAsType(MessageOccurrenceSpecification).container in if container.fragments->includes(self.sendEvent) then self.signature.parameters->size() = self.arguments->size() and self.signature.parameters->forAll(currentParameter : Parameter | self.arguments->one(argument : ParameterValueMapping | argument.parameter = currentParameter)) else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 13,
          "OperationCallExpImpl": 16,
          "LetExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 16,
          "BooleanLiteralExpImpl": 2
        },
        "properties": [
          "ram::Message::signature",
          "ram::ParameterValueMapping::parameter",
          "ram::Message::sendEvent",
          "ram::Message::arguments",
          "$$::Tuple::status",
          "ram::InteractionFragment::container",
          "ram::Operation::parameters",
          "ram::FragmentContainer::fragments",
          "ram::Message::messageSort"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "not": 2,
          "oclIsUndefined": 1,
          "at": 1,
          "and": 1,
          "asOrderedSet": 1,
          "isEmpty": 1,
          "includes": 1,
          "=": 1,
          "indexOf": 2,
          "oclAsType": 2
        },
        "name": "deleteMessageIsLast",
        "body": "Tuple {\n\tmessage : String = 'The destruction occurrence may not come before any other occurrence on this lifeline',\n\tstatus : Boolean = if self.messageSort = MessageSort::deleteMessage then if not self.receiveEvent.oclIsUndefined() and not self.receiveEvent.oclAsType(InteractionFragment).covered->isEmpty() then let event : InteractionFragment = self.receiveEvent.oclAsType(InteractionFragment) in event.covered->asOrderedSet()->at(1).coveredBy->forAll(fragment : InteractionFragment | if event.container.fragments->includes(fragment) then event.container.fragments->indexOf(fragment) <= event.container.fragments->indexOf(event) else true endif) else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 14,
          "VariableExpImpl": 11,
          "LetExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "IfExpImpl": 3,
          "BooleanLiteralExpImpl": 3,
          "PropertyCallExpImpl": 14
        },
        "properties": [
          "ram::Message::receiveEvent",
          "$$::Tuple::status",
          "ram::InteractionFragment::container",
          "ram::FragmentContainer::fragments",
          "ram::Lifeline::coveredBy",
          "ram::InteractionFragment::covered",
          "ram::Message::messageSort"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsUndefined": 1,
          "oclIsKindOf": 1,
          "oclIsTypeOf": 4,
          "getType": 1,
          "oclAsType": 4,
          "oclType": 1
        },
        "name": "validReturnsValue",
        "body": "Tuple {\n\tmessage : String = 'Type of return value must match the type of the return',\n\tstatus : Boolean = if self.returns.oclIsTypeOf(StructuralFeatureValue) then let value : StructuralFeatureValue = self.returns.oclAsType(StructuralFeatureValue).value in if not value.oclIsUndefined() then let type : Type = if value.oclIsTypeOf(Attribute) then value.oclAsType(Attribute).type else if value.oclIsTypeOf(Reference) then value.oclAsType(Reference).type else value.oclAsType(AssociationEnd).getType() endif endif in type.oclIsTypeOf(self.signature.returnType.oclType()) else true endif else if self.returns.oclIsKindOf(LiteralSpecification) then false else true endif endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 11,
          "LetExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 8,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 5,
          "PropertyCallExpImpl": 9,
          "BooleanLiteralExpImpl": 3
        },
        "properties": [
          "ram::Message::signature",
          "ram::Message::returns",
          "ram::Attribute::type",
          "$$::Tuple::status",
          "ram::Operation::returnType",
          "ram::StructuralFeatureValue::value",
          "ram::Reference::type"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 2,
          "oclIsTypeOf": 1,
          "=": 1
        },
        "name": "returnsSpecified",
        "body": "Tuple {\n\tmessage : String = 'Reply message must have returns specified if return type is not void',\n\tstatus : Boolean = if self.messageSort = MessageSort::reply then if not self.signature.returnType.oclIsTypeOf(RVoid) then not self.returns.oclIsUndefined() else self.returns.oclIsUndefined() endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 6,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 6,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::signature",
          "ram::Message::returns",
          "$$::Tuple::status",
          "ram::Operation::returnType",
          "ram::Message::messageSort"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 2,
          "at": 2,
          "oclIsKindOf": 2,
          "and": 3,
          "asOrderedSet": 2,
          "<": 1,
          "oclAsType": 2,
          "=": 1,
          "indexOf": 2
        },
        "name": "validSelfMessage",
        "body": "Tuple {\n\tmessage : String = 'receiveEvent of a self message may not come before the sendEvent',\n\tstatus : Boolean = if not self.receiveEvent.oclIsUndefined() and self.receiveEvent.oclIsKindOf(MessageOccurrenceSpecification) and not self.sendEvent.oclIsUndefined() and self.sendEvent.oclIsKindOf(MessageOccurrenceSpecification) then let sendEvent : InteractionFragment = self.sendEvent.oclAsType(InteractionFragment) in let receiveEvent : InteractionFragment = self.receiveEvent.oclAsType(InteractionFragment) in if sendEvent.covered->asOrderedSet()->at(1) = receiveEvent.covered->asOrderedSet()->at(1) then sendEvent.container.fragments->indexOf(self.sendEvent) < receiveEvent.container.fragments->indexOf(self.receiveEvent) else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 12,
          "OperationCallExpImpl": 19,
          "LetExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 4,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 15,
          "BooleanLiteralExpImpl": 2
        },
        "properties": [
          "ram::Message::receiveEvent",
          "ram::Message::sendEvent",
          "$$::Tuple::status",
          "ram::InteractionFragment::container",
          "ram::FragmentContainer::fragments",
          "ram::InteractionFragment::covered"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 2,
          "oclIsKindOf": 2,
          "and": 3,
          "=": 1,
          "indexOf": 2,
          "-": 1,
          "oclAsType": 1
        },
        "name": "noCrossingMessages",
        "body": "Tuple {\n\tmessage : String = 'Messages may not cross each other, MessageEnds of one message must come one after the other (also, send must come before receive)',\n\tstatus : Boolean = if not self.receiveEvent.oclIsUndefined() and self.receiveEvent.oclIsKindOf(MessageOccurrenceSpecification) and not self.sendEvent.oclIsUndefined() and self.sendEvent.oclIsKindOf(MessageOccurrenceSpecification) then let container : FragmentContainer = self.receiveEvent.oclAsType(MessageOccurrenceSpecification).container in let indexDifference : Integer = container.fragments->indexOf(self.receiveEvent) - container.fragments->indexOf(self.sendEvent) in indexDifference = 1 else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 10,
          "OperationCallExpImpl": 14,
          "LetExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 3,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 11,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::receiveEvent",
          "ram::Message::sendEvent",
          "$$::Tuple::status",
          "ram::InteractionFragment::container",
          "ram::FragmentContainer::fragments"
        ]
      },
      {
        "operations": {
          "oclIsTypeOf": 1,
          "=": 1
        },
        "name": "assignToAllowed",
        "body": "Tuple {\n\tmessage : String = 'assignTo may not be specified for operations whose return type is void',\n\tstatus : Boolean = if self.signature.returnType.oclIsTypeOf(RVoid) then self.assignTo = null else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::signature",
          "ram::Message::assignTo",
          "$$::Tuple::status",
          "ram::Operation::returnType"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 1,
          "at": 1,
          "and": 1,
          "asOrderedSet": 1,
          "isEmpty": 1,
          "includes": 1,
          "indexOf": 2,
          "oclAsType": 2,
          "=": 1,
          ">=": 1
        },
        "name": "createMessageIsFirst",
        "body": "Tuple {\n\tmessage : String = 'The create message occurrence may not come after any other occurrence on this lifeline',\n\tstatus : Boolean = if self.messageSort = MessageSort::createMessage then if not self.receiveEvent.oclIsUndefined() and not self.receiveEvent.oclAsType(InteractionFragment).covered->isEmpty() then let event : InteractionFragment = self.receiveEvent.oclAsType(InteractionFragment) in event.covered->asOrderedSet()->at(1).coveredBy->forAll(fragment : InteractionFragment | if event.container.fragments->includes(fragment) then event.container.fragments->indexOf(fragment) >= event.container.fragments->indexOf(event) else true endif) else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 14,
          "VariableExpImpl": 11,
          "LetExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 14,
          "BooleanLiteralExpImpl": 3
        },
        "properties": [
          "ram::Message::receiveEvent",
          "$$::Tuple::status",
          "ram::InteractionFragment::container",
          "ram::FragmentContainer::fragments",
          "ram::Lifeline::coveredBy",
          "ram::InteractionFragment::covered",
          "ram::Message::messageSort"
        ]
      },
      {
        "operations": {
          "at": 2,
          "oclIsTypeOf": 2,
          "and": 2,
          "asOrderedSet": 2,
          "includes": 2,
          "oclAsType": 2
        },
        "name": "boundariesNotCrossed",
        "body": "Tuple {\n\tmessage : String = 'Messages may not cross boundaries of CombinedFragments or their operands',\n\tstatus : Boolean = let send : MessageOccurrenceSpecification = self.sendEvent in let receive : MessageOccurrenceSpecification = self.receiveEvent in if send.container.oclIsTypeOf(InteractionOperand) and receive.container.oclIsTypeOf(InteractionOperand) then send.container.oclAsType(InteractionOperand).CombinedFragment.covered->includes(send.covered->asOrderedSet()->at(1)) and receive.container.oclAsType(InteractionOperand).CombinedFragment.covered->includes(receive.covered->asOrderedSet()->at(1)) else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 8,
          "LetExpImpl": 2,
          "OppositePropertyCallExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 4,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 11,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::receiveEvent",
          "ram::Message::sendEvent",
          "$$::Tuple::status",
          "ram::InteractionFragment::container",
          "ram::InteractionFragment::covered"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsUndefined": 1,
          "oclIsKindOf": 1,
          "oclIsTypeOf": 2,
          "getType": 1,
          "oclAsType": 3,
          "oclType": 1
        },
        "name": "validAssignTo",
        "body": "Tuple {\n\tmessage : String = 'Return type of signature operation must match the type of assignTo',\n\tstatus : Boolean = if not self.assignTo.oclIsUndefined() then let type : Type = if self.assignTo.oclIsTypeOf(Attribute) then self.assignTo.oclAsType(Attribute).type else if self.assignTo.oclIsTypeOf(Reference) then self.assignTo.oclAsType(Reference).type else self.assignTo.oclAsType(AssociationEnd).getType() endif endif in type.oclIsKindOf(self.signature.returnType.oclType()) else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 8,
          "LetExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 5,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 11,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::signature",
          "ram::Attribute::type",
          "ram::Message::assignTo",
          "$$::Tuple::status",
          "ram::Operation::returnType",
          "ram::Reference::type"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsUndefined": 1,
          "=": 1
        },
        "name": "validReturns",
        "body": "Tuple {\n\tmessage : String = 'Returns may only be specified if message sort is reply message',\n\tstatus : Boolean = if not self.returns.oclIsUndefined() then self.messageSort = MessageSort::reply else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::returns",
          "$$::Tuple::status",
          "ram::Message::messageSort"
        ]
      },
      {
        "operations": {
          "at": 2,
          "oclIsKindOf": 2,
          "and": 1,
          "asOrderedSet": 2,
          "oclAsType": 2,
          "=": 1
        },
        "name": "selfMessage",
        "body": "if self.sendEvent.oclIsKindOf(MessageOccurrenceSpecification) and self.receiveEvent.oclIsKindOf(MessageOccurrenceSpecification) then self.sendEvent.oclAsType(MessageOccurrenceSpecification).covered->asOrderedSet()->at(1) = self.receiveEvent.oclAsType(MessageOccurrenceSpecification).covered->asOrderedSet()->at(1) else false endif",
        "type": "PropertyImpl",
        "constructs": {
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 4,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 4,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 6,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::receiveEvent",
          "ram::Message::sendEvent",
          "ram::InteractionFragment::covered"
        ]
      },
      {
        "operations": {
          "not": 2,
          "<>": 1,
          "at": 1,
          "oclIsUndefined": 2,
          "oclIsTypeOf": 3,
          "oclIsKindOf": 1,
          "getType": 1,
          "and": 1,
          "asOrderedSet": 1,
          "includes": 1,
          "oclAsType": 6
        },
        "name": "validSignature",
        "body": "Tuple {\n\tmessage : String = 'Message signature must be an operation of the classifier that is represented by the lifeline of the receive event',\n\tstatus : Boolean = if self.messageSort <> MessageSort::reply and not self.receiveEvent.oclIsUndefined() then let typedElement : TypedElement = self.receiveEvent.oclAsType(InteractionFragment).covered->asOrderedSet()->at(1).represents in if not typedElement.oclIsUndefined() then let type : Type = if typedElement.oclIsTypeOf(Parameter) then typedElement.oclAsType(Parameter).type else if typedElement.oclIsTypeOf(Attribute) then typedElement.oclAsType(Attribute).type else if typedElement.oclIsTypeOf(Reference) then typedElement.oclAsType(Reference).type else typedElement.oclAsType(AssociationEnd).getType() endif endif endif in if type.oclIsKindOf(Classifier) then type.oclAsType(Classifier).operations->includes(self.signature) else true endif else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 14,
          "OperationCallExpImpl": 20,
          "LetExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 10,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 6,
          "PropertyCallExpImpl": 11,
          "BooleanLiteralExpImpl": 3
        },
        "properties": [
          "ram::Message::signature",
          "ram::Message::receiveEvent",
          "ram::Lifeline::represents",
          "ram::Attribute::type",
          "$$::Tuple::status",
          "ram::Reference::type",
          "ram::InteractionFragment::covered",
          "ram::Classifier::operations",
          "ram::Message::messageSort",
          "ram::Parameter::type"
        ]
      }
    ],
    "properties": [
      "signature",
      "returns",
      "receiveEvent",
      "sendEvent",
      "arguments",
      "assignTo",
      "MessageEnd",
      "selfMessage",
      "messageSort",
      "interaction"
    ]
  },
  {
    "name": "Reference",
    "expressions": [],
    "properties": [
      "type",
      "Interaction"
    ]
  },
  {
    "name": "CombinedFragment",
    "expressions": [{
      "operations": {
        "or": 2,
        "size": 1,
        "=": 4
      },
      "name": "validOperands",
      "body": "Tuple {\n\tmessage : String = 'opt and loop fragments may only have one operand',\n\tstatus : Boolean = if self.interactionOperator = InteractionOperatorKind::opt or self.interactionOperator = InteractionOperatorKind::loop or self.interactionOperator = InteractionOperatorKind::critical then self.operands->size() = 1 else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 7,
        "VariableExpImpl": 4,
        "TupleLiteralExpImpl": 1,
        "EnumLiteralExpImpl": 3,
        "IntegerLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 5,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::CombinedFragment::interactionOperator",
        "$$::Tuple::status",
        "ram::CombinedFragment::operands"
      ]
    }],
    "properties": [
      "interactionOperator",
      "operands"
    ]
  },
  {
    "name": "LiteralSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "RArray",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.reflect.Array'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "<>": 2,
          "size": 1,
          "oclIsTypeOf": 2,
          "and": 1,
          "toString": 1,
          "+": 4,
          "indexOf": 2,
          "-": 1,
          "substring": 2,
          ">=": 1
        },
        "name": "getName",
        "body": "if (self.type <> null and self.type.name <> null) then if (self.type.oclIsTypeOf(RArray)) then self.type.name.substring(1, self.type.name.indexOf('[') -1) else self.type.name endif + '[' + if (self.size >= 0) then self.size.toString() else '' endif + ']' + if (self.type.oclIsTypeOf(RArray)) then self.type.name.substring(self.type.name.indexOf('['), self.type.name.size()) else '' endif else null endif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 12,
          "OperationCallExpImpl": 17,
          "NullLiteralExpImpl": 3,
          "IntegerLiteralExpImpl": 3,
          "StringLiteralExpImpl": 6,
          "TypeExpImpl": 2,
          "IfExpImpl": 4,
          "PropertyCallExpImpl": 19
        },
        "properties": [
          "ram::NamedElement::name",
          "ram::RArray::type",
          "ram::RArray::size"
        ]
      }
    ],
    "properties": [
      "type",
      "size"
    ]
  },
  {
    "name": "ClassifierMapping",
    "expressions": [],
    "properties": [
      "toElement",
      "operationMappings",
      "fromElement",
      "Instantiation",
      "attributeMappings"
    ]
  },
  {
    "name": "REnum",
    "expressions": [],
    "properties": ["literals"]
  },
  {
    "name": "RDouble",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Double'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getName",
        "body": "'double'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "Mapping",
    "expressions": [
      {
        "operations": {},
        "name": "getFromElement",
        "body": "null",
        "type": "OperationImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getToElement",
        "body": "null",
        "type": "OperationImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "ReferenceType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Attribute",
    "expressions": [],
    "properties": [
      "type",
      "Class",
      "AttributeMapping",
      "AttributeMapping"
    ]
  },
  {
    "name": "TypedElement",
    "expressions": [],
    "properties": ["Lifeline"]
  },
  {
    "name": "OperationMapping",
    "expressions": [],
    "properties": [
      "toElement",
      "parameterMappings",
      "ClassifierMapping",
      "fromElement"
    ]
  },
  {
    "name": "Class",
    "expressions": [{
      "operations": {
        "not": 1,
        "includes": 1
      },
      "name": "notSelfSuperType",
      "body": "Tuple {\n\tmessage : String = 'A class may not be it\\'s own supertype',\n\tstatus : Boolean = not self.superTypes->includes(self)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "ram::Class::superTypes",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "superTypes",
      "abstract",
      "attributes",
      "partial"
    ]
  },
  {
    "name": "ParameterMapping",
    "expressions": [],
    "properties": [
      "OperationMapping",
      "fromElement",
      "toElement"
    ]
  },
  {
    "name": "RBoolean",
    "expressions": [
      {
        "operations": {},
        "name": "getName",
        "body": "'boolean'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Boolean'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "MessageView",
    "expressions": [
      {
        "operations": {
          "not": 3,
          "oclIsUndefined": 2
        },
        "name": "specificationDefined",
        "body": "Tuple {\n\tmessage : String = 'A MessageView for a non-partial operation must have a specification',\n\tstatus : Boolean = if not self.specifies.oclIsUndefined() then if not self.specifies.partial then not self.specification.oclIsUndefined() else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 5,
          "BooleanLiteralExpImpl": 2
        },
        "properties": [
          "$$::Tuple::status",
          "ram::MessageView::specifies",
          "ram::Operation::partial",
          "ram::MessageView::specification"
        ]
      },
      {
        "operations": {
          "oclIsUndefined": 1,
          "and": 1,
          "notEmpty": 1
        },
        "name": "isAffectedBy",
        "body": "Tuple {\n\tmessage : String = 'An empty MessageView must have at least one affectedBy',\n\tstatus : Boolean = if self.specification.oclIsUndefined() and self.specifies.partial then self.affectedBy->notEmpty() else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 5,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::AbstractMessageView::affectedBy",
          "$$::Tuple::status",
          "ram::Operation::partial",
          "ram::MessageView::specifies",
          "ram::MessageView::specification"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 1,
          "at": 1,
          "size": 1,
          "oclIsTypeOf": 1,
          "and": 1,
          "asOrderedSet": 1,
          "=": 1,
          ">": 1
        },
        "name": "specifiesIsFirstMessage",
        "body": "Tuple {\n\tmessage : String = 'The first message in the MessageView must match specifies of the MessageView',\n\tstatus : Boolean = if not self.specification.oclIsUndefined() and self.specification.messages->size() > 0 then self.specifies = self.specification.messages->select(message : Message | not message.sendEvent.oclIsTypeOf(MessageOccurrenceSpecification))->asOrderedSet()->at(1).signature else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 5,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 9,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::signature",
          "ram::Message::sendEvent",
          "$$::Tuple::status",
          "ram::MessageView::specifies",
          "ram::MessageView::specification",
          "ram::Interaction::messages"
        ]
      }
    ],
    "properties": [
      "MessageViewReference",
      "specifies",
      "specification"
    ]
  },
  {
    "name": "ParameterValue",
    "expressions": [{
      "operations": {
        "oclIsTypeOf": 1,
        "oclType": 1
      },
      "name": "validValueType",
      "body": "Tuple {\n\tmessage : String = 'Type of value must match the type of the parameter',\n\tstatus : Boolean = self.parameter.type.oclIsTypeOf(self.ParameterValueMapping.parameter.type.oclType())\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 2,
        "OppositePropertyCallExpImpl": 1,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 5
      },
      "properties": [
        "ram::ParameterValueMapping::parameter",
        "$$::Tuple::status",
        "ram::ParameterValue::parameter",
        "ram::Parameter::type"
      ]
    }],
    "properties": ["parameter"]
  },
  {
    "name": "TemporaryProperty",
    "expressions": [],
    "properties": ["Lifeline"]
  },
  {
    "name": "RSet",
    "expressions": [],
    "properties": []
  },
  {
    "name": "TypeParameter",
    "expressions": [],
    "properties": [
      "genericType",
      "Classifier"
    ]
  },
  {
    "name": "RLong",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Long'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getName",
        "body": "'float'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "AspectMessageView",
    "expressions": [{
      "operations": {
        "not": 1,
        "includes": 1
      },
      "name": "notAffectedBySelf",
      "body": "Tuple {\n\tmessage : String = 'Message View may not be affected by itself',\n\tstatus : Boolean = not self.affectedBy->includes(self)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "ram::AbstractMessageView::affectedBy",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "advice",
      "AbstractMessageView",
      "pointcut"
    ]
  },
  {
    "name": "OriginalBehaviorExecution",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Property",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "=": 1,
          "-": 1,
          ">": 1
        },
        "name": "validUpperBound",
        "body": "Tuple {\n\tmessage : String = 'The upperbound must be greater than zero or -1 representing *',\n\tstatus : Boolean = self.upperBound > 0 or self.upperBound = -1\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "$$::Tuple::status",
          "ram::Property::upperBound"
        ]
      },
      {
        "operations": {">=": 1},
        "name": "validLowerBound",
        "body": "Tuple {\n\tmessage : String = 'The lowerbound must be greater than or equal to zero',\n\tstatus : Boolean = self.lowerBound >= 0\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "ram::Property::lowerBound",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "or": 1,
          "-": 1,
          "=": 1
        },
        "name": "validMultiplicity",
        "body": "Tuple {\n\tmessage : String = 'The lowerBound must be less than or equal to the upperBound',\n\tstatus : Boolean = self.lowerBound <= self.upperBound or self.upperBound = -1\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 3,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "ram::Property::lowerBound",
          "$$::Tuple::status",
          "ram::Property::upperBound"
        ]
      }
    ],
    "properties": [
      "lowerBound",
      "referenceType",
      "upperBound"
    ]
  },
  {
    "name": "Lifeline",
    "expressions": [],
    "properties": [
      "represents",
      "localProperties",
      "coveredBy",
      "Interaction"
    ]
  },
  {
    "name": "StructuralFeature",
    "expressions": [],
    "properties": [
      "Message",
      "StructuralFeatureValue",
      "static"
    ]
  },
  {
    "name": "Type",
    "expressions": [],
    "properties": [
      "StructuralView",
      "Operation",
      "Parameter"
    ]
  },
  {
    "name": "Interaction",
    "expressions": [],
    "properties": [
      "MessageView",
      "lifelines",
      "formalGates",
      "properties",
      "AspectMessageView",
      "messages"
    ]
  },
  {
    "name": "Constraint",
    "expressions": [],
    "properties": [
      "Specification",
      "Transition"
    ]
  },
  {
    "name": "InteractionOperand",
    "expressions": [],
    "properties": [
      "interactionConstraint",
      "CombinedFragment"
    ]
  },
  {
    "name": "LiteralString",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "Operation",
    "expressions": [{
      "operations": {
        "oclIsTypeOf": 2,
        "and": 1,
        "oclAsType": 2,
        "=": 2,
        "oclContainer": 1
      },
      "name": "messageViewDefined",
      "body": "Tuple {\n\tmessage : String = 'MessageView missing for public operation',\n\tstatus : Boolean = if visibility = Visibility::public and self.Classifier.oclIsTypeOf(Class) then self.Classifier.oclContainer().oclAsType(StructuralView).Aspect.messageViews->select(messageView : AbstractMessageView | messageView.oclIsTypeOf(MessageView))->one(messageView : AbstractMessageView | messageView.oclAsType(MessageView).specifies = self) else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "VariableExpImpl": 6,
        "OperationCallExpImpl": 8,
        "OppositePropertyCallExpImpl": 3,
        "TupleLiteralExpImpl": 1,
        "EnumLiteralExpImpl": 1,
        "TypeExpImpl": 4,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 4,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::Operation::visibility",
        "$$::Tuple::status",
        "ram::Aspect::messageViews",
        "ram::MessageView::specifies"
      ]
    }],
    "properties": [
      "visibility",
      "OperationMapping",
      "abstract",
      "partial",
      "Classifier",
      "Message",
      "OperationMapping",
      "AspectMessageView",
      "static",
      "returnType",
      "MessageView",
      "parameters",
      "Transition"
    ]
  },
  {
    "name": "AttributeMapping",
    "expressions": [],
    "properties": [
      "fromElement",
      "ClassifierMapping",
      "toElement"
    ]
  },
  {
    "name": "ObjectType",
    "expressions": [],
    "properties": [
      "RArray",
      "TypeParameter",
      "Reference",
      "RCollection"
    ]
  },
  {
    "name": "InteractionOperatorKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Aspect",
    "expressions": [{
      "operations": {
        "allInstances": 2,
        "union": 2,
        "=": 2
      },
      "name": "mandatoryAspectParameters",
      "body": "let mappableElements : Set(MappableElement) = Set{} in mappableElements->union(Class.allInstances()->select(partial = true))->union(Operation.allInstances()->select(partial = true))",
      "type": "PropertyImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 3,
        "LetExpImpl": 1,
        "TypeExpImpl": 2,
        "CollectionLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2,
        "BooleanLiteralExpImpl": 2
      },
      "properties": [
        "ram::Operation::partial",
        "ram::Class::partial"
      ]
    }],
    "properties": [
      "structuralView",
      "mandatoryAspectParameters",
      "layout",
      "stateViews",
      "messageViews",
      "Instantiation",
      "instantiations"
    ]
  },
  {
    "name": "StateMachine",
    "expressions": [],
    "properties": [
      "transitions",
      "start",
      "StateView",
      "substitutions",
      "states"
    ]
  },
  {
    "name": "Instantiation",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "=": 1
        },
        "name": "aspectCannotMapSelf",
        "body": "Tuple {\n\tmessage : String = 'Aspect may not depend on itself',\n\tstatus : Boolean = not (self.externalAspect = self.Aspect)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "OppositePropertyCallExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "ram::Instantiation::externalAspect",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {"=": 2},
        "name": "mandatoryAspectParametersMapped",
        "body": "Tuple {\n\tmessage : String = 'Partial elements from lower-level aspects have to be mapped',\n\tstatus : Boolean = if self.type = InstantiationType::Depends then self.externalAspect.mandatoryAspectParameters->forAll(element : MappableElement | self.mappings->exists(fromElement = element)) else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 6,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Instantiation::mappings",
          "ram::Instantiation::externalAspect",
          "ram::Aspect::mandatoryAspectParameters",
          "$$::Tuple::status",
          "ram::ClassifierMapping::fromElement",
          "ram::Instantiation::type"
        ]
      }
    ],
    "properties": [
      "mappings",
      "externalAspect",
      "Aspect",
      "type"
    ]
  },
  {
    "name": "MessageViewReference",
    "expressions": [{
      "operations": {
        "size": 1,
        ">": 1
      },
      "name": "isAffectedBy",
      "body": "Tuple {\n\tmessage : String = 'The MessageViewReference must have at least one affectedBy',\n\tstatus : Boolean = self.affectedBy->size() > 0\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "ram::AbstractMessageView::affectedBy",
        "$$::Tuple::status"
      ]
    }],
    "properties": ["references"]
  },
  {
    "name": "Substitution",
    "expressions": [],
    "properties": ["StateMachine"]
  },
  {
    "name": "AbstractMessageView",
    "expressions": [],
    "properties": [
      "affectedBy",
      "Aspect"
    ]
  },
  {
    "name": "ElementMap",
    "expressions": [],
    "properties": [
      "value",
      "ContainerMap",
      "key"
    ]
  },
  {
    "name": "InstantiationType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Layout",
    "expressions": [],
    "properties": [
      "containers",
      "Aspect"
    ]
  },
  {
    "name": "Transition",
    "expressions": [],
    "properties": [
      "TransitionSubstitution",
      "startState",
      "StateMachine",
      "signature",
      "guard",
      "endState",
      "TransitionSubstitution"
    ]
  }
]
