[
  {
    "name": "MessageViewReference",
    "expressions": [{
      "operations": {
        "size": 1,
        ">": 1
      },
      "name": "isAffectedBy",
      "body": "Tuple {\n\tmessage : String = 'The MessageViewReference must at least have one affectedBy',\n\tstatus : Boolean = self.affectedBy->size() > 0\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "$$::Tuple::status",
        "ram::AbstractMessageView::affectedBy"
      ]
    }],
    "properties": ["references"]
  },
  {
    "name": "Class",
    "expressions": [{
      "operations": {
        "not": 1,
        "includes": 1
      },
      "name": "notSelfSuperType",
      "body": "Tuple {\n\tmessage : String = 'A class may not be it\\'s own supertype',\n\tstatus : Boolean = not self.superTypes->includes(self)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "ram::Class::superTypes",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "partial",
      "superTypes",
      "associationEnds",
      "abstract",
      "attributes"
    ]
  },
  {
    "name": "MessageView",
    "expressions": [{
      "operations": {
        "not": 2,
        "oclIsUndefined": 1
      },
      "name": "specificationDefined",
      "body": "Tuple {\n\tmessage : String = 'A MessageView for a non-partial operation must have a specification',\n\tstatus : Boolean = if not self.specifies.partial then not self.specification.oclIsUndefined() else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 3,
        "VariableExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 4,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::Operation::partial",
        "ram::MessageView::specifies",
        "$$::Tuple::status",
        "ram::MessageView::specification"
      ]
    }],
    "properties": [
      "MessageViewReference",
      "specifies",
      "specification"
    ]
  },
  {
    "name": "Mapping",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsTypeOf": 2
        },
        "name": "validSourceModelElement",
        "body": "Tuple {\n\tmessage : String = 'The source model element may only be of type Class or Operation',\n\tstatus : Boolean = self.sourceModelElement.oclIsTypeOf(Class) or self.sourceModelElement.oclIsTypeOf(Operation)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::Mapping::sourceModelElement",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {
          "oclIsTypeOf": 2,
          "oclIsKindOf": 1,
          "and": 1,
          "includes": 3,
          "oclAsType": 2
        },
        "name": "validMapping",
        "body": "Tuple {\n\tmessage : String = 'Source must be from depending aspect and targets must be from current aspect',\n\tstatus : Boolean = let clazz : Class = if sourceModelElement.oclIsTypeOf(Operation) then sourceModelElement.oclAsType(Operation).Classifier else sourceModelElement endif in self.Instantiation.externalAspect.structuralView.classes->includes(clazz) and self.maps->forAll(element : MappableElement | let clazz : Class = if element.oclIsTypeOf(Operation) then element.oclAsType(Operation).Classifier else element endif in if clazz.oclIsKindOf(PrimitiveType) then self.Instantiation.Aspect.structuralView.types->includes(clazz) else self.Instantiation.Aspect.structuralView.classes->includes(clazz) endif)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 14,
          "OperationCallExpImpl": 9,
          "LetExpImpl": 2,
          "OppositePropertyCallExpImpl": 7,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 5,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "ram::StructuralView::classes",
          "ram::Mapping::maps",
          "ram::Mapping::sourceModelElement",
          "ram::Instantiation::externalAspect",
          "ram::StructuralView::types",
          "ram::Aspect::structuralView",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "oclIsTypeOf": 1,
          "oclType": 1
        },
        "name": "sameTypesMapped",
        "body": "Tuple {\n\tmessage : String = 'Mapping must be between same types of elements',\n\tstatus : Boolean = self.maps->forAll(element : MappableElement | if element.oclIsKindOf(Classifier) then self.sourceModelElement.oclIsKindOf(Classifier) else element.oclIsTypeOf(self.sourceModelElement.oclType()) endif)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 4,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "ram::Mapping::maps",
          "ram::Mapping::sourceModelElement",
          "$$::Tuple::status"
        ]
      }
    ],
    "properties": [
      "maps",
      "Instantiation",
      "sourceModelElement"
    ]
  },
  {
    "name": "MessageEnd",
    "expressions": [],
    "properties": [
      "message",
      "Message",
      "Message"
    ]
  },
  {
    "name": "ContainerMap",
    "expressions": [],
    "properties": [
      "value",
      "key",
      "Layout"
    ]
  },
  {
    "name": "REnumLiteral",
    "expressions": [],
    "properties": ["enum"]
  },
  {
    "name": "Layout",
    "expressions": [],
    "properties": [
      "Aspect",
      "containers"
    ]
  },
  {
    "name": "OriginalBehaviorExecution",
    "expressions": [],
    "properties": []
  },
  {
    "name": "RAny",
    "expressions": [{
      "operations": {},
      "name": "getName",
      "body": "'*'",
      "type": "OperationImpl",
      "constructs": {"StringLiteralExpImpl": 1},
      "properties": []
    }],
    "properties": []
  },
  {
    "name": "Visibility",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ParameterValueMapping",
    "expressions": [{
      "operations": {"oclIsKindOf": 1},
      "name": "validParameterValue",
      "body": "Tuple {\n\tmessage : String = 'Type of value must match the type of the parameter',\n\tstatus : Boolean = if self.value.oclIsKindOf(LiteralSpecification) then false else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 1,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "IfExpImpl": 1,
        "BooleanLiteralExpImpl": 2,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "ram::ParameterValueMapping::value",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "Message",
      "parameter",
      "value"
    ]
  },
  {
    "name": "RString",
    "expressions": [
      {
        "operations": {},
        "name": "getName",
        "body": "'String'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.String'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "CombinedFragment",
    "expressions": [{
      "operations": {
        "or": 2,
        "size": 1,
        "=": 4
      },
      "name": "validOperands",
      "body": "Tuple {\n\tmessage : String = 'opt and loop fragments may only have one operand',\n\tstatus : Boolean = if self.interactionOperator = InteractionOperatorKind::opt or self.interactionOperator = InteractionOperatorKind::loop or self.interactionOperator = InteractionOperatorKind::critical then self.operands->size() = 1 else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 4,
        "OperationCallExpImpl": 7,
        "TupleLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "EnumLiteralExpImpl": 3,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 5,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::CombinedFragment::operands",
        "ram::CombinedFragment::interactionOperator",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "operands",
      "interactionOperator"
    ]
  },
  {
    "name": "RVoid",
    "expressions": [{
      "operations": {},
      "name": "getName",
      "body": "'void'",
      "type": "OperationImpl",
      "constructs": {"StringLiteralExpImpl": 1},
      "properties": []
    }],
    "properties": []
  },
  {
    "name": "MessageOccurrenceSpecification",
    "expressions": [{
      "operations": {
        "at": 1,
        "asOrderedSet": 1,
        "includes": 1,
        "indexOf": 2,
        "=": 1,
        ">=": 1
      },
      "name": "createMessageIsFirst",
      "body": "Tuple {\n\tmessage : String = 'The create message occurrence may not come after any other occurrence on this lifeline',\n\tstatus : Boolean = if self.message.messageSort = MessageSort::createMessage then self.covered->asOrderedSet()->at(1).coveredBy->forAll(fragment : InteractionFragment | if self.container.fragments->includes(fragment) then self.container.fragments->indexOf(fragment) >= self.container.fragments->indexOf(self) else true endif) else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 8,
        "OperationCallExpImpl": 7,
        "TupleLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "EnumLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 2,
        "PropertyCallExpImpl": 11,
        "BooleanLiteralExpImpl": 2
      },
      "properties": [
        "ram::MessageEnd::message",
        "ram::InteractionFragment::covered",
        "ram::Message::messageSort",
        "ram::Lifeline::coveredBy",
        "ram::InteractionFragment::container",
        "$$::Tuple::status",
        "ram::FragmentContainer::fragments"
      ]
    }],
    "properties": []
  },
  {
    "name": "REnum",
    "expressions": [],
    "properties": ["literals"]
  },
  {
    "name": "RSet",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ReferenceType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Lifeline",
    "expressions": [{
      "operations": {"=": 1},
      "name": "noNameForMetaClass",
      "body": "Tuple {\n\tmessage : String = 'A Lifeline representing a MetaClass may not have a name',\n\tstatus : Boolean = if metaClass then self.name = '' else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 2,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 3,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::NamedElement::name",
        "ram::Lifeline::metaClass",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "represents",
      "Interaction",
      "localProperties",
      "metaClass",
      "coveredBy"
    ]
  },
  {
    "name": "CodeExecution",
    "expressions": [],
    "properties": ["specification"]
  },
  {
    "name": "AspectMessageView",
    "expressions": [{
      "operations": {
        "not": 1,
        "includes": 1
      },
      "name": "notAffectedBySelf",
      "body": "Tuple {\n\tmessage : String = 'Message View may not be affected by itself',\n\tstatus : Boolean = not self.affectedBy->includes(self)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "$$::Tuple::status",
        "ram::AbstractMessageView::affectedBy"
      ]
    }],
    "properties": [
      "pointcut",
      "advice",
      "AbstractMessageView"
    ]
  },
  {
    "name": "Operation",
    "expressions": [{
      "operations": {
        "oclIsTypeOf": 2,
        "and": 1,
        "oclAsSet": 1,
        "=": 2,
        "oclAsType": 1
      },
      "name": "messageViewDefined",
      "body": "Tuple {\n\tmessage : String = 'MessageView missing for public operation',\n\tstatus : Boolean = if visibility = Visibility::public and self.Classifier.oclIsTypeOf(Class) then self.Classifier.StructuralView.Aspect.messageViews->select(messageView : AbstractMessageView | messageView.oclIsTypeOf(MessageView))->one(messageView : AbstractMessageView | messageView.oclAsType(MessageView).specification = self) else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "VariableExpImpl": 6,
        "OperationCallExpImpl": 7,
        "OppositePropertyCallExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "EnumLiteralExpImpl": 1,
        "TypeExpImpl": 3,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 6,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::Operation::visibility",
        "$$::Tuple::status",
        "ram::MessageView::specification",
        "OclInvalid::oclBadProperty"
      ]
    }],
    "properties": [
      "MessageView",
      "abstract",
      "visibility",
      "Classifier",
      "parameters",
      "partial",
      "static",
      "Message",
      "returnType"
    ]
  },
  {
    "name": "ImplementationClass",
    "expressions": [],
    "properties": ["instanceClassName"]
  },
  {
    "name": "RBoolean",
    "expressions": [
      {
        "operations": {},
        "name": "getName",
        "body": "'boolean'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Boolean'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "Association",
    "expressions": [],
    "properties": [
      "ends",
      "StructuralView"
    ]
  },
  {
    "name": "RInt",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Integer'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getName",
        "body": "'int'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "LiteralInteger",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "StructuralFeature",
    "expressions": [],
    "properties": [
      "StructuralFeatureValue",
      "Message"
    ]
  },
  {
    "name": "Attribute",
    "expressions": [],
    "properties": [
      "type",
      "Class"
    ]
  },
  {
    "name": "Interaction",
    "expressions": [],
    "properties": [
      "messages",
      "MessageView",
      "AspectMessageView",
      "lifelines",
      "AspectMessageView"
    ]
  },
  {
    "name": "AbstractMessageView",
    "expressions": [],
    "properties": [
      "Aspect",
      "affectedBy"
    ]
  },
  {
    "name": "ElementMap",
    "expressions": [],
    "properties": [
      "ContainerMap",
      "key",
      "value"
    ]
  },
  {
    "name": "LayoutElement",
    "expressions": [],
    "properties": [
      "x",
      "y",
      "ElementMap"
    ]
  },
  {
    "name": "TemporaryProperty",
    "expressions": [],
    "properties": ["Lifeline"]
  },
  {
    "name": "OpaqueExpression",
    "expressions": [],
    "properties": [
      "language",
      "body"
    ]
  },
  {
    "name": "EObject",
    "expressions": [],
    "properties": [
      "ContainerMap",
      "ElementMap"
    ]
  },
  {
    "name": "StructuralView",
    "expressions": [
      {
        "operations": {},
        "name": "noTwoClassesWithSameName",
        "body": "Tuple {\n\tmessage : String = 'Name of a class has to be unique',\n\tstatus : Boolean = self.classes->isUnique(name)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::StructuralView::classes",
          "ram::NamedElement::name",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {},
        "name": "uniqueTypes",
        "body": "Tuple {\n\tmessage : String = 'There may be only one type of the same type',\n\tstatus : Boolean = self.types->isUnique(name)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::NamedElement::name",
          "ram::StructuralView::types",
          "$$::Tuple::status"
        ]
      }
    ],
    "properties": [
      "classes",
      "Aspect",
      "associations",
      "types"
    ]
  },
  {
    "name": "MappableElement",
    "expressions": [],
    "properties": [
      "Mapping",
      "Aspect",
      "Mapping"
    ]
  },
  {
    "name": "LiteralString",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "OccurrenceSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "NamedElement",
    "expressions": [{
      "operations": {
        "<>": 1,
        "oclIsTypeOf": 1,
        "and": 1,
        "oclAsType": 1,
        "=": 1
      },
      "name": "validName",
      "body": "Tuple {\n\tmessage : String = 'Name of RAM elements may not be empty',\n\tstatus : Boolean = if self.oclIsTypeOf(AssociationEnd) and self.oclAsType(AssociationEnd).navigable = false then true else self.name <> '' endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 5,
        "VariableExpImpl": 3,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 2,
        "TypeExpImpl": 2,
        "IfExpImpl": 1,
        "BooleanLiteralExpImpl": 2,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "ram::AssociationEnd::navigable",
        "ram::NamedElement::name",
        "$$::Tuple::status"
      ]
    }],
    "properties": ["name"]
  },
  {
    "name": "Message",
    "expressions": [
      {
        "operations": {
          "size": 2,
          "and": 1,
          "=": 2
        },
        "name": "argumentsSpecified",
        "body": "Tuple {\n\tmessage : String = 'All arguments of the operation must be specified',\n\tstatus : Boolean = self.signature.parameters->size() = self.arguments->size() and self.signature.parameters->forAll(parameter : Parameter | self.arguments->one(argument : ParameterValueMapping | argument.parameter = parameter))\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 6,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "ram::ParameterValueMapping::parameter",
          "ram::Operation::parameters",
          "ram::Message::arguments",
          "$$::Tuple::status",
          "ram::Message::signature"
        ]
      },
      {
        "operations": {
          "at": 2,
          "asOrderedSet": 2,
          "<": 1,
          "oclAsType": 2,
          "=": 1,
          "indexOf": 2
        },
        "name": "validSelfMessage",
        "body": "Tuple {\n\tmessage : String = 'receiveEvent of a self message may not come before the sendEvent',\n\tstatus : Boolean = if self.sendEvent.oclAsType(MessageOccurrenceSpecification).covered->asOrderedSet()->at(1) = self.receiveEvent.oclAsType(MessageOccurrenceSpecification).covered->asOrderedSet()->at(1) then self.interaction.fragments->indexOf(self.sendEvent) < self.interaction.fragments->indexOf(self.receiveEvent) else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 6,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 11,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::interaction",
          "ram::InteractionFragment::covered",
          "$$::Tuple::status",
          "ram::Message::sendEvent",
          "ram::FragmentContainer::fragments",
          "ram::Message::receiveEvent"
        ]
      },
      {
        "operations": {
          "at": 1,
          "asOrderedSet": 1,
          "oclAsType": 1
        },
        "name": "validOperationCall",
        "body": "Tuple {\n\tmessage : String = 'Non-static calls may not be performed on meta-classes',\n\tstatus : Boolean = if self.receiveEvent.oclAsType(InteractionFragment).covered->asOrderedSet()->at(1).metaClass then self.signature.static else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 6,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::InteractionFragment::covered",
          "ram::Lifeline::metaClass",
          "ram::Operation::static",
          "$$::Tuple::status",
          "ram::Message::receiveEvent",
          "ram::Message::signature"
        ]
      },
      {
        "operations": {
          "or": 1,
          "=": 2,
          "indexOf": 2,
          "-": 2
        },
        "name": "noCrossingMessages",
        "body": "Tuple {\n\tmessage : String = 'Messages may not cross each other, MessageEnds of one message must come one after the other',\n\tstatus : Boolean = let indexDifference : Integer = self.interaction.fragments->indexOf(self.receiveEvent) - self.interaction.fragments->indexOf(self.sendEvent) in indexDifference = 1 or indexDifference = - 1\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 7,
          "LetExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "ram::Message::interaction",
          "ram::Message::sendEvent",
          "$$::Tuple::status",
          "ram::FragmentContainer::fragments",
          "ram::Message::receiveEvent"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 2,
          "oclIsTypeOf": 1,
          "=": 1
        },
        "name": "returnsSpecified",
        "body": "Tuple {\n\tmessage : String = 'Reply message must have returns specified if return type is not void',\n\tstatus : Boolean = if self.messageSort = MessageSort::reply then if not self.signature.returnType.oclIsTypeOf(RVoid) then not self.returns.oclIsUndefined() else self.returns.oclIsUndefined() endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 6,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 6,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::returns",
          "ram::Message::messageSort",
          "$$::Tuple::status",
          "ram::Message::signature",
          "ram::Operation::returnType"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsUndefined": 1,
          "=": 1
        },
        "name": "validReturns",
        "body": "Tuple {\n\tmessage : String = 'Returns may only be specified if message sort is reply message',\n\tstatus : Boolean = if not self.returns.oclIsUndefined() then self.messageSort = MessageSort::reply else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::returns",
          "ram::Message::messageSort",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {
          "at": 1,
          "asOrderedSet": 1,
          "includes": 1,
          "oclAsType": 1
        },
        "name": "validSignature",
        "body": "Tuple {\n\tmessage : String = 'Message signature must be an operation of the classifier that is represented by the lifeline of the receive event',\n\tstatus : Boolean = self.receiveEvent.oclAsType(InteractionFragment).covered->asOrderedSet()->at(1).represents.operations->includes(self.signature)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "ram::Lifeline::represents",
          "ram::InteractionFragment::covered",
          "ram::Classifier::operations",
          "$$::Tuple::status",
          "ram::Message::receiveEvent",
          "ram::Message::signature"
        ]
      },
      {
        "operations": {
          "oclIsTypeOf": 1,
          "=": 1
        },
        "name": "assignToAllowed",
        "body": "Tuple {\n\tmessage : String = 'assignTo may not be specified for operations whose return type is void',\n\tstatus : Boolean = if self.signature.returnType.oclIsTypeOf(RVoid) then self.assignTo = null else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "BooleanLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "ram::Message::assignTo",
          "$$::Tuple::status",
          "ram::Message::signature",
          "ram::Operation::returnType"
        ]
      },
      {
        "operations": {
          "at": 2,
          "oclIsTypeOf": 2,
          "and": 2,
          "asOrderedSet": 2,
          "includes": 2,
          "oclAsType": 2
        },
        "name": "boundariesNotCrossed",
        "body": "Tuple {\n\tmessage : String = 'Messages may not cross boundaries of CombinedFragments or their operands',\n\tstatus : Boolean = let send : MessageOccurrenceSpecification = self.sendEvent in let receive : MessageOccurrenceSpecification = self.receiveEvent in if send.container.oclIsTypeOf(InteractionOperand) and receive.container.oclIsTypeOf(InteractionOperand) then send.container.oclAsType(InteractionOperand).CombinedFragment.covered->includes(send.covered->asOrderedSet()->at(1)) and receive.container.oclAsType(InteractionOperand).CombinedFragment.covered->includes(receive.covered->asOrderedSet()->at(1)) else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 8,
          "LetExpImpl": 2,
          "OppositePropertyCallExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 4,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 11,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::InteractionFragment::covered",
          "ram::InteractionFragment::container",
          "ram::Message::sendEvent",
          "$$::Tuple::status",
          "ram::Message::receiveEvent"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "at": 1,
          "oclIsTypeOf": 2,
          "oclIsKindOf": 1,
          "oclAsType": 3,
          "oclType": 1
        },
        "name": "validAssignTo",
        "body": "Tuple {\n\tmessage : String = 'Return type of signature operation must match the type of assignTo',\n\tstatus : Boolean = if self.assignTo <> null then let type : Type = if self.assignTo.oclIsTypeOf(Attribute) then self.assignTo.oclAsType(Attribute).type else if self.assignTo.oclIsTypeOf(Reference) then self.assignTo.oclAsType(Reference).type else self.assignTo.oclAsType(AssociationEnd).assoc.ends->select(end : AssociationEnd | end <> self)->at(1).myClass endif endif in type.oclIsKindOf(self.signature.returnType.oclType()) else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 10,
          "OperationCallExpImpl": 10,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 5,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 14,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Association::ends",
          "ram::Reference::type",
          "ram::AssociationEnd::assoc",
          "ram::Attribute::type",
          "ram::AssociationEnd::myClass",
          "ram::Message::assignTo",
          "$$::Tuple::status",
          "ram::Operation::returnType",
          "ram::Message::signature"
        ]
      }
    ],
    "properties": [
      "interaction",
      "MessageEnd",
      "returns",
      "messageSort",
      "assignTo",
      "sendEvent",
      "arguments",
      "receiveEvent",
      "signature"
    ]
  },
  {
    "name": "ObjectType",
    "expressions": [],
    "properties": [
      "Reference",
      "RCollection"
    ]
  },
  {
    "name": "DestructionOccurrenceSpecification",
    "expressions": [{
      "operations": {
        "<=": 1,
        "at": 1,
        "asOrderedSet": 1,
        "includes": 1,
        "indexOf": 2
      },
      "name": "destructionIsLast",
      "body": "Tuple {\n\tmessage : String = 'The destruction occurrence may not come before any other occurrence on this lifeline',\n\tstatus : Boolean = self.covered->asOrderedSet()->at(1).coveredBy->forAll(fragment : InteractionFragment | if self.container.fragments->includes(fragment) then self.container.fragments->indexOf(fragment) <= self.container.fragments->indexOf(self) else true endif)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 7,
        "TupleLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 9,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::InteractionFragment::covered",
        "ram::Lifeline::coveredBy",
        "ram::InteractionFragment::container",
        "$$::Tuple::status",
        "ram::FragmentContainer::fragments"
      ]
    }],
    "properties": []
  },
  {
    "name": "LiteralSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ValueSpecification",
    "expressions": [],
    "properties": [
      "CodeExecution",
      "Message",
      "ParameterValueMapping",
      "InteractionOperand"
    ]
  },
  {
    "name": "StructuralFeatureValue",
    "expressions": [{
      "operations": {
        "<>": 2,
        "at": 1,
        "oclIsTypeOf": 3,
        "oclAsType": 3,
        "oclType": 1
      },
      "name": "validValueType",
      "body": "Tuple {\n\tmessage : String = 'Type of value must match the type of the parameter',\n\tstatus : Boolean = if self.value <> null then let type : Type = if self.value.oclIsTypeOf(Attribute) then self.value.oclAsType(Attribute).type else if self.value.oclIsTypeOf(Reference) then self.value.oclAsType(Reference).type else self.value.oclAsType(AssociationEnd).assoc.ends->select(end : AssociationEnd | end <> self)->at(1).myClass endif endif in type.oclIsTypeOf(self.ParameterValueMapping.parameter.type.oclType()) else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "TupleLiteralExpImpl": 1,
        "TypeExpImpl": 5,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 14,
        "IteratorExpImpl": 1,
        "VariableExpImpl": 10,
        "OperationCallExpImpl": 10,
        "LetExpImpl": 1,
        "NullLiteralExpImpl": 1,
        "OppositePropertyCallExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "IfExpImpl": 3,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::Association::ends",
        "ram::StructuralFeatureValue::value",
        "ram::ParameterValueMapping::parameter",
        "ram::Reference::type",
        "ram::AssociationEnd::assoc",
        "ram::Attribute::type",
        "ram::Parameter::type",
        "ram::AssociationEnd::myClass",
        "$$::Tuple::status"
      ]
    }],
    "properties": ["value"]
  },
  {
    "name": "Type",
    "expressions": [],
    "properties": [
      "Operation",
      "StructuralView",
      "Parameter"
    ]
  },
  {
    "name": "PrimitiveType",
    "expressions": [],
    "properties": ["Attribute"]
  },
  {
    "name": "Reference",
    "expressions": [],
    "properties": ["type"]
  },
  {
    "name": "Classifier",
    "expressions": [],
    "properties": [
      "StructuralView",
      "Class",
      "operations",
      "Lifeline"
    ]
  },
  {
    "name": "InteractionOperand",
    "expressions": [],
    "properties": [
      "CombinedFragment",
      "interactionConstraint"
    ]
  },
  {
    "name": "FragmentContainer",
    "expressions": [],
    "properties": ["fragments"]
  },
  {
    "name": "InteractionFragment",
    "expressions": [{
      "operations": {
        "not": 1,
        "size": 1,
        "oclIsTypeOf": 1,
        "and": 1,
        "notEmpty": 1,
        "=": 1
      },
      "name": "validCoveredMultiplicity",
      "body": "Tuple {\n\tmessage : String = 'InteractionFragment may only have one Lifeline it covers (except CombinedFragment)',\n\tstatus : Boolean = if not self.oclIsTypeOf(CombinedFragment) and covered->notEmpty() then covered->size() = 1 else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 3,
        "TupleLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "IfExpImpl": 1,
        "BooleanLiteralExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "ram::InteractionFragment::covered",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "covered",
      "container"
    ]
  },
  {
    "name": "MessageSort",
    "expressions": [],
    "properties": []
  },
  {
    "name": "RCollection",
    "expressions": [{
      "operations": {
        "or": 1,
        "oclIsUndefined": 1,
        "size": 1,
        "oclIsTypeOf": 2,
        "and": 2,
        "+": 4,
        "oclAsType": 2,
        "substring": 1,
        "oclType": 2
      },
      "name": "getName",
      "body": "let partial : String = if type.oclIsTypeOf(Class) and type.oclAsType(Class).partial or type.oclIsTypeOf(Operation) and type.oclAsType(Operation).partial then '|' else '' endif in let name : String = self.oclType().name.substring(2, self.oclType().name.size()) in if type.name.oclIsUndefined() then name else name + '<' + partial + type.name + '>' endif",
      "type": "OperationImpl",
      "constructs": {
        "OperationCallExpImpl": 16,
        "VariableExpImpl": 11,
        "LetExpImpl": 2,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 4,
        "StringLiteralExpImpl": 4,
        "IfExpImpl": 2,
        "PropertyCallExpImpl": 12
      },
      "properties": [
        "ram::Class::partial",
        "pivot::NamedElement::name",
        "ram::Operation::partial",
        "ram::NamedElement::name",
        "ram::RCollection::type"
      ]
    }],
    "properties": ["type"]
  },
  {
    "name": "RList",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Property",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "=": 1,
          "-": 1,
          ">": 1
        },
        "name": "validUpperBound",
        "body": "Tuple {\n\tmessage : String = 'The upperbound must be greater than zero or -1 representing *',\n\tstatus : Boolean = self.upperBound > 0 or self.upperBound = - 1\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::Property::upperBound",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {">=": 1},
        "name": "validLowerBound",
        "body": "Tuple {\n\tmessage : String = 'The lowerbound must be greater than or equal to zero',\n\tstatus : Boolean = self.lowerBound >= 0\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "ram::Property::lowerBound",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "or": 1,
          "-": 1,
          "=": 1
        },
        "name": "validMultiplicity",
        "body": "Tuple {\n\tmessage : String = 'The lowerBound must be less than or equal to the upperBound',\n\tstatus : Boolean = self.lowerBound <= self.upperBound or self.upperBound = - 1\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "ram::Property::upperBound",
          "ram::Property::lowerBound",
          "$$::Tuple::status"
        ]
      }
    ],
    "properties": [
      "name",
      "lowerBound",
      "upperBound",
      "referenceType"
    ]
  },
  {
    "name": "Parameter",
    "expressions": [{
      "operations": {
        "not": 1,
        "oclIsTypeOf": 1
      },
      "name": "notVoid",
      "body": "Tuple {\n\tmessage : String = 'The type of the parameter may not be void',\n\tstatus : Boolean = not self.type.oclIsTypeOf(RVoid)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "TupleLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "ram::Parameter::type",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "Operation",
      "type",
      "ParameterValueMapping",
      "ParameterValue"
    ]
  },
  {
    "name": "InteractionOperatorKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Instantiation",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "=": 1
        },
        "name": "aspectCannotMapSelf",
        "body": "Tuple {\n\tmessage : String = 'Aspect may not depend on itself',\n\tstatus : Boolean = not (self.externalAspect = self.Aspect)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "OppositePropertyCallExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "ram::Instantiation::externalAspect",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {"=": 2},
        "name": "mandatoryAspectParametersMapped",
        "body": "Tuple {\n\tmessage : String = 'Partial elements from lower-level aspects have to be mapped',\n\tstatus : Boolean = if self.type = InstantiationType::Depends then self.externalAspect.mandatoryAspectParameters->forAll(element : MappableElement | self.mappings->exists(sourceModelElement = element)) else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "BooleanLiteralExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "ram::Instantiation::mappings",
          "ram::Aspect::mandatoryAspectParameters",
          "ram::Mapping::sourceModelElement",
          "ram::Instantiation::externalAspect",
          "ram::Instantiation::type",
          "$$::Tuple::status"
        ]
      }
    ],
    "properties": [
      "mappings",
      "Aspect",
      "externalAspect",
      "type"
    ]
  },
  {
    "name": "AssociationEnd",
    "expressions": [{
      "operations": {
        "<>": 2,
        "and": 1
      },
      "name": "uniqueName",
      "body": "Tuple {\n\tmessage : String = 'AssociationEnds of a class must be unique',\n\tstatus : Boolean = self.myClass.associationEnds->select(associationEnd : AssociationEnd | associationEnd.name <> null and associationEnd.name <> '')->isUnique(name)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 3,
        "NullLiteralExpImpl": 1,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 2,
        "InvalidLiteralExpImpl": 1,
        "PropertyCallExpImpl": 5
      },
      "properties": [
        "ram::Class::associationEnds",
        "ram::AssociationEnd::myClass",
        "$$::Tuple::status",
        "OclInvalid::oclBadProperty"
      ]
    }],
    "properties": [
      "assoc",
      "myClass",
      "navigable"
    ]
  },
  {
    "name": "InstantiationType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ParameterValue",
    "expressions": [{
      "operations": {
        "oclIsTypeOf": 1,
        "oclType": 1
      },
      "name": "validValueType",
      "body": "Tuple {\n\tmessage : String = 'Type of value must match the type of the parameter',\n\tstatus : Boolean = self.parameter.type.oclIsTypeOf(self.ParameterValueMapping.parameter.type.oclType())\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 2,
        "OppositePropertyCallExpImpl": 1,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 5
      },
      "properties": [
        "ram::ParameterValueMapping::parameter",
        "ram::ParameterValue::parameter",
        "ram::Parameter::type",
        "$$::Tuple::status"
      ]
    }],
    "properties": ["parameter"]
  },
  {
    "name": "Aspect",
    "expressions": [{
      "operations": {
        "allInstances": 2,
        "union": 2,
        "=": 2
      },
      "name": "mandatoryAspectParameters",
      "body": "let mappableElements : Set(MappableElement) = Set{} in mappableElements->union(Class.allInstances()->select(partial = true))->union(Operation.allInstances()->select(partial = true))",
      "type": "PropertyImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 6,
        "LetExpImpl": 1,
        "TypeExpImpl": 2,
        "CollectionLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2,
        "BooleanLiteralExpImpl": 2
      },
      "properties": [
        "ram::Class::partial",
        "ram::Operation::partial"
      ]
    }],
    "properties": [
      "layout",
      "mandatoryAspectParameters",
      "instantiations",
      "Instantiation",
      "messageViews",
      "structuralView"
    ]
  },
  {
    "name": "RChar",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Character'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getName",
        "body": "'char'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  }
]
