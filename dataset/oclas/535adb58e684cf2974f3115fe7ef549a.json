[
  {
    "name": "Forward",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Whenever",
    "expressions": [],
    "properties": [
      "Whenever",
      "Else",
      "Condition"
    ]
  },
  {
    "name": "Sequence",
    "expressions": [{
      "operations": {
        "<>": 1,
        "oclIsKindOf": 2,
        "and": 2,
        "+": 1,
        "implies": 1,
        "=": 1,
        "oclAsType": 1,
        "indexOf": 2
      },
      "name": "conflictmovement",
      "body": "\n\t\t\tself.Operations->forAll(op1, op2 | Operations->indexOf(op1)+1 = Operations->indexOf(op2) and op1.oclIsKindOf(Movement) and op2.oclIsKindOf(Movement) implies op1.oclAsType(Movement).duration <> 0.0)",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 11,
        "VariableExpImpl": 8,
        "RealLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 3,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "robot::Movement::duration",
        "robot::Sequence::Operations"
      ]
    }],
    "properties": [
      "Mission",
      "Operations"
    ]
  },
  {
    "name": "ESensor",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Compare",
    "expressions": [],
    "properties": [
      "Operator",
      "Condition2",
      "Condition1"
    ]
  },
  {
    "name": "Mission",
    "expressions": [],
    "properties": ["Sequence"]
  },
  {
    "name": "Backward",
    "expressions": [],
    "properties": []
  },
  {
    "name": "TBoolean",
    "expressions": [],
    "properties": ["Value"]
  },
  {
    "name": "EOperator",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Variable",
    "expressions": [],
    "properties": ["Name"]
  },
  {
    "name": "Value",
    "expressions": [],
    "properties": ["Variable"]
  },
  {
    "name": "Sensor",
    "expressions": [],
    "properties": ["name"]
  },
  {
    "name": "Condition",
    "expressions": [],
    "properties": [
      "While",
      "Whenever",
      "Event",
      "Alternative",
      "Compare",
      "Compare"
    ]
  },
  {
    "name": "Values",
    "expressions": [],
    "properties": [
      "Var",
      "Value"
    ]
  },
  {
    "name": "Operator",
    "expressions": [],
    "properties": [
      "type",
      "Compare"
    ]
  },
  {
    "name": "TurnLeft",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Different",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Affectation",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Sleep",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Movement",
    "expressions": [{
      "operations": {">=": 1},
      "name": "positif",
      "body": "\n\t\t\tself.duration >= 0",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["robot::Movement::duration"]
    }],
    "properties": ["duration"]
  },
  {
    "name": "Alternative",
    "expressions": [],
    "properties": [
      "Consequence",
      "Condition",
      "Alternative"
    ]
  },
  {
    "name": "Declaration",
    "expressions": [],
    "properties": []
  },
  {
    "name": "While",
    "expressions": [],
    "properties": [
      "Operation",
      "Condition"
    ]
  },
  {
    "name": "Echo",
    "expressions": [],
    "properties": ["param"]
  },
  {
    "name": "TurnRight",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Event",
    "expressions": [],
    "properties": [
      "Condition",
      "At",
      "Onleave"
    ]
  },
  {
    "name": "TInteger",
    "expressions": [],
    "properties": ["Value"]
  },
  {
    "name": "Stop",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Var",
    "expressions": [],
    "properties": [
      "Name",
      "Value"
    ]
  },
  {
    "name": "TFloat",
    "expressions": [],
    "properties": ["Value"]
  },
  {
    "name": "Operation",
    "expressions": [],
    "properties": [
      "Whenever",
      "Sequence",
      "Alternative",
      "While",
      "Event",
      "Alternative",
      "Event",
      "Whenever"
    ]
  },
  {
    "name": "TString",
    "expressions": [],
    "properties": ["Value"]
  }
]
