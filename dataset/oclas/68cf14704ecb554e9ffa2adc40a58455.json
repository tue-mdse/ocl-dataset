[
  {
    "name": "CreateLinkAction",
    "expressions": [{
      "operations": {
        "not": 1,
        "association": 1
      },
      "name": "association_not_abstract",
      "body": "not self.association().isAbstract",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::Classifier::isAbstract"]
    }],
    "properties": ["endData"]
  },
  {
    "name": "ExpansionKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "CreateLinkObjectAction",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "association": 1
        },
        "name": "association_class",
        "body": "self.association().oclIsKindOf(AssociationClass)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "association": 1,
          "=": 1
        },
        "name": "type_of_result",
        "body": "result.type = association()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::CreateLinkObjectAction::result"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity",
        "body": "result.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CreateLinkObjectAction::result"]
      }
    ],
    "properties": ["result"]
  },
  {
    "name": "Profile",
    "expressions": [
      {
        "operations": {
          "union": 1,
          "allOwningPackages": 2,
          "notEmpty": 1
        },
        "name": "references_same_metamodel",
        "body": "metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages()->\r\n  union(metaclassReference.importedElement.allOwningPackages() )->notEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 8,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Profile::metamodelReference",
          "UML::PackageImport::importedPackage",
          "UML::Profile::metaclassReference",
          "UML::ElementImport::importedElement",
          "UML::Namespace::elementImport"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 3,
          "and": 2,
          "intersection": 1,
          "allParents": 2,
          "isEmpty": 2,
          "includes": 1,
          "oclAsType": 3
        },
        "name": "metaclass_reference_not_specialized",
        "body": "metaclassReference.importedElement->\r\n\tselect(c | c.oclIsKindOf(Classifier) and\r\n\t\t(c.oclAsType(Classifier).allParents()->collect(namespace)->includes(self)))->isEmpty()\r\nand \r\npackagedElement->\r\n    select(oclIsKindOf(Classifier))->collect(oclAsType(Classifier).allParents())->\r\n       intersection(metaclassReference.importedElement->select(oclIsKindOf(Classifier))->collect(oclAsType(Classifier)))->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 8,
          "OperationCallExpImpl": 14,
          "VariableExpImpl": 13,
          "TypeExpImpl": 6,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::ElementImport::importedElement",
          "UML::Profile::metaclassReference",
          "UML::Package::packagedElement",
          "UML::NamedElement::namespace"
        ]
      }
    ],
    "properties": [
      "metamodelReference",
      "metaclassReference",
      "profileApplication",
      "stereotype"
    ]
  },
  {
    "name": "ActivityPartition",
    "expressions": [
      {
        "operations": {
          "isEmpty": 1,
          "oclAsSet": 1,
          "implies": 1
        },
        "name": "dimension_not_contained",
        "body": "isDimension implies superPartition->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityPartition::superPartition",
          "UML::ActivityPartition::isDimension"
        ]
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 3,
          "and": 3,
          "oclAsSet": 1,
          "notEmpty": 1,
          "implies": 1,
          "oclAsType": 1,
          "=": 2
        },
        "name": "represents_property_and_is_contained",
        "body": "(represents.oclIsKindOf(Property) and superPartition->notEmpty()) implies\r\n(\r\n  (superPartition.represents.oclIsKindOf(Classifier) and represents.owner = superPartition.represents) or \r\n  (superPartition.represents.oclIsKindOf(Property) and represents.owner = superPartition.represents.oclAsType(Property).type)\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 8,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 15
        },
        "properties": [
          "UML::ActivityPartition::superPartition",
          "UML::TypedElement::type",
          "UML::ActivityPartition::represents",
          "UML::Element::owner"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 3,
          "and": 3,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "represents_property",
        "body": "(represents.oclIsKindOf(Property) and superPartition->notEmpty() and superPartition.represents.oclIsKindOf(Classifier)) implies\r\n(\r\n  let representedClassifier : Classifier = superPartition.represents.oclAsType(Classifier)\r\n  in\r\n    superPartition.subpartition->reject(isExternal)->forAll(p | \r\n       p.represents.oclIsKindOf(Property) and p.owner=representedClassifier)\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 9,
          "LetExpImpl": 1,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 11
        },
        "properties": [
          "UML::ActivityPartition::superPartition",
          "UML::ActivityPartition::represents",
          "UML::ActivityPartition::isExternal",
          "UML::Element::owner",
          "UML::ActivityPartition::subpartition"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "not": 1,
          "or": 2,
          "oclIsKindOf": 5,
          "and": 9,
          "oclAsSet": 1,
          "allInstances": 1,
          "includes": 2,
          "notEmpty": 1,
          "implies": 1,
          "oclAsType": 5,
          "=": 2
        },
        "name": "represents_classifier",
        "body": "(not isExternal and represents.oclIsKindOf(Classifier) and superPartition->notEmpty()) implies\r\n(\r\n   let representedClassifier : Classifier = represents.oclAsType(Classifier) in\r\n     superPartition.represents.oclIsKindOf(Classifier) and\r\n      let representedSuperClassifier : Classifier = superPartition.represents.oclAsType(Classifier) in\r\n       (representedSuperClassifier.oclIsKindOf(BehavioredClassifier) and representedClassifier.oclIsKindOf(Behavior) and \r\n        representedSuperClassifier.oclAsType(BehavioredClassifier).ownedBehavior->includes(representedClassifier.oclAsType(Behavior))) \r\n       or\r\n       (representedSuperClassifier.oclIsKindOf(Class) and  representedSuperClassifier.oclAsType(Class).nestedClassifier->includes(representedClassifier))\r\n       or\r\n       (Association.allInstances()->exists(a | a.memberEnd->exists(end1 | end1.isComposite and end1.type = representedClassifier and \r\n                                                                      a.memberEnd->exists(end2 | end1<>end2 and end2.type = representedSuperClassifier))))\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 22,
          "OperationCallExpImpl": 31,
          "LetExpImpl": 2,
          "TypeExpImpl": 11,
          "PropertyCallExpImpl": 15
        },
        "properties": [
          "UML::BehavioredClassifier::ownedBehavior",
          "UML::ActivityPartition::superPartition",
          "UML::Class::nestedClassifier",
          "UML::TypedElement::type",
          "UML::Association::memberEnd",
          "UML::ActivityPartition::represents",
          "UML::Property::isComposite",
          "UML::ActivityPartition::isExternal"
        ]
      }
    ],
    "properties": [
      "edge",
      "superPartition",
      "node",
      "represents",
      "isExternal",
      "isDimension",
      "activity",
      "subpartition"
    ]
  },
  {
    "name": "GeneralizationSet",
    "expressions": [
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "asSet": 1
        },
        "name": "generalization_same_classifier",
        "body": "generalization->collect(general)->asSet()->size() <= 1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Generalization::general",
          "UML::GeneralizationSet::generalization"
        ]
      },
      {
        "operations": {
          "not": 4,
          "<>": 1,
          "and": 3,
          "allParents": 2,
          "includes": 2,
          "implies": 1,
          "=": 2
        },
        "name": "maps_to_generalization_set",
        "body": "powertype <> null implies generalization->forAll( gen | \r\n    not (gen.general = powertype) and not gen.general.allParents()->includes(powertype) and not (gen.specific = powertype) and not powertype.allParents()->includes(gen.specific)\r\n  )",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 15,
          "VariableExpImpl": 10,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::Generalization::general",
          "UML::GeneralizationSet::powertype",
          "UML::GeneralizationSet::generalization",
          "UML::Generalization::specific"
        ]
      }
    ],
    "properties": [
      "powertype",
      "generalization",
      "isDisjoint",
      "isCovering"
    ]
  },
  {
    "name": "ReadVariableAction",
    "expressions": [
      {
        "operations": {
          "and": 1,
          "=": 2
        },
        "name": "type_and_ordering",
        "body": "result.type =variable.type and \nresult.isOrdered = variable.isOrdered\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::ReadVariableAction::result",
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::VariableAction::variable"
        ]
      },
      {
        "operations": {"compatibleWith": 1},
        "name": "compatible_multiplicity",
        "body": "variable.compatibleWith(result)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReadVariableAction::result",
          "UML::VariableAction::variable"
        ]
      }
    ],
    "properties": ["result"]
  },
  {
    "name": "MessageOccurrenceSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "LiteralString",
    "expressions": [
      {
        "operations": {},
        "name": "isComputable",
        "body": "true",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "stringValue",
        "body": "value",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::LiteralString::value"]
      }
    ],
    "properties": ["value"]
  },
  {
    "name": "InvocationAction",
    "expressions": [],
    "properties": [
      "argument",
      "onPort"
    ]
  },
  {
    "name": "Parameter",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "implies": 1,
          "=": 1
        },
        "name": "object_effect",
        "body": "(type.oclIsKindOf(DataType)) implies (effect = null)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Parameter::effect"
        ]
      },
      {
        "operations": {
          "not": 1,
          "and": 1
        },
        "name": "stream_and_exception",
        "body": "not (isException and isStream)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Parameter::isStream",
          "UML::Parameter::isException"
        ]
      },
      {
        "operations": {
          "or": 3,
          "and": 1,
          "implies": 2,
          "=": 7
        },
        "name": "in_and_out",
        "body": "(effect = ParameterEffectKind::delete implies (direction = ParameterDirectionKind::_'in' or direction = ParameterDirectionKind::inout))\r\nand\r\n(effect = ParameterEffectKind::create implies (direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::return))",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 7,
          "EnumLiteralExpImpl": 7,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::Parameter::effect",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "stringValue": 1,
          "=": 1
        },
        "name": "default",
        "body": "if self.type = String then defaultValue.stringValue() else null endif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Parameter::defaultValue"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "and": 1,
          "implies": 1
        },
        "name": "not_exception",
        "body": "isException implies (direction <> ParameterDirectionKind::_'in' and direction <> ParameterDirectionKind::inout)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Parameter::isException",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "notEmpty": 2,
          "implies": 1
        },
        "name": "connector_end",
        "body": "end->notEmpty() implies collaboration->notEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "OppositePropertyCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ConnectableElement::end"]
      },
      {
        "operations": {
          "<>": 1,
          "not": 1,
          "and": 1,
          "implies": 1
        },
        "name": "reentrant_behaviors",
        "body": "(isStream and behavior <> null) implies not behavior.isReentrant",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "OppositePropertyCallExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Parameter::isStream",
          "UML::Behavior::isReentrant"
        ]
      }
    ],
    "properties": [
      "effect",
      "isStream",
      "parameterSet",
      "ownerFormalParam",
      "isException",
      "opaqueExpression",
      "defaultValue",
      "operation",
      "behavior",
      "default",
      "activityParameterNode",
      "direction"
    ]
  },
  {
    "name": "ValueSpecificationAction",
    "expressions": [
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity",
        "body": "result.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ValueSpecificationAction::result"]
      },
      {
        "operations": {"conformsTo": 1},
        "name": "compatible_type",
        "body": "value.type.conformsTo(result.type)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ValueSpecificationAction::result",
          "UML::ValueSpecificationAction::value"
        ]
      }
    ],
    "properties": [
      "result",
      "value"
    ]
  },
  {
    "name": "Artifact",
    "expressions": [],
    "properties": [
      "ownedOperation",
      "artifact",
      "manifestation",
      "ownedAttribute",
      "nestedArtifact",
      "fileName"
    ]
  },
  {
    "name": "ParameterEffectKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Expression",
    "expressions": [],
    "properties": [
      "symbol",
      "operand"
    ]
  },
  {
    "name": "ConnectableElement",
    "expressions": [{
      "operations": {
        "allInstances": 1,
        "=": 1
      },
      "name": "end",
      "body": "ConnectorEnd.allInstances()->select(role = self)",
      "type": "OperationImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 2,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::ConnectorEnd::role"]
    }],
    "properties": [
      "collaboration",
      "end",
      "templateParameter",
      "structuredClassifier",
      "lifeline"
    ]
  },
  {
    "name": "DurationInterval",
    "expressions": [],
    "properties": [
      "min",
      "max",
      "durationConstraint"
    ]
  },
  {
    "name": "Feature",
    "expressions": [],
    "properties": [
      "isStatic",
      "featuringClassifier"
    ]
  },
  {
    "name": "Trigger",
    "expressions": [{
      "operations": {
        "oclIsKindOf": 1,
        "implies": 1,
        "notEmpty": 1
      },
      "name": "trigger_with_ports",
      "body": "port->notEmpty() implies event.oclIsKindOf(MessageEvent)",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 3,
        "VariableExpImpl": 2,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::Trigger::event",
        "UML::Trigger::port"
      ]
    }],
    "properties": [
      "event",
      "acceptEventAction",
      "transition",
      "replyAction",
      "port",
      "state"
    ]
  },
  {
    "name": "BehaviorExecutionSpecification",
    "expressions": [],
    "properties": ["behavior"]
  },
  {
    "name": "ConditionalNode",
    "expressions": [
      {
        "operations": {
          "oclAsSet": 1,
          "asSet": 1
        },
        "name": "allActions",
        "body": "self->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "intersection": 1,
          "isEmpty": 1
        },
        "name": "clause_no_predecessor",
        "body": "clause->closure(predecessorClause)->intersection(clause)->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Clause::predecessorClause",
          "UML::ConditionalNode::clause"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "union": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "executable_nodes",
        "body": "clause.test->union(clause._'body') = node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 7,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::StructuredActivityNode::node",
          "UML::ConditionalNode::clause",
          "UML::Clause::test",
          "UML::Clause::body"
        ]
      },
      {
        "operations": {"isEmpty": 1},
        "name": "no_input_pins",
        "body": "input->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Action::input"]
      },
      {
        "operations": {
          "size": 1,
          "oclIsKindOf": 1,
          "includes": 1,
          "union": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "one_clause_with_executable_node",
        "body": "node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->forAll(n | \r\n\tself.clause->select(test->union(_'body')->includes(n))->size()=1)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 6,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::StructuredActivityNode::node",
          "UML::ConditionalNode::clause",
          "UML::Clause::test",
          "UML::Clause::body"
        ]
      },
      {
        "operations": {"isEmpty": 1},
        "name": "result_no_incoming",
        "body": "result.incoming->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ConditionalNode::result",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "at": 8,
          "compatibleWith": 1,
          "size": 3,
          "and": 4,
          "conformsTo": 1,
          "=": 3
        },
        "name": "matching_output_pins",
        "body": "clause->forAll(\r\n\tbodyOutput->size()=self.result->size() and\r\n\tSequence{1..self.result->size()}->forAll(i |\r\n\t\tbodyOutput->at(i).type.conformsTo(result->at(i).type) and\r\n\t\tbodyOutput->at(i).isOrdered = result->at(i).isOrdered and\r\n\t\tbodyOutput->at(i).isUnique = result->at(i).isUnique and\r\n\t\tbodyOutput->at(i).compatibleWith(result->at(i))))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 20,
          "VariableExpImpl": 20,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 18
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::ConditionalNode::result",
          "UML::Clause::bodyOutput",
          "UML::ConditionalNode::clause",
          "UML::MultiplicityElement::isUnique"
        ]
      }
    ],
    "properties": [
      "result",
      "clause",
      "isDeterminate",
      "isAssured"
    ]
  },
  {
    "name": "ConnectableElementTemplateParameter",
    "expressions": [],
    "properties": ["parameteredElement"]
  },
  {
    "name": "Clause",
    "expressions": [
      {
        "operations": {
          "includesAll": 1,
          "allActions": 1,
          "oclAsType": 1
        },
        "name": "body_output_pins",
        "body": "_'body'.oclAsType(Action).allActions().output->includesAll(bodyOutput)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 5,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Action::output",
          "UML::Clause::bodyOutput",
          "UML::Clause::body"
        ]
      },
      {
        "operations": {
          "allActions": 1,
          "and": 2,
          "includes": 1,
          "toUnlimitedNatural": 1,
          "is": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "decider_output",
        "body": "test.oclAsType(Action).allActions().output->includes(decider) and\r\ndecider.type = Boolean and\r\ndecider.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 8,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Clause::decider",
          "UML::TypedElement::type",
          "UML::Action::output",
          "UML::Clause::test"
        ]
      },
      {
        "operations": {
          "intersection": 1,
          "isEmpty": 1
        },
        "name": "test_and_body",
        "body": "test->intersection(_'body')->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Clause::test",
          "UML::Clause::body"
        ]
      }
    ],
    "properties": [
      "predecessorClause",
      "decider",
      "conditionalNode",
      "bodyOutput",
      "test",
      "body",
      "successorClause"
    ]
  },
  {
    "name": "LiteralInteger",
    "expressions": [
      {
        "operations": {},
        "name": "integerValue",
        "body": "value",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::LiteralInteger::value"]
      },
      {
        "operations": {},
        "name": "isComputable",
        "body": "true",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": ["value"]
  },
  {
    "name": "FinalState",
    "expressions": [
      {
        "operations": {
          "isEmpty": 1,
          "oclAsSet": 1
        },
        "name": "no_exit_behavior",
        "body": "exit->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::exit"]
      },
      {
        "operations": {
          "isEmpty": 1,
          "oclAsSet": 1
        },
        "name": "no_state_behavior",
        "body": "doActivity->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::doActivity"]
      },
      {
        "operations": {
          "isEmpty": 1,
          "oclAsSet": 1
        },
        "name": "cannot_reference_submachine",
        "body": "submachine->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::submachine"]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "no_regions",
        "body": "region->size() = 0",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::region"]
      },
      {
        "operations": {
          "isEmpty": 1,
          "oclAsSet": 1
        },
        "name": "no_entry_behavior",
        "body": "entry->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::entry"]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "no_outgoing_transitions",
        "body": "outgoing->size() = 0",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Vertex::outgoing"]
      }
    ],
    "properties": []
  },
  {
    "name": "ProfileApplication",
    "expressions": [],
    "properties": [
      "appliedProfile",
      "applyingPackage",
      "isStrict"
    ]
  },
  {
    "name": "VariableAction",
    "expressions": [{
      "operations": {"isAccessibleBy": 1},
      "name": "scope_of_variable",
      "body": "variable.isAccessibleBy(self)",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 2,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::VariableAction::variable"]
    }],
    "properties": ["variable"]
  },
  {
    "name": "Pseudostate",
    "expressions": [
      {
        "operations": {
          "<=": 1,
          "or": 1,
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "history_vertices",
        "body": "((kind = PseudostateKind::deepHistory) or (kind = PseudostateKind::shallowHistory)) implies (outgoing->size() <= 1)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 6,
          "EnumLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 1,
          "implies": 1,
          "=": 1,
          ">=": 2
        },
        "name": "junction_vertex",
        "body": "(kind = PseudostateKind::junction) implies (incoming->size() >= 1 and outgoing->size() >= 1)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 7,
          "IntegerLiteralExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing",
          "UML::Vertex::incoming"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 1,
          "implies": 1,
          "=": 2,
          ">=": 1
        },
        "name": "join_vertex",
        "body": "(kind = PseudostateKind::join) implies (outgoing->size() = 1 and incoming->size() >= 2)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing",
          "UML::Vertex::incoming"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "implies": 1,
          "=": 1
        },
        "name": "initial_vertex",
        "body": "(kind = PseudostateKind::initial) implies (outgoing->size() <= 1)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 1,
          "implies": 1,
          "=": 1,
          ">=": 2
        },
        "name": "choice_vertex",
        "body": "(kind = PseudostateKind::choice) implies (incoming->size() >= 1 and outgoing->size() >= 1)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing",
          "UML::Vertex::incoming"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 1,
          "implies": 1,
          "=": 2,
          ">=": 1
        },
        "name": "fork_vertex",
        "body": "(kind = PseudostateKind::fork) implies (incoming->size() = 1 and outgoing->size() >= 2)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing",
          "UML::Vertex::incoming"
        ]
      },
      {
        "operations": {
          "and": 1,
          "isEmpty": 1,
          "implies": 1,
          "=": 2
        },
        "name": "outgoing_from_initial",
        "body": "(kind = PseudostateKind::initial) implies (outgoing.guard = null and outgoing.trigger->isEmpty())",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing",
          "UML::Transition::guard",
          "UML::Transition::trigger"
        ]
      },
      {
        "operations": {
          "isContainedInRegion": 2,
          "<>": 2,
          "and": 3,
          "LCAState": 1,
          "implies": 1,
          "=": 1,
          "containingStateMachine": 1
        },
        "name": "transitions_outgoing",
        "body": "(kind = PseudostateKind::fork) implies\r\n\r\n-- for any pair of outgoing transitions there exists an orthogonal state which contains the targets of these transitions \r\n-- such that these targets belong to different regions of that orthogonal state \r\n\r\noutgoing->forAll(t1:Transition, t2:Transition | let contState:State = containingStateMachine().LCAState(t1.target, t2.target) in\r\n\t((contState <> null) and (contState.region\r\n\t\t->exists(r1:Region, r2: Region | (r1 <> r2) and t1.target.isContainedInRegion(r1) and t2.target.isContainedInRegion(r2)))))\r\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 13,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::State::region",
          "UML::Vertex::outgoing",
          "UML::Transition::target"
        ]
      },
      {
        "operations": {
          "isContainedInRegion": 2,
          "<>": 2,
          "and": 3,
          "LCAState": 1,
          "implies": 1,
          "=": 1,
          "containingStateMachine": 1
        },
        "name": "transitions_incoming",
        "body": "(kind = PseudostateKind::join) implies\n\n-- for any pair of incoming transitions there exists an orthogonal state which contains the source vetices of these transitions \n-- such that these source vertices belong to different regions of that orthogonal state \n\nincoming->forAll(t1:Transition, t2:Transition | let contState:State = containingStateMachine().LCAState(t1.source, t2.source) in\n\t((contState <> null) and (contState.region\n\t\t->exists(r1:Region, r2: Region | (r1 <> r2) and t1.source.isContainedInRegion(r1) and t2.source.isContainedInRegion(r2)))))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 13,
          "OperationCallExpImpl": 11,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::State::region",
          "UML::Transition::source",
          "UML::Vertex::incoming"
        ]
      }
    ],
    "properties": [
      "kind",
      "state",
      "connectionPointReference",
      "connectionPointReference",
      "stateMachine"
    ]
  },
  {
    "name": "ElementImport",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "implies": 1,
          "=": 1
        },
        "name": "imported_element_is_public",
        "body": "importedElement.visibility <> null implies importedElement.visibility = VisibilityKind::public",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ElementImport::importedElement",
          "UML::PackageableElement::visibility"
        ]
      },
      {
        "operations": {
          "or": 1,
          "=": 2
        },
        "name": "visibility_public_or_private",
        "body": "visibility = VisibilityKind::public or visibility = VisibilityKind::private",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::ElementImport::visibility"]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "getName",
        "body": "if alias->notEmpty() then\n  alias\nelse\n  importedElement.name\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ElementImport::alias",
          "UML::ElementImport::importedElement",
          "UML::NamedElement::name"
        ]
      }
    ],
    "properties": [
      "alias",
      "profile",
      "importedElement",
      "importingNamespace",
      "visibility"
    ]
  },
  {
    "name": "ExpansionRegion",
    "expressions": [],
    "properties": [
      "outputElement",
      "inputElement",
      "mode"
    ]
  },
  {
    "name": "ObjectNode",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "oclIsKindOf": 1,
          "union": 1,
          "implies": 1
        },
        "name": "object_flow_edges",
        "body": "(not isControlType) implies incoming->union(outgoing)->forAll(oclIsKindOf(ObjectFlow))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 4,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ObjectNode::isControlType",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "not": 1,
          "<>": 1,
          "size": 2,
          "and": 5,
          "is": 1,
          "conformsTo": 2,
          "implies": 1,
          "inputParameters": 3,
          "=": 2,
          "outputParameters": 1
        },
        "name": "input_output_parameter",
        "body": "selection<>null implies\r\n\tselection.inputParameters()->size()=1 and\r\n\tselection.inputParameters()->forAll(p | not p.isUnique and p.is(0,*) and self.type.conformsTo(p.type)) and\r\n\tselection.outputParameters()->size()=1 and\r\n\t\tselection.inputParameters()->forAll(p | self.type.conformsTo(p.type))\r\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 11,
          "OperationCallExpImpl": 19,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 3,
          "UnlimitedNaturalLiteralExpImpl": 1,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ObjectNode::selection",
          "UML::MultiplicityElement::isUnique"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "=": 2
        },
        "name": "selection_behavior",
        "body": "(selection<>null) = (ordering=ObjectNodeOrderingKind::ordered)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ObjectNode::ordering",
          "UML::ObjectNode::selection"
        ]
      }
    ],
    "properties": [
      "inState",
      "ordering",
      "isControlType",
      "selection",
      "upperBound",
      "exceptionHandler"
    ]
  },
  {
    "name": "ActivityFinalNode",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ParameterSet",
    "expressions": [
      {
        "operations": {
          "and": 3,
          "isEmpty": 2,
          "implies": 2,
          "=": 4
        },
        "name": "input",
        "body": "((parameter->exists(direction = ParameterDirectionKind::_'in')) implies \r\n    behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::_'in' and p.parameterSet->isEmpty())->forAll(isStream))\r\n    and\r\n((parameter->exists(direction = ParameterDirectionKind::out)) implies \r\n    behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::out and p.parameterSet->isEmpty())->forAll(isStream))  \r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "VariableExpImpl": 12,
          "OperationCallExpImpl": 11,
          "OppositePropertyCallExpImpl": 2,
          "EnumLiteralExpImpl": 4,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "UML::BehavioralFeature::ownedParameter",
          "UML::Parameter::isStream",
          "UML::Parameter::parameterSet",
          "UML::ParameterSet::parameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "not": 1,
          "size": 2,
          "oclAsSet": 2,
          "includes": 1,
          "implies": 1,
          "=": 1
        },
        "name": "two_parameter_sets",
        "body": "parameter->forAll(parameterSet->forAll(s1, s2 | s1->size() = s2->size() implies s1.parameter->exists(p | not s2.parameter->includes(p))))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 8,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Parameter::parameterSet",
          "UML::ParameterSet::parameter"
        ]
      },
      {
        "operations": {
          "and": 2,
          "=": 3
        },
        "name": "same_parameterized_entity",
        "body": "parameter->forAll(p1, p2 | self.owner = p1.owner and self.owner = p2.owner and p1.direction = p2.direction)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 7,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::ParameterSet::parameter",
          "UML::Element::owner",
          "UML::Parameter::direction"
        ]
      }
    ],
    "properties": [
      "parameter",
      "condition",
      "behavioralFeature",
      "behavior"
    ]
  },
  {
    "name": "String",
    "expressions": [],
    "properties": []
  },
  {
    "name": "LiteralSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "WriteVariableAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "toUnlimitedNatural": 1,
          "is": 1,
          "implies": 1
        },
        "name": "multiplicity",
        "body": "value<>null implies value.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::WriteVariableAction::value"]
      },
      {
        "operations": {
          "<>": 1,
          "conformsTo": 1,
          "implies": 1
        },
        "name": "value_type",
        "body": "value <> null implies value.type.conformsTo(variable.type)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::WriteVariableAction::value",
          "UML::VariableAction::variable"
        ]
      }
    ],
    "properties": ["value"]
  },
  {
    "name": "ComponentRealization",
    "expressions": [],
    "properties": [
      "abstraction",
      "realizingClassifier"
    ]
  },
  {
    "name": "DataStoreNode",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ExtensionEnd",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "aggregation",
        "body": "self.aggregation = AggregationKind::composite",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Property::aggregation"]
      },
      {
        "operations": {
          "or": 1,
          "upperBound": 1,
          "and": 1,
          "lowerBound": 2,
          "=": 3
        },
        "name": "multiplicity",
        "body": "(lowerBound() = 0 or lowerBound() = 1) and upperBound() = 1",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 3
        },
        "properties": []
      },
      {
        "operations": {
          "integerValue": 1,
          "=": 1
        },
        "name": "lowerBound",
        "body": "if lowerValue=null then 0 else lowerValue.integerValue() endif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::MultiplicityElement::lowerValue"]
      }
    ],
    "properties": [
      "type",
      "extension",
      "lower"
    ]
  },
  {
    "name": "DeployedArtifact",
    "expressions": [],
    "properties": ["deploymentForArtifact"]
  },
  {
    "name": "TimeExpression",
    "expressions": [{
      "operations": {
        "size": 1,
        "oclIsKindOf": 1,
        "and": 1,
        "implies": 1,
        "=": 2
      },
      "name": "no_expr_requires_observation",
      "body": "expr = null implies (observation->size() = 1 and observation->forAll(oclIsKindOf(TimeObservation)))",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 4,
        "NullLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::TimeExpression::observation",
        "UML::TimeExpression::expr"
      ]
    }],
    "properties": [
      "timeEvent",
      "timeInterval",
      "observation",
      "expr",
      "timeInterval"
    ]
  },
  {
    "name": "AcceptEventAction",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "or": 2,
          "oclIsKindOf": 1,
          "and": 1,
          "isEmpty": 1,
          "conformsTo": 1,
          "implies": 1,
          "oclAsType": 1,
          "=": 1,
          "first": 1
        },
        "name": "conforming_type",
        "body": "not isUnmarshall implies \r\n\tresult->isEmpty() or\r\n\tlet type: Type = result->first().type in\r\n\ttype=null or \r\n\t\t(trigger->forAll(event.oclIsKindOf(SignalEvent)) and \r\n\t\t trigger.event.oclAsType(SignalEvent).signal->forAll(s | s.conformsTo(type)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 5,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 12,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::Trigger::event",
          "UML::AcceptEventAction::result",
          "UML::SignalEvent::signal",
          "UML::TypedElement::type",
          "UML::AcceptEventAction::isUnmarshall",
          "UML::AcceptEventAction::trigger"
        ]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "no_input_pins",
        "body": "input->size() = 0",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Action::input"]
      },
      {
        "operations": {
          "or": 1,
          "size": 1,
          "oclIsTypeOf": 1,
          "oclIsKindOf": 2,
          "and": 1,
          "implies": 1,
          "=": 1
        },
        "name": "no_output_pins",
        "body": "(self.oclIsTypeOf(AcceptEventAction) and\r\n   (trigger->forAll(event.oclIsKindOf(ChangeEvent) or  \r\n                             event.oclIsKindOf(CallEvent))))\r\nimplies output->size() = 0",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 8,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Trigger::event",
          "UML::AcceptEventAction::trigger",
          "UML::Action::output"
        ]
      },
      {
        "operations": {
          "not": 1,
          "or": 1,
          "size": 1,
          "oclIsKindOf": 2,
          "and": 2,
          "is": 1,
          "toUnlimitedNatural": 1,
          "implies": 1,
          "=": 1,
          "first": 1
        },
        "name": "one_output_pin",
        "body": "not isUnmarshall and trigger->exists(event.oclIsKindOf(SignalEvent) or event.oclIsKindOf(TimeEvent)) implies \r\n\toutput->size() = 1 and output->first().is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 6,
          "IntegerLiteralExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Trigger::event",
          "UML::AcceptEventAction::isUnmarshall",
          "UML::AcceptEventAction::trigger",
          "UML::Action::output"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "allAttributes": 1,
          "oclAsType": 1,
          "asSequence": 2,
          "at": 6,
          "size": 5,
          "oclIsTypeOf": 1,
          "and": 7,
          "includesMultiplicity": 1,
          "implies": 1,
          "=": 4,
          ">": 1,
          "first": 2
        },
        "name": "unmarshall_signal_events",
        "body": "isUnmarshall and self.oclIsTypeOf(AcceptEventAction) implies\r\n\ttrigger->size()=1 and\r\n\ttrigger->asSequence()->first().event.oclIsKindOf(SignalEvent) and\r\n\tlet attribute: OrderedSet(Property) = trigger->asSequence()->first().event.oclAsType(SignalEvent).signal.allAttributes() in\r\n\tattribute->size()>0 and result->size() = attribute->size() and\r\n\tSequence{1..result->size()}->forAll(i | \r\n\t\tresult->at(i).type = attribute->at(i).type and \r\n\t\tresult->at(i).isOrdered = attribute->at(i).isOrdered and\r\n\t\tresult->at(i).includesMultiplicity(attribute->at(i)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 33,
          "VariableExpImpl": 21,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 3,
          "TypeExpImpl": 3,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 16
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::Trigger::event",
          "UML::AcceptEventAction::result",
          "UML::SignalEvent::signal",
          "UML::TypedElement::type",
          "UML::AcceptEventAction::isUnmarshall",
          "UML::AcceptEventAction::trigger"
        ]
      }
    ],
    "properties": [
      "result",
      "isUnmarshall",
      "trigger"
    ]
  },
  {
    "name": "MessageSort",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Association",
    "expressions": [
      {
        "operations": {
          "includesAll": 1,
          "size": 1,
          "implies": 1,
          ">": 1
        },
        "name": "association_ends",
        "body": "memberEnd->size() > 2 implies ownedEnd->includesAll(memberEnd)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::Association::ownedEnd"
        ]
      },
      {
        "operations": {"asSet": 1},
        "name": "endType",
        "body": "memberEnd->collect(type)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Association::memberEnd"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "ends_must_be_typed",
        "body": "memberEnd->forAll(type->notEmpty())",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Association::memberEnd"
        ]
      },
      {
        "operations": {
          "at": 2,
          "size": 1,
          "oclIsKindOf": 1,
          "conformsTo": 1,
          "oclAsType": 1
        },
        "name": "specialized_end_types",
        "body": "Sequence{1..memberEnd->size()}->\r\n\tforAll(i | general->select(oclIsKindOf(Association)).oclAsType(Association)->\r\n\t\tforAll(ga | self.memberEnd->at(i).type.conformsTo(ga.memberEnd->at(i).type)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 8,
          "OperationCallExpImpl": 6,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Classifier::general",
          "UML::TypedElement::type",
          "UML::Association::memberEnd"
        ]
      },
      {
        "operations": {
          "size": 2,
          "oclIsKindOf": 1,
          "oclAsType": 1,
          "=": 1,
          "parents": 1
        },
        "name": "specialized_end_number",
        "body": "parents()->select(oclIsKindOf(Association)).oclAsType(Association)->forAll(p | p.memberEnd->size() = self.memberEnd->size())",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 6,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Association::memberEnd"]
      },
      {
        "operations": {
          "<>": 1,
          "size": 1,
          "and": 1,
          "implies": 1,
          "=": 2
        },
        "name": "binary_associations",
        "body": "memberEnd->exists(aggregation <> AggregationKind::none) implies (memberEnd->size() = 2 and memberEnd->exists(aggregation = AggregationKind::none))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 6,
          "EnumLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::Property::aggregation"
        ]
      }
    ],
    "properties": [
      "connector",
      "memberEnd",
      "navigableOwnedEnd",
      "clearAssociationAction",
      "isDerived",
      "endType",
      "ownedEnd"
    ]
  },
  {
    "name": "MessageKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "OccurrenceSpecification",
    "expressions": [],
    "properties": [
      "covered",
      "executionSpecification",
      "toAfter",
      "executionSpecification",
      "toBefore"
    ]
  },
  {
    "name": "ProtocolTransition",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "associated_actions",
        "body": "effect = null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Transition::effect"]
      },
      {
        "operations": {"belongsToPSM": 1},
        "name": "belongs_to_psm",
        "body": "container.belongsToPSM()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Transition::container"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "referred",
        "body": "trigger->collect(event)->select(oclIsKindOf(CallEvent))->collect(oclAsType(CallEvent).operation)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 4,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Trigger::event",
          "UML::CallEvent::operation",
          "UML::Transition::trigger"
        ]
      },
      {
        "operations": {
          "includesAll": 1,
          "and": 1,
          "allFeatures": 1,
          "oclAsSet": 1,
          "notEmpty": 2,
          "oclAsType": 1,
          "referred": 2,
          "containingStateMachine": 2
        },
        "name": "refers_to_operation",
        "body": "if (referred()->notEmpty() and containingStateMachine()._'context'->notEmpty()) then \r\n    containingStateMachine()._'context'.oclAsType(BehavioredClassifier).allFeatures()->includesAll(referred())\r\nelse true endif",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 4,
          "TypeExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 2,
          "BooleanLiteralExpImpl": 1
        },
        "properties": ["UML::Behavior::context"]
      }
    ],
    "properties": [
      "postCondition",
      "preCondition",
      "referred"
    ]
  },
  {
    "name": "AddStructuralFeatureValueAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "not": 2,
          "and": 2,
          "oclAsSet": 1,
          "is": 1,
          "implies": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "insertAt_pin",
        "body": "if not structuralFeature.isOrdered then insertAt = null\nelse \n  not isReplaceAll implies\n  \tinsertAt<>null and \n  \tinsertAt->forAll(type=UnlimitedNatural and is(1,1.oclAsType(UnlimitedNatural)))\nendif\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 7,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::AddStructuralFeatureValueAction::insertAt",
          "UML::AddStructuralFeatureValueAction::isReplaceAll",
          "UML::StructuralFeatureAction::structuralFeature"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "required_value",
        "body": "value<>null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::WriteStructuralFeatureAction::value"]
      }
    ],
    "properties": [
      "insertAt",
      "isReplaceAll"
    ]
  },
  {
    "name": "Component",
    "expressions": [
      {
        "operations": {
          "allUsedInterfaces": 2,
          "allParents": 3,
          "union": 6,
          "asSet": 5
        },
        "name": "required",
        "body": "let \tuis : Set(Interface) = allUsedInterfaces(),\r\n        realizingClassifiers : Set(Classifier) = self.realization.realizingClassifier->union(self.allParents()->collect(realization.realizingClassifier))->asSet(),\r\n        allRealizingClassifiers : Set(Classifier) = realizingClassifiers->union(realizingClassifiers.allParents())->asSet(),\r\n        realizingClassifierInterfaces : Set(Interface) = allRealizingClassifiers->iterate(c; rci : Set(Interface) = Set{} | rci->union(c.allUsedInterfaces())),\r\n        ports : Set(Port) = self.ownedPort->union(allParents()->collect(ownedPort))->asSet(),\r\n        usedByPorts : Set(Interface) = ports.required->asSet()\r\nin\t    uis->union(realizingClassifierInterfaces)->union(usedByPorts)->asSet()\r\n",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "OperationCallExpImpl": 16,
          "VariableExpImpl": 20,
          "LetExpImpl": 6,
          "IterateExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::ComponentRealization::realizingClassifier",
          "UML::EncapsulatedClassifier::ownedPort",
          "UML::Component::realization",
          "UML::Port::required"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "isEmpty": 1,
          "implies": 1
        },
        "name": "no_packaged_elements",
        "body": "nestingClass <> null implies packagedElement->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "OppositePropertyCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Component::packagedElement"]
      },
      {
        "operations": {"isEmpty": 1},
        "name": "no_nested_classifiers",
        "body": "nestedClassifier->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Class::nestedClassifier"]
      },
      {
        "operations": {
          "allParents": 3,
          "allRealizedInterfaces": 2,
          "union": 6,
          "asSet": 5
        },
        "name": "provided",
        "body": "let \tris : Set(Interface) = allRealizedInterfaces(),\r\n        realizingClassifiers : Set(Classifier) =  self.realization.realizingClassifier->union(self.allParents()->collect(realization.realizingClassifier))->asSet(),\r\n        allRealizingClassifiers : Set(Classifier) = realizingClassifiers->union(realizingClassifiers.allParents())->asSet(),\r\n        realizingClassifierInterfaces : Set(Interface) = allRealizingClassifiers->iterate(c; rci : Set(Interface) = Set{} | rci->union(c.allRealizedInterfaces())),\r\n        ports : Set(Port) = self.ownedPort->union(allParents()->collect(ownedPort))->asSet(),\r\n        providedByPorts : Set(Interface) = ports.provided->asSet()\r\nin     ris->union(realizingClassifierInterfaces) ->union(providedByPorts)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "VariableExpImpl": 20,
          "OperationCallExpImpl": 16,
          "LetExpImpl": 6,
          "IterateExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::ComponentRealization::realizingClassifier",
          "UML::EncapsulatedClassifier::ownedPort",
          "UML::Port::provided",
          "UML::Component::realization"
        ]
      }
    ],
    "properties": [
      "packagedElement",
      "provided",
      "isIndirectlyInstantiated",
      "realization",
      "required"
    ]
  },
  {
    "name": "ReduceAction",
    "expressions": [
      {
        "operations": {
          "conformsTo": 1,
          "outputParameters": 1
        },
        "name": "output_types_are_compatible",
        "body": "reducer.outputParameters().type->forAll(conformsTo(result.type))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ReduceAction::result",
          "UML::ReduceAction::reducer"
        ]
      },
      {
        "operations": {
          "size": 2,
          "upperBound": 1,
          "and": 3,
          "conformsTo": 2,
          "implies": 1,
          "inputParameters": 1,
          "=": 2,
          ">": 1,
          "outputParameters": 1
        },
        "name": "reducer_inputs_output",
        "body": "let inputs: OrderedSet(Parameter) = reducer.inputParameters() in\r\nlet outputs: OrderedSet(Parameter) = reducer.outputParameters() in\r\ninputs->size()=2 and outputs->size()=1 and\r\ninputs.type->forAll(t | \r\n\toutputs.type->forAll(conformsTo(t)) and \r\n\t-- Note that the following only checks the case when the collection is via multiple tokens.\r\n\tcollection.upperBound()>1 implies collection.type.conformsTo(t))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 14,
          "VariableExpImpl": 13,
          "LetExpImpl": 2,
          "IntegerLiteralExpImpl": 3,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ReduceAction::collection",
          "UML::ReduceAction::reducer"
        ]
      },
      {
        "operations": {},
        "name": "input_type_is_collection",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      }
    ],
    "properties": [
      "isOrdered",
      "result",
      "collection",
      "reducer"
    ]
  },
  {
    "name": "TemplateParameter",
    "expressions": [{
      "operations": {
        "<>": 1,
        "implies": 1,
        "isCompatibleWith": 1
      },
      "name": "must_be_compatible",
      "body": "default <> null implies default.isCompatibleWith(parameteredElement)",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 3,
        "VariableExpImpl": 3,
        "NullLiteralExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::TemplateParameter::parameteredElement",
        "UML::TemplateParameter::default"
      ]
    }],
    "properties": [
      "signature",
      "parameteredElement",
      "templateSignature",
      "templateParameterSubstitution",
      "redefinableTemplateSignature",
      "ownedDefault",
      "default",
      "ownedParameteredElement"
    ]
  },
  {
    "name": "AggregationKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "PartDecomposition",
    "expressions": [
      {
        "operations": {},
        "name": "assume",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {},
        "name": "parts_of_internal_structures",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {},
        "name": "commutativity_of_decomposition",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      }
    ],
    "properties": ["lifeline"]
  },
  {
    "name": "ForkNode",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2,
          "union": 1
        },
        "name": "edges",
        "body": "let allEdges : Set(ActivityEdge) = incoming->union(outgoing) in\r\nallEdges->forAll(oclIsKindOf(ControlFlow)) or allEdges->forAll(oclIsKindOf(ObjectFlow))\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 6,
          "LetExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "one_incoming_edge",
        "body": "incoming->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::incoming"]
      }
    ],
    "properties": []
  },
  {
    "name": "AcceptCallAction",
    "expressions": [
      {
        "operations": {
          "at": 6,
          "compatibleWith": 1,
          "size": 3,
          "and": 3,
          "conformsTo": 1,
          "=": 2,
          "oclAsType": 1,
          "inputParameters": 1,
          "first": 1,
          "asSequence": 1
        },
        "name": "result_pins",
        "body": "let parameter: OrderedSet(Parameter) = trigger.event->asSequence()->first().oclAsType(CallEvent).operation.inputParameters() in\r\nresult->size() = parameter->size() and\r\nSequence{1..result->size()}->forAll(i | \r\n\tparameter->at(i).type.conformsTo(result->at(i).type) and \r\n\tparameter->at(i).isOrdered = result->at(i).isOrdered and\r\n\tparameter->at(i).compatibleWith(result->at(i)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 17,
          "OperationCallExpImpl": 20,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "UML::Trigger::event",
          "UML::MultiplicityElement::isOrdered",
          "UML::AcceptEventAction::result",
          "UML::TypedElement::type",
          "UML::AcceptEventAction::trigger",
          "UML::CallEvent::operation"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "unmarshall",
        "body": "isUnmarshall = true",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1,
          "BooleanLiteralExpImpl": 1
        },
        "properties": ["UML::AcceptEventAction::isUnmarshall"]
      },
      {
        "operations": {
          "size": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "=": 1,
          "first": 1,
          "asSequence": 1
        },
        "name": "trigger_call_event",
        "body": "trigger->size()=1 and\r\ntrigger->asSequence()->first().event.oclIsKindOf(CallEvent)\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 6,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Trigger::event",
          "UML::AcceptEventAction::trigger"
        ]
      }
    ],
    "properties": ["returnInformation"]
  },
  {
    "name": "LiteralBoolean",
    "expressions": [
      {
        "operations": {},
        "name": "booleanValue",
        "body": "value",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::LiteralBoolean::value"]
      },
      {
        "operations": {},
        "name": "isComputable",
        "body": "true",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": ["value"]
  },
  {
    "name": "Slot",
    "expressions": [],
    "properties": [
      "value",
      "definingFeature",
      "owningInstance"
    ]
  },
  {
    "name": "Vertex",
    "expressions": [
      {
        "operations": {
          "allInstances": 1,
          "=": 1
        },
        "name": "outgoing",
        "body": "Transition.allInstances()->select(source=self)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Transition::source"]
      },
      {
        "operations": {
          "isContainedInRegion": 1,
          "isEmpty": 1,
          "oclAsSet": 1,
          "=": 1
        },
        "name": "isContainedInRegion",
        "body": "if (container = r) then\r\n\ttrue\r\nelse\r\n\tif (r.state->isEmpty()) then\r\n\t\tfalse\r\n\telse\r\n\t\tcontainer.state.isContainedInRegion(r)\r\n\tendif\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 4,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 4,
          "BooleanLiteralExpImpl": 2
        },
        "properties": [
          "UML::Region::state",
          "UML::Vertex::container"
        ]
      },
      {
        "operations": {
          "allInstances": 1,
          "=": 1
        },
        "name": "incoming",
        "body": "Transition.allInstances()->select(target=self)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Transition::target"]
      },
      {
        "operations": {
          "not": 1,
          "or": 1,
          "isComposite": 1,
          "isContainedInState": 1,
          "isEmpty": 1,
          "oclAsSet": 1,
          "=": 1
        },
        "name": "isContainedInState",
        "body": "if not s.isComposite() or container->isEmpty() then\r\n\tfalse\r\nelse\r\n\tif container.state = s then \r\n\t\ttrue\r\n\telse\r\n\t\tcontainer.state.isContainedInState(s)\r\n\tendif\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 6,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 5,
          "BooleanLiteralExpImpl": 2
        },
        "properties": [
          "UML::Region::state",
          "UML::Vertex::container"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "or": 1,
          "oclIsKindOf": 2,
          "and": 1,
          "oclAsType": 4,
          "=": 2,
          "containingStateMachine": 2
        },
        "name": "containingStateMachine",
        "body": "if container <> null\nthen\n-- the container is a region\n   container.containingStateMachine()\nelse \n   if (self.oclIsKindOf(Pseudostate)) and ((self.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint) or (self.oclAsType(Pseudostate).kind = PseudostateKind::exitPoint)) then\n      self.oclAsType(Pseudostate).stateMachine\n   else \n      if (self.oclIsKindOf(ConnectionPointReference)) then\n          self.oclAsType(ConnectionPointReference).state.containingStateMachine() -- no other valid cases possible\n      else \n          null\n      endif\n   endif\nendif\n\n",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 8,
          "NullLiteralExpImpl": 2,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 6,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Pseudostate::stateMachine",
          "UML::ConnectionPointReference::state",
          "UML::Vertex::container"
        ]
      }
    ],
    "properties": [
      "outgoing",
      "incoming",
      "container"
    ]
  },
  {
    "name": "State",
    "expressions": [
      {
        "operations": {"containingStateMachine": 1},
        "name": "containingStateMachine",
        "body": "container.containingStateMachine()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Vertex::container"]
      },
      {
        "operations": {
          "and": 1,
          "implies": 1,
          "=": 2
        },
        "name": "destinations_or_sources_of_transitions",
        "body": "self.isSubmachineState implies (self.connection->forAll (cp |\r\n  cp.entry->forAll (ps | ps.stateMachine = self.submachine) and\r\n  cp.exit->forAll (ps | ps.stateMachine = self.submachine)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 8,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::State::connection",
          "UML::Pseudostate::stateMachine",
          "UML::ConnectionPointReference::exit",
          "UML::State::submachine",
          "UML::ConnectionPointReference::entry",
          "UML::State::isSubmachineState"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "isSubmachineState",
        "body": "submachine <> null",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::submachine"]
      },
      {
        "operations": {
          "size": 1,
          ">": 1
        },
        "name": "isOrthogonal",
        "body": "region->size () > 1",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::region"]
      },
      {
        "operations": {
          "not": 1,
          "implies": 1
        },
        "name": "submachine_or_regions",
        "body": "isComposite implies not isSubmachineState",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::State::isComposite",
          "UML::State::isSubmachineState"
        ]
      },
      {
        "operations": {"notEmpty": 1},
        "name": "isComposite",
        "body": "region->notEmpty()",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::region"]
      },
      {
        "operations": {
          "or": 1,
          "=": 2
        },
        "name": "entry_or_exit",
        "body": "connectionPoint->forAll(kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::State::connectionPoint"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "notEmpty": 1
        },
        "name": "composite_states",
        "body": "connectionPoint->notEmpty() implies isComposite",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::State::isComposite",
          "UML::State::connectionPoint"
        ]
      },
      {
        "operations": {
          "not": 1,
          "isSubmachineState": 1,
          "and": 1,
          "isEmpty": 1
        },
        "name": "isSimple",
        "body": "(region->isEmpty()) and not isSubmachineState()",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::region"]
      },
      {
        "operations": {},
        "name": "isConsistentWith",
        "body": "-- the following is merely a default body; it is expected that the specific form of this constraint will be specified by profiles\r\ntrue",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "implies": 1,
          "notEmpty": 1
        },
        "name": "submachine_states",
        "body": "isSubmachineState implies connection->notEmpty( )",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::State::connection",
          "UML::State::isSubmachineState"
        ]
      },
      {
        "operations": {
          "or": 1,
          "notEmpty": 1,
          "=": 1,
          "containingStateMachine": 1
        },
        "name": "redefinitionContext",
        "body": "let sm : StateMachine = containingStateMachine() in\nif sm._'context' = null or sm.general->notEmpty() then\n  sm\nelse\n  sm._'context'\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 4,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Classifier::general",
          "UML::Behavior::context"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "includes": 1,
          "oclAsType": 2
        },
        "name": "isRedefinitionContextValid",
        "body": "if redefinedElement.oclIsKindOf(State) then\r\n  let redefinedState : State = redefinedElement.oclAsType(State) in\r\n    container.redefinedElement.oclAsType(Region)->exists(r:Region |\r\n      r.subvertex->includes(redefinedState))\r\nelse\r\n  false\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 4,
          "LetExpImpl": 1,
          "TypeExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "UML::RedefinableElement::redefinedElement",
          "UML::Region::subvertex",
          "UML::Vertex::container"
        ]
      }
    ],
    "properties": [
      "stateInvariant",
      "state",
      "isSimple",
      "exit",
      "redefinedState",
      "connectionPoint",
      "isComposite",
      "isOrthogonal",
      "region",
      "redefinitionContext",
      "deferrableTrigger",
      "connection",
      "submachine",
      "entry",
      "doActivity",
      "objectNode",
      "isSubmachineState"
    ]
  },
  {
    "name": "Include",
    "expressions": [],
    "properties": [
      "includingCase",
      "addition"
    ]
  },
  {
    "name": "LinkEndCreationData",
    "expressions": [
      {
        "operations": {
          "not": 2,
          "<>": 1,
          "and": 2,
          "oclAsSet": 1,
          "is": 1,
          "toUnlimitedNatural": 1,
          "implies": 1,
          "=": 3
        },
        "name": "insertAt_pin",
        "body": "if  not end.isOrdered\nthen insertAt = null\nelse\n\tnot isReplaceAll=false implies\n\tinsertAt <> null and insertAt->forAll(type=UnlimitedNatural and is(1,1))\nendif\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 7,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 7,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::LinkEndCreationData::isReplaceAll",
          "UML::LinkEndCreationData::insertAt"
        ]
      },
      {
        "operations": {
          "allPins": 1,
          "including": 1
        },
        "name": "allPins",
        "body": "self.LinkEndData::allPins()->including(insertAt)",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::LinkEndCreationData::insertAt"]
      }
    ],
    "properties": [
      "isReplaceAll",
      "createLinkAction",
      "insertAt"
    ]
  },
  {
    "name": "InterfaceRealization",
    "expressions": [],
    "properties": [
      "contract",
      "implementingClassifier"
    ]
  },
  {
    "name": "StringExpression",
    "expressions": [
      {
        "operations": {
          "isEmpty": 1,
          "notEmpty": 2
        },
        "name": "subexpressions",
        "body": "if subExpression->notEmpty() then operand->isEmpty() else operand->notEmpty() endif",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::StringExpression::subExpression",
          "UML::Expression::operand"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "operands",
        "body": "operand->forAll (oclIsKindOf (LiteralString))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Expression::operand"]
      },
      {
        "operations": {
          "stringValue": 2,
          "concat": 2,
          "notEmpty": 1
        },
        "name": "stringValue",
        "body": "if subExpression->notEmpty()\nthen subExpression->iterate(se; stringValue: String = '' | stringValue.concat(se.stringValue()))\nelse operand->iterate(op; stringValue: String = '' | stringValue.concat(op.stringValue()))\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 5,
          "StringLiteralExpImpl": 2,
          "IterateExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::StringExpression::subExpression",
          "UML::Expression::operand"
        ]
      }
    ],
    "properties": [
      "subExpression",
      "owningExpression",
      "namedElement"
    ]
  },
  {
    "name": "Interaction",
    "expressions": [{
      "operations": {
        "isEmpty": 1,
        "oclAsSet": 1
      },
      "name": "not_contained",
      "body": "enclosingInteraction->isEmpty()",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 2,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::InteractionFragment::enclosingInteraction"]
    }],
    "properties": [
      "message",
      "formalGate",
      "lifeline",
      "action",
      "interactionUse",
      "fragment"
    ]
  },
  {
    "name": "Gate",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "asOrderedSet": 1,
          "oclAsSet": 1,
          "notEmpty": 2,
          "implies": 1,
          "oppositeEnd": 2,
          "oclAsType": 2,
          "=": 2,
          "first": 1
        },
        "name": "isInsideCF",
        "body": "self.oppositeEnd()-> notEmpty() and combinedFragment->notEmpty() implies\r\nlet oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in\r\nif oppEnd.oclIsKindOf(MessageOccurrenceSpecification)\r\nthen let oppMOS : MessageOccurrenceSpecification\r\n= oppEnd.oclAsType(MessageOccurrenceSpecification)\r\nin combinedFragment = oppMOS.enclosingOperand.combinedFragment\r\nelse let oppGate : Gate = oppEnd.oclAsType(Gate)\r\nin combinedFragment = oppGate.combinedFragment.enclosingOperand.combinedFragment\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 10,
          "OperationCallExpImpl": 14,
          "LetExpImpl": 3,
          "OppositePropertyCallExpImpl": 6,
          "TypeExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::InteractionFragment::enclosingOperand"]
      },
      {
        "operations": {},
        "name": "isDistinguishableFrom",
        "body": "true",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "isActual",
        "body": "interactionUse->notEmpty()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "OppositePropertyCallExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "enclosingFragment": 1,
          "isOutsideCF": 1,
          "asOrderedSet": 1,
          "includes": 1,
          "matches": 2,
          "size": 2,
          "and": 3,
          "oclAsSet": 1,
          "implies": 1,
          "=": 3,
          "isInsideCF": 2,
          "oppositeEnd": 1,
          "first": 1
        },
        "name": "outside_cf_matched",
        "body": "isOutsideCF() implies\r\n if self.combinedFragment.interactionOperator->asOrderedSet()->first() = InteractionOperatorKind::alt\r\n then self.combinedFragment.operand->forAll(op : InteractionOperand |\r\n self.combinedFragment.cfragmentGate->select(isInsideCF() and \r\n oppositeEnd().enclosingFragment()->includes(self.combinedFragment) and matches(self))->size()=1)\r\n else  self.combinedFragment.cfragmentGate->select(isInsideCF() and matches(self))->size()=1\r\n endif",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 20,
          "VariableExpImpl": 14,
          "OppositePropertyCallExpImpl": 5,
          "IntegerLiteralExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::CombinedFragment::cfragmentGate",
          "UML::CombinedFragment::operand",
          "UML::CombinedFragment::interactionOperator"
        ]
      },
      {
        "operations": {
          "size": 1,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1,
          "matches": 1,
          "=": 1
        },
        "name": "actual_gate_matched",
        "body": "interactionUse->notEmpty() implies interactionUse.refersTo.formalGate->select(matches(self))->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 4,
          "OppositePropertyCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::InteractionUse::refersTo",
          "UML::Interaction::formalGate"
        ]
      },
      {
        "operations": {
          "getName": 2,
          "size": 1,
          "isOutsideCF": 1,
          "implies": 1,
          "=": 2
        },
        "name": "outside_cf_gate_distinguishable",
        "body": "isOutsideCF() implies combinedFragment.cfragmentGate->select(getName() = self.getName())->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 7,
          "OppositePropertyCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CombinedFragment::cfragmentGate"]
      },
      {
        "operations": {
          "getName": 2,
          "and": 5,
          "oclAsSet": 4,
          "includes": 4,
          "implies": 2,
          "=": 4
        },
        "name": "matches",
        "body": "self.getName() = gateToMatch.getName() and \r\nself.message.messageSort = gateToMatch.message.messageSort and\r\nself.message.name = gateToMatch.message.name and\r\nself.message.sendEvent->includes(self) implies gateToMatch.message.receiveEvent->includes(gateToMatch)  and\r\nself.message.receiveEvent->includes(self) implies gateToMatch.message.sendEvent->includes(gateToMatch) and\r\nself.message.signature = gateToMatch.message.signature",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 16,
          "OperationCallExpImpl": 21,
          "PropertyCallExpImpl": 20
        },
        "properties": [
          "UML::Message::receiveEvent",
          "UML::Message::sendEvent",
          "UML::NamedElement::name",
          "UML::Message::messageSort",
          "UML::MessageEnd::message",
          "UML::Message::signature"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "asOrderedSet": 3,
          "oclAsSet": 2,
          "oclAsType": 2,
          "oppositeEnd": 1,
          "isInsideCF": 1,
          "first": 3
        },
        "name": "getOperand",
        "body": "if isInsideCF() then\r\n  let oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in\r\n    if oppEnd.oclIsKindOf(MessageOccurrenceSpecification)\r\n    then let oppMOS : MessageOccurrenceSpecification = oppEnd.oclAsType(MessageOccurrenceSpecification)\r\n        in oppMOS.enclosingOperand->asOrderedSet()->first()\r\n    else let oppGate : Gate = oppEnd.oclAsType(Gate)\r\n        in oppGate.combinedFragment.enclosingOperand->asOrderedSet()->first()\r\n    endif\r\n  else null\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 7,
          "LetExpImpl": 3,
          "OppositePropertyCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 3,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::InteractionFragment::enclosingOperand"]
      },
      {
        "operations": {
          "getName": 2,
          "size": 1,
          "and": 1,
          "getOperand": 2,
          "implies": 1,
          "=": 3,
          "isInsideCF": 2
        },
        "name": "inside_cf_gate_distinguishable",
        "body": "isInsideCF() implies\r\nlet selfOperand : InteractionOperand = self.getOperand() in\r\n  combinedFragment.cfragmentGate->select(isInsideCF() and getName() = self.getName())->select(getOperand() = selfOperand)->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 8,
          "LetExpImpl": 1,
          "OppositePropertyCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CombinedFragment::cfragmentGate"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "asOrderedSet": 1,
          "oclAsSet": 9,
          "union": 4,
          "asSet": 8,
          "implies": 1,
          "notEmpty": 2,
          "oclAsType": 10,
          "oppositeEnd": 2,
          "=": 2,
          "first": 1
        },
        "name": "isOutsideCF",
        "body": "self.oppositeEnd()-> notEmpty() and combinedFragment->notEmpty() implies\r\nlet oppEnd : MessageEnd = self.oppositeEnd()->asOrderedSet()->first() in\r\nif oppEnd.oclIsKindOf(MessageOccurrenceSpecification) \r\nthen let oppMOS : MessageOccurrenceSpecification = oppEnd.oclAsType(MessageOccurrenceSpecification)\r\nin  self.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->\r\n     union(self.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet()) =\r\n     oppMOS.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->\r\n     union(oppMOS.enclosingOperand.oclAsType(InteractionFragment)->asSet())\r\nelse let oppGate : Gate = oppEnd.oclAsType(Gate) \r\nin self.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->\r\n     union(self.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet()) =\r\n     oppGate.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->\r\n     union(oppGate.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet())\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 14,
          "OperationCallExpImpl": 42,
          "LetExpImpl": 3,
          "OppositePropertyCallExpImpl": 7,
          "TypeExpImpl": 11,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::InteractionFragment::enclosingOperand",
          "UML::InteractionFragment::enclosingInteraction"
        ]
      },
      {
        "operations": {
          "size": 1,
          "and": 1,
          "isOutsideCF": 1,
          "implies": 1,
          "matches": 1,
          "=": 1,
          "isInsideCF": 1
        },
        "name": "inside_cf_matched",
        "body": "isInsideCF() implies combinedFragment.cfragmentGate->select(isOutsideCF() and matches(self))->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 5,
          "OppositePropertyCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CombinedFragment::cfragmentGate"]
      },
      {
        "operations": {
          "or": 1,
          "isActual": 1,
          "asOrderedSet": 5,
          "isOutsideCF": 1,
          "oclAsSet": 6,
          "isSend": 2,
          "concat": 4,
          "notEmpty": 1,
          "first": 5
        },
        "name": "getName",
        "body": "if name->notEmpty() then name->asOrderedSet()->first()\r\nelse  if isActual() or isOutsideCF() \r\n  then if isSend() \r\n    then 'out_'.concat(self.message.name->asOrderedSet()->first())\r\n    else 'in_'.concat(self.message.name->asOrderedSet()->first())\r\n    endif\r\n  else if isSend()\r\n    then 'in_'.concat(self.message.name->asOrderedSet()->first())\r\n    else 'out_'.concat(self.message.name->asOrderedSet()->first())\r\n    endif\r\n  endif\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 26,
          "VariableExpImpl": 10,
          "StringLiteralExpImpl": 4,
          "IfExpImpl": 4,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::NamedElement::name",
          "UML::MessageEnd::message"
        ]
      },
      {
        "operations": {
          "getName": 2,
          "size": 1,
          "isActual": 1,
          "implies": 1,
          "=": 2
        },
        "name": "actual_gate_distinguishable",
        "body": "isActual() implies interactionUse.actualGate->select(getName() = self.getName())->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4,
          "OppositePropertyCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InteractionUse::actualGate"]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "isFormal",
        "body": "interaction->notEmpty()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "OppositePropertyCallExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "getName": 2,
          "size": 1,
          "isFormal": 1,
          "implies": 1,
          "=": 2
        },
        "name": "formal_gate_distinguishable",
        "body": "isFormal() implies interaction.formalGate->select(getName() = self.getName())->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 7,
          "OppositePropertyCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Interaction::formalGate"]
      }
    ],
    "properties": [
      "combinedFragment",
      "interactionUse",
      "interaction"
    ]
  },
  {
    "name": "ConnectorKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ClearStructuralFeatureAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "implies": 1,
          "=": 1
        },
        "name": "type_of_result",
        "body": "result<>null implies result.type = object.type",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::StructuralFeatureAction::object",
          "UML::TypedElement::type",
          "UML::ClearStructuralFeatureAction::result"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "toUnlimitedNatural": 1,
          "is": 1,
          "implies": 1
        },
        "name": "multiplicity_of_result",
        "body": "result<>null implies result.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::ClearStructuralFeatureAction::result"]
      }
    ],
    "properties": ["result"]
  },
  {
    "name": "CreateObjectAction",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "oclIsKindOf": 1
        },
        "name": "classifier_not_association_class",
        "body": "not classifier.oclIsKindOf(AssociationClass)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CreateObjectAction::classifier"]
      },
      {
        "operations": {"=": 1},
        "name": "same_type",
        "body": "result.type = classifier",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::CreateObjectAction::classifier",
          "UML::TypedElement::type",
          "UML::CreateObjectAction::result"
        ]
      },
      {
        "operations": {"not": 1},
        "name": "classifier_not_abstract",
        "body": "not classifier.isAbstract ",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::CreateObjectAction::classifier",
          "UML::Classifier::isAbstract"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity",
        "body": "result.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CreateObjectAction::result"]
      }
    ],
    "properties": [
      "classifier",
      "result"
    ]
  },
  {
    "name": "ExecutionEnvironment",
    "expressions": [],
    "properties": []
  },
  {
    "name": "JoinNode",
    "expressions": [
      {
        "operations": {"oclIsKindOf": 3},
        "name": "incoming_object_flow",
        "body": "if incoming->exists(oclIsKindOf(ObjectFlow)) then outgoing->forAll(oclIsKindOf(ObjectFlow))\r\nelse outgoing->forAll(oclIsKindOf(ControlFlow))\r\nendif",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 6,
          "TypeExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "one_outgoing_edge",
        "body": "outgoing->size() = 1",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::outgoing"]
      }
    ],
    "properties": [
      "joinSpec",
      "isCombineDuplicate"
    ]
  },
  {
    "name": "InputPin",
    "expressions": [{
      "operations": {
        "<>": 1,
        "includesAll": 1,
        "oclIsKindOf": 1,
        "and": 2,
        "allOwnedNodes": 1,
        "notEmpty": 1,
        "implies": 1,
        "oclAsType": 1
      },
      "name": "outgoing_edges_structured_only",
      "body": "outgoing->notEmpty() implies\r\n\taction<>null and\r\n\taction.oclIsKindOf(StructuredActivityNode) and\r\n\taction.oclAsType(StructuredActivityNode).allOwnedNodes()->includesAll(outgoing.target)",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 9,
        "VariableExpImpl": 6,
        "OppositePropertyCallExpImpl": 3,
        "NullLiteralExpImpl": 1,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::ActivityEdge::target",
        "UML::ActivityNode::outgoing"
      ]
    }],
    "properties": [
      "reduceAction",
      "addStructuralFeatureValueAction",
      "raiseExceptionAction",
      "testIdentityAction",
      "sendSignalAction",
      "removeStructuralFeatureValueAction",
      "replyAction",
      "writeStructuralFeatureAction",
      "writeVariableAction",
      "removeVariableValueAction",
      "action",
      "unmarshallAction",
      "destroyObjectAction",
      "startObjectBehaviorAction",
      "reclassifyObjectAction",
      "sendObjectAction",
      "testIdentityAction",
      "replyAction",
      "structuredActivityNode",
      "linkEndCreationData",
      "callOperationAction",
      "loopNode",
      "linkAction",
      "qualifierValue",
      "addVariableValueAction",
      "readLinkObjectEndAction",
      "readIsClassifiedObjectAction",
      "opaqueAction",
      "sendObjectAction",
      "linkEndDestructionData",
      "startClassifierBehaviorAction",
      "clearAssociationAction",
      "structuralFeatureAction",
      "linkEndData",
      "invocationAction",
      "readLinkObjectEndQualifierAction"
    ]
  },
  {
    "name": "EncapsulatedClassifier",
    "expressions": [{
      "operations": {
        "oclIsKindOf": 1,
        "asOrderedSet": 1,
        "oclAsType": 1
      },
      "name": "ownedPort",
      "body": "ownedAttribute->select(oclIsKindOf(Port))->collect(oclAsType(Port))->asOrderedSet()",
      "type": "OperationImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "OperationCallExpImpl": 3,
        "VariableExpImpl": 3,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::StructuredClassifier::ownedAttribute"]
    }],
    "properties": ["ownedPort"]
  },
  {
    "name": "Port",
    "expressions": [
      {
        "operations": {
          "basicProvided": 1,
          "basicRequired": 1
        },
        "name": "provided",
        "body": "if isConjugated then basicRequired() else basicProvided() endif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Port::isConjugated"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsSet": 1,
          "allRealizedInterfaces": 1,
          "asSet": 1,
          "oclAsType": 2
        },
        "name": "basicProvided",
        "body": "if type.oclIsKindOf(Interface) \r\nthen type.oclAsType(Interface)->asSet() \r\nelse type.oclAsType(Classifier).allRealizedInterfaces() \r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "TypeExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": ["UML::TypedElement::type"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsSet": 1,
          "isEmpty": 1,
          "implies": 1
        },
        "name": "default_value",
        "body": "type.oclIsKindOf(Interface) implies defaultValue->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Property::defaultValue"
        ]
      },
      {
        "operations": {
          "basicProvided": 1,
          "basicRequired": 1
        },
        "name": "required",
        "body": "if isConjugated then basicProvided() else basicRequired() endif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Port::isConjugated"]
      },
      {
        "operations": {"=": 1},
        "name": "port_aggregation",
        "body": "aggregation = AggregationKind::composite",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Property::aggregation"]
      },
      {
        "operations": {"=": 1},
        "name": "encapsulated_owner",
        "body": "owner = encapsulatedClassifier",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "OppositePropertyCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Element::owner"]
      },
      {
        "operations": {
          "allUsedInterfaces": 1,
          "oclAsType": 1
        },
        "name": "basicRequired",
        "body": " type.oclAsType(Classifier).allUsedInterfaces() ",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::TypedElement::type"]
      }
    ],
    "properties": [
      "encapsulatedClassifier",
      "trigger",
      "protocol",
      "invocationAction",
      "isService",
      "redefinedPort",
      "isConjugated",
      "port",
      "provided",
      "isBehavior",
      "required"
    ]
  },
  {
    "name": "UnmarshallAction",
    "expressions": [
      {
        "operations": {
          "at": 6,
          "size": 1,
          "compatibleWith": 1,
          "and": 2,
          "allAttributes": 1,
          "conformsTo": 1,
          "=": 1
        },
        "name": "type_ordering_and_multiplicity",
        "body": "let attribute:OrderedSet(Property) = unmarshallType.allAttributes() in\r\nSequence{1..result->size()}->forAll(i | \r\n\tattribute->at(i).type.conformsTo(result->at(i).type) and\r\n\tattribute->at(i).isOrdered=result->at(i).isOrdered and\r\n\tattribute->at(i).compatibleWith(result->at(i)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 14,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::UnmarshallAction::unmarshallType",
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::UnmarshallAction::result"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity_of_object",
        "body": "object.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::UnmarshallAction::object"]
      },
      {
        "operations": {"conformsTo": 1},
        "name": "object_type",
        "body": "object.type.conformsTo(unmarshallType)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::UnmarshallAction::unmarshallType",
          "UML::TypedElement::type",
          "UML::UnmarshallAction::object"
        ]
      },
      {
        "operations": {
          "size": 1,
          "allAttributes": 1,
          ">=": 1
        },
        "name": "structural_feature",
        "body": "unmarshallType.allAttributes()->size() >= 1",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::UnmarshallAction::unmarshallType"]
      },
      {
        "operations": {
          "size": 2,
          "allAttributes": 1,
          "=": 1
        },
        "name": "number_of_result",
        "body": "unmarshallType.allAttributes()->size() = result->size()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::UnmarshallAction::unmarshallType",
          "UML::UnmarshallAction::result"
        ]
      }
    ],
    "properties": [
      "unmarshallType",
      "result",
      "object"
    ]
  },
  {
    "name": "Model",
    "expressions": [],
    "properties": ["viewpoint"]
  },
  {
    "name": "DestructionOccurrenceSpecification",
    "expressions": [{
      "operations": {
        "last": 1,
        "and": 1,
        "oclAsSet": 1,
        "notEmpty": 1,
        "=": 2
      },
      "name": "no_occurrence_specifications_below",
      "body": "let o : InteractionOperand = enclosingOperand in o->notEmpty() and \r\nlet peerEvents : OrderedSet(OccurrenceSpecification) = covered.events->select(enclosingOperand = o)\r\nin peerEvents->last() = self",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 7,
        "OperationCallExpImpl": 6,
        "LetExpImpl": 2,
        "OppositePropertyCallExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::InteractionFragment::enclosingOperand",
        "UML::OccurrenceSpecification::covered"
      ]
    }],
    "properties": []
  },
  {
    "name": "ReadLinkAction",
    "expressions": [
      {
        "operations": {
          "openEnd": 1,
          "and": 1,
          "=": 2
        },
        "name": "type_and_ordering",
        "body": "self.openEnd()->forAll(type=result.type and isOrdered=result.isOrdered)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 4,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::ReadLinkAction::result",
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "compatibleWith": 1,
          "openEnd": 1,
          "first": 1
        },
        "name": "compatible_multiplicity",
        "body": "self.openEnd()->first().compatibleWith(result)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkAction::result"]
      },
      {
        "operations": {
          "<>": 1,
          "or": 2,
          "openEnd": 1,
          "and": 2,
          "conformsTo": 1,
          "oclAsType": 1,
          "=": 3,
          "first": 1
        },
        "name": "visibility",
        "body": "let openEnd : Property = self.openEnd()->first() in\n  openEnd.visibility = VisibilityKind::public or \n  endData->exists(oed | \n    oed.end<>openEnd and \n    (_'context' = oed.end.type or \n      (openEnd.visibility = VisibilityKind::protected and \n        _'context'.conformsTo(oed.end.type.oclAsType(Classifier)))))\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 10,
          "LetExpImpl": 1,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::Action::context",
          "UML::LinkEndData::end",
          "UML::TypedElement::type",
          "UML::NamedElement::visibility",
          "UML::LinkAction::endData"
        ]
      },
      {
        "operations": {
          "asOrderedSet": 1,
          "=": 1
        },
        "name": "openEnd",
        "body": "endData->select(value=null).end->asOrderedSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::LinkEndData::value",
          "UML::LinkAction::endData"
        ]
      },
      {
        "operations": {
          "size": 1,
          "openEnd": 1,
          "=": 1
        },
        "name": "one_open_end",
        "body": "self.openEnd()->size() = 1",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "openEnd": 1,
          "isNavigable": 1,
          "first": 1
        },
        "name": "navigable_open_end",
        "body": "self.openEnd()->first().isNavigable()\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 1
        },
        "properties": []
      }
    ],
    "properties": ["result"]
  },
  {
    "name": "Namespace",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "isDistinguishableFrom": 1
        },
        "name": "excludeCollisions",
        "body": "imps->reject(imp1  | imps->exists(imp2 | not imp1.isDistinguishableFrom(imp2, self)))",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {
          "isDistinguishableFrom": 1,
          "excluding": 1
        },
        "name": "membersAreDistinguishable",
        "body": "member->forAll( memb |\n   member->excluding(memb)->forAll(other |\n       memb.isDistinguishableFrom(other, self)))",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Namespace::member"]
      },
      {
        "operations": {"membersAreDistinguishable": 1},
        "name": "members_distinguishable",
        "body": "membersAreDistinguishable()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "excludesAll": 1,
          "oclAsType": 1
        },
        "name": "cannot_import_ownedMembers",
        "body": "elementImport.importedElement.oclAsType(Element)->excludesAll(ownedMember)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ElementImport::importedElement",
          "UML::Namespace::ownedMember",
          "UML::Namespace::elementImport"
        ]
      },
      {
        "operations": {
          "getNamesOfMember": 1,
          "getName": 1,
          "includes": 2,
          "visibleMembers": 1,
          "notEmpty": 1,
          "asSet": 2,
          "oclAsType": 1,
          "=": 1
        },
        "name": "getNamesOfMember",
        "body": "if self.ownedMember ->includes(element)\nthen Set{element.name}\nelse let elementImports : Set(ElementImport) = self.elementImport->select(ei | ei.importedElement = element) in\n  if elementImports->notEmpty()\n  then\n     elementImports->collect(el | el.getName())->asSet()\n  else \n     self.packageImport->select(pi | pi.importedPackage.visibleMembers().oclAsType(NamedElement)->includes(element))-> collect(pi | pi.importedPackage.getNamesOfMember(element))->asSet()\n  endif\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 5,
          "VariableExpImpl": 15,
          "OperationCallExpImpl": 10,
          "LetExpImpl": 1,
          "TypeExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::PackageImport::importedPackage",
          "UML::ElementImport::importedElement",
          "UML::Namespace::packageImport",
          "UML::NamedElement::name",
          "UML::Namespace::ownedMember",
          "UML::Namespace::elementImport"
        ]
      },
      {
        "operations": {
          "excludes": 1,
          "oclAsType": 1
        },
        "name": "cannot_import_self",
        "body": "packageImport.importedPackage.oclAsType(Namespace)->excludes(self)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::PackageImport::importedPackage",
          "UML::Namespace::packageImport"
        ]
      },
      {
        "operations": {
          "importMembers": 1,
          "visibleMembers": 1,
          "union": 1,
          "asSet": 2
        },
        "name": "importedMember",
        "body": "self.importMembers(elementImport.importedElement->asSet()->union(packageImport.importedPackage->collect(p | p.visibleMembers()))->asSet())",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 6,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::PackageImport::importedPackage",
          "UML::ElementImport::importedElement",
          "UML::Namespace::packageImport",
          "UML::Namespace::elementImport"
        ]
      },
      {
        "operations": {
          "excludeCollisions": 1,
          "isDistinguishableFrom": 1
        },
        "name": "importMembers",
        "body": "self.excludeCollisions(imps)->select(imp | self.ownedMember->forAll(mem | imp.isDistinguishableFrom(mem, self)))",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 6,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Namespace::ownedMember"]
      }
    ],
    "properties": [
      "packageImport",
      "ownedMember",
      "ownedRule",
      "importedMember",
      "elementImport",
      "member"
    ]
  },
  {
    "name": "ClassifierTemplateParameter",
    "expressions": [
      {
        "operations": {
          "and": 1,
          "allParents": 1,
          "isEmpty": 3,
          "implies": 1
        },
        "name": "parametered_element_no_features",
        "body": "parameteredElement.feature->isEmpty() and (constrainingClassifier->isEmpty() implies  parameteredElement.allParents()->isEmpty())",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Classifier::feature",
          "UML::ClassifierTemplateParameter::constrainingClassifier",
          "UML::ClassifierTemplateParameter::parameteredElement"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "actual_is_classifier",
        "body": " templateParameterSubstitution.actual->forAll(a | a.oclIsKindOf(Classifier))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::TemplateParameterSubstitution::actual"]
      },
      {
        "operations": {
          "or": 2,
          "and": 1,
          "isSubstitutableFor": 1,
          "conformsTo": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "constraining_classifiers_constrain_args",
        "body": "templateParameterSubstitution.actual->forAll( a |\r\n  let arg : Classifier = a.oclAsType(Classifier) in\r\n    constrainingClassifier->forAll(\r\n      cc |  \r\n         arg = cc or arg.conformsTo(cc) or (allowSubstitutable and arg.isSubstitutableFor(cc))\r\n      )\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 11,
          "OperationCallExpImpl": 7,
          "LetExpImpl": 1,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::TemplateParameterSubstitution::actual",
          "UML::ClassifierTemplateParameter::allowSubstitutable",
          "UML::ClassifierTemplateParameter::constrainingClassifier"
        ]
      },
      {
        "operations": {
          "notEmpty": 1,
          "implies": 1
        },
        "name": "has_constraining_classifier",
        "body": "allowSubstitutable implies constrainingClassifier->notEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ClassifierTemplateParameter::allowSubstitutable",
          "UML::ClassifierTemplateParameter::constrainingClassifier"
        ]
      },
      {
        "operations": {
          "not": 2,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "matching_abstract",
        "body": "(not parameteredElement.isAbstract) implies templateParameterSubstitution.actual->forAll(a | not a.oclAsType(Classifier).isAbstract)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 4,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TemplateParameterSubstitution::actual",
          "UML::Classifier::isAbstract",
          "UML::ClassifierTemplateParameter::parameteredElement"
        ]
      },
      {
        "operations": {
          "or": 2,
          "and": 1,
          "isSubstitutableFor": 1,
          "conformsTo": 1,
          "=": 1
        },
        "name": "constraining_classifiers_constrain_parametered_element",
        "body": "constrainingClassifier->forAll(\r\n     cc |  parameteredElement = cc or parameteredElement.conformsTo(cc) or (allowSubstitutable and parameteredElement.isSubstitutableFor(cc))\r\n)\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 8,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ClassifierTemplateParameter::allowSubstitutable",
          "UML::ClassifierTemplateParameter::constrainingClassifier",
          "UML::ClassifierTemplateParameter::parameteredElement"
        ]
      }
    ],
    "properties": [
      "allowSubstitutable",
      "constrainingClassifier",
      "parameteredElement"
    ]
  },
  {
    "name": "ExpansionNode",
    "expressions": [{
      "operations": {
        "oclAsSet": 2,
        "xor": 1,
        "notEmpty": 2
      },
      "name": "region_as_input_or_output",
      "body": "regionAsInput->notEmpty() xor regionAsOutput->notEmpty()",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 5,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::ExpansionNode::regionAsInput",
        "UML::ExpansionNode::regionAsOutput"
      ]
    }],
    "properties": [
      "regionAsInput",
      "regionAsOutput"
    ]
  },
  {
    "name": "MultiplicityElement",
    "expressions": [
      {
        "operations": {
          "<=": 2,
          "or": 1,
          "upperBound": 3,
          "and": 1,
          "lowerBound": 2,
          "=": 1
        },
        "name": "compatibleWith",
        "body": "(other.lowerBound() <= self.lowerBound()) and ((other.upperBound() = *) or (self.upperBound() <= other.upperBound()))",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 10,
          "UnlimitedNaturalLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "lowerBound": 1,
          ">=": 1
        },
        "name": "lower_ge_0",
        "body": "lowerBound() >= 0",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "<>": 2,
          "unlimitedValue": 1,
          "implies": 1
        },
        "name": "upper_is_unlimitedNatural",
        "body": "upperValue <> null implies upperValue.unlimitedValue() <> null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::MultiplicityElement::upperValue"]
      },
      {
        "operations": {},
        "name": "value_specification_no_side_effects",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {},
        "name": "value_specification_constant",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "or": 1,
          "unlimitedValue": 2,
          "=": 2
        },
        "name": "upperBound",
        "body": "if (upperValue=null or upperValue.unlimitedValue()=null) then 1 else upperValue.unlimitedValue() endif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": ["UML::MultiplicityElement::upperValue"]
      },
      {
        "operations": {
          "<>": 2,
          "integerValue": 1,
          "implies": 1
        },
        "name": "lower_is_integer",
        "body": "lowerValue <> null implies lowerValue.integerValue() <> null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::MultiplicityElement::lowerValue"]
      },
      {
        "operations": {"upperBound": 1},
        "name": "upper",
        "body": "upperBound()",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "<=": 1,
          "upperBound": 2,
          "and": 1,
          "lowerBound": 2,
          ">=": 1
        },
        "name": "includesMultiplicity",
        "body": "(self.lowerBound() <= M.lowerBound()) and (self.upperBound() >= M.upperBound())",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4
        },
        "properties": []
      },
      {
        "operations": {
          "upperBound": 1,
          "lowerBound": 1,
          ">=": 1
        },
        "name": "upper_ge_lower",
        "body": "upperBound() >= lowerBound()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {"lowerBound": 1},
        "name": "lower",
        "body": "lowerBound()",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "or": 1,
          "integerValue": 2,
          "=": 2
        },
        "name": "lowerBound",
        "body": "if (lowerValue=null or lowerValue.integerValue()=null) then 1 else lowerValue.integerValue() endif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": ["UML::MultiplicityElement::lowerValue"]
      },
      {
        "operations": {
          "upperBound": 1,
          "and": 1,
          "lowerBound": 1,
          "=": 2
        },
        "name": "is",
        "body": "lowerbound = self.lowerBound() and upperbound = self.upperBound()",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5
        },
        "properties": []
      },
      {
        "operations": {
          "upperBound": 1,
          ">": 1
        },
        "name": "isMultivalued",
        "body": "upperBound() > 1",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1
        },
        "properties": []
      }
    ],
    "properties": [
      "lowerValue",
      "isOrdered",
      "lower",
      "upper",
      "isUnique",
      "upperValue"
    ]
  },
  {
    "name": "DurationObservation",
    "expressions": [{
      "operations": {
        "size": 3,
        "=": 3
      },
      "name": "first_event_multiplicity",
      "body": "if (event->size() = 2)\r\n  then (firstEvent->size() = 2) else (firstEvent->size() = 0)\r\nendif",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 3,
        "IntegerLiteralExpImpl": 3,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::DurationObservation::event",
        "UML::DurationObservation::firstEvent"
      ]
    }],
    "properties": [
      "event",
      "firstEvent"
    ]
  },
  {
    "name": "UnlimitedNaturalObject",
    "expressions": [],
    "properties": []
  },
  {
    "name": "UseCase",
    "expressions": [
      {
        "operations": {
          "size": 2,
          "oclIsKindOf": 1,
          "allInstances": 1,
          "includes": 1,
          "asSet": 1,
          "implies": 2,
          "oclAsType": 1,
          ">": 2
        },
        "name": "no_association_to_use_case",
        "body": "Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies \r\n   (\r\n   let usecases: Set(UseCase) = a.memberEnd.type->select(oclIsKindOf(UseCase))->collect(oclAsType(UseCase))->asSet() in\r\n   usecases->size() > 1 implies usecases->collect(subject)->size() > 1\r\n   )\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "VariableExpImpl": 10,
          "OperationCallExpImpl": 11,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Association::memberEnd",
          "UML::UseCase::subject"
        ]
      },
      {
        "operations": {
          "allIncludedUseCases": 1,
          "union": 1,
          "asSet": 1
        },
        "name": "allIncludedUseCases",
        "body": "self.include.addition->union(self.include.addition->collect(uc | uc.allIncludedUseCases()))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 5,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Include::addition",
          "UML::UseCase::include"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "must_have_name",
        "body": "name -> notEmpty ()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::NamedElement::name"]
      },
      {
        "operations": {
          "size": 1,
          "allInstances": 1,
          "includes": 1,
          "implies": 1,
          "=": 1
        },
        "name": "binary_associations",
        "body": "Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies a.memberEnd->size() = 2)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Association::memberEnd"
        ]
      },
      {
        "operations": {
          "not": 1,
          "allIncludedUseCases": 1,
          "includes": 1
        },
        "name": "cannot_include_self",
        "body": "not allIncludedUseCases()->includes(self)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3
        },
        "properties": []
      }
    ],
    "properties": [
      "extensionPoint",
      "extend",
      "subject",
      "include",
      "classifier",
      "extend",
      "include"
    ]
  },
  {
    "name": "Message",
    "expressions": [
      {
        "operations": {
          "or": 2,
          "oclIsKindOf": 2,
          "isEmpty": 1,
          "oclAsType": 5,
          "not": 1,
          "at": 1,
          "size": 3,
          "and": 4,
          "oclAsSet": 1,
          "conformsTo": 1,
          "implies": 2,
          "=": 6,
          "indexOf": 1
        },
        "name": "signature_is_operation_request",
        "body": "(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall) and signature.oclIsKindOf(Operation)  implies \r\n let requestParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->\r\n select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::_'in'  )\r\nin requestParms->size() = self.argument->size() and\r\nself.argument->forAll( o: ValueSpecification | \r\nnot (o.oclIsKindOf(Expression) and o.oclAsType(Expression).symbol->size()=0 and o.oclAsType(Expression).operand->isEmpty() ) implies \r\nlet p : Parameter = requestParms->at(self.argument->indexOf(o)) in\r\no.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 30,
          "VariableExpImpl": 17,
          "LetExpImpl": 2,
          "EnumLiteralExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 7,
          "PropertyCallExpImpl": 14
        },
        "properties": [
          "UML::Message::argument",
          "UML::Expression::symbol",
          "UML::TypedElement::type",
          "UML::Message::messageSort",
          "UML::Message::signature",
          "UML::Operation::ownedParameter",
          "UML::Parameter::direction",
          "UML::Expression::operand"
        ]
      },
      {
        "operations": {},
        "name": "occurrence_specifications",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "asOrderedSet": 1,
          "isEmpty": 1,
          "oclAsType": 6,
          "not": 1,
          "at": 1,
          "size": 3,
          "oclIsTypeOf": 1,
          "and": 4,
          "inheritedMember": 1,
          "oclAsSet": 1,
          "conformsTo": 1,
          "implies": 2,
          "indexOf": 1,
          "=": 3
        },
        "name": "signature_is_signal",
        "body": "(messageSort = MessageSort::asynchSignal ) and signature.oclIsKindOf(Signal) implies\r\n   let signalAttributes : OrderedSet(Property) = signature.oclAsType(Signal).inheritedMember()->\r\n             select(n:NamedElement | n.oclIsTypeOf(Property))->collect(oclAsType(Property))->asOrderedSet()\r\n   in signalAttributes->size() = self.argument->size()\r\n   and self.argument->forAll( o: ValueSpecification |\r\n          not (o.oclIsKindOf(Expression)\r\n          and o.oclAsType(Expression).symbol->size()=0\r\n          and o.oclAsType(Expression).operand->isEmpty() ) implies\r\n              let p : Property = signalAttributes->at(self.argument->indexOf(o))\r\n              in o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier)))\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 29,
          "VariableExpImpl": 16,
          "LetExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 9,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::Message::argument",
          "UML::Expression::symbol",
          "UML::TypedElement::type",
          "UML::Message::messageSort",
          "UML::Message::signature",
          "UML::Expression::operand"
        ]
      },
      {
        "operations": {},
        "name": "arguments",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "or": 3,
          "oclIsKindOf": 2,
          "and": 3,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 5
        },
        "name": "signature_refer_to",
        "body": "signature->notEmpty() implies \r\n((signature.oclIsKindOf(Operation) and \r\n(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall or messageSort = MessageSort::reply) \r\n) or (signature.oclIsKindOf(Signal)  and messageSort = MessageSort::asynchSignal )\r\n ) and name = signature.name",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 16,
          "VariableExpImpl": 9,
          "EnumLiteralExpImpl": 4,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::NamedElement::name",
          "UML::Message::messageSort",
          "UML::Message::signature"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 3,
          "asOrderedSet": 4,
          "oclAsSet": 4,
          "implies": 2,
          "<": 1,
          "indexOf": 2,
          "oclAsType": 4,
          "=": 1,
          "first": 4
        },
        "name": "sending_receiving_message_event",
        "body": "receiveEvent.oclIsKindOf(MessageOccurrenceSpecification)\r\nimplies\r\nlet f :  Lifeline = sendEvent->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first().covered in\r\nf = receiveEvent->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first().covered  implies\r\nf.events->indexOf(sendEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() ) < \r\nf.events->indexOf(receiveEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() )",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 12,
          "OperationCallExpImpl": 25,
          "LetExpImpl": 1,
          "OppositePropertyCallExpImpl": 2,
          "TypeExpImpl": 7,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::Message::receiveEvent",
          "UML::Message::sendEvent",
          "UML::OccurrenceSpecification::covered"
        ]
      },
      {
        "operations": {},
        "name": "messageKind",
        "body": "messageKind",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Message::messageKind"]
      },
      {
        "operations": {
          "enclosingFragment": 2,
          "and": 1,
          "asOrderedSet": 2,
          "oclAsSet": 4,
          "notEmpty": 2,
          "implies": 1,
          "=": 1,
          "first": 2
        },
        "name": "cannot_cross_boundaries",
        "body": "sendEvent->notEmpty() and receiveEvent->notEmpty() implies\r\nlet sendEnclosingFrag : Set(InteractionFragment) = \r\nsendEvent->asOrderedSet()->first().enclosingFragment()\r\nin \r\nlet receiveEnclosingFrag : Set(InteractionFragment) = \r\nreceiveEvent->asOrderedSet()->first().enclosingFragment()\r\nin  sendEnclosingFrag = receiveEnclosingFrag",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 15,
          "VariableExpImpl": 6,
          "LetExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Message::receiveEvent",
          "UML::Message::sendEvent"
        ]
      },
      {
        "operations": {},
        "name": "isDistinguishableFrom",
        "body": "true",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "or": 2,
          "oclIsKindOf": 2,
          "oclAsType": 4,
          "asSequence": 1,
          "at": 1,
          "size": 2,
          "and": 3,
          "conformsTo": 1,
          "implies": 2,
          "notEmpty": 1,
          "=": 5,
          "indexOf": 1,
          "first": 1
        },
        "name": "signature_is_operation_reply",
        "body": "(messageSort = MessageSort::reply) and signature.oclIsKindOf(Operation) implies \r\n let replyParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter->\r\nselect(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::return)\r\nin replyParms->size() = self.argument->size() and\r\nself.argument->forAll( o: ValueSpecification | o.oclIsKindOf(Expression) and let e : Expression = o.oclAsType(Expression) in\r\ne.operand->notEmpty()  implies \r\nlet p : Parameter = replyParms->at(self.argument->indexOf(o)) in\r\ne.operand->asSequence()->first().type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier))\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 26,
          "VariableExpImpl": 17,
          "LetExpImpl": 3,
          "EnumLiteralExpImpl": 4,
          "TypeExpImpl": 6,
          "PropertyCallExpImpl": 14
        },
        "properties": [
          "UML::Message::argument",
          "UML::TypedElement::type",
          "UML::Message::messageSort",
          "UML::Message::signature",
          "UML::Operation::ownedParameter",
          "UML::Parameter::direction",
          "UML::Expression::operand"
        ]
      }
    ],
    "properties": [
      "messageKind",
      "receiveEvent",
      "argument",
      "sendEvent",
      "messageSort",
      "informationFlow",
      "messageEnd",
      "connector",
      "signature",
      "interaction"
    ]
  },
  {
    "name": "ConnectorEnd",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "oclIsKindOf": 1,
          "oclAsSet": 1,
          "notEmpty": 1,
          "implies": 1
        },
        "name": "self_part_with_port",
        "body": "partWithPort->notEmpty() implies not partWithPort.oclIsKindOf(Port)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::ConnectorEnd::partWithPort"]
      },
      {
        "operations": {"compatibleWith": 1},
        "name": "multiplicity",
        "body": "self.compatibleWith(definingEnd)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ConnectorEnd::definingEnd"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "isEmpty": 1,
          "oclAsSet": 1,
          "implies": 1,
          "=": 1
        },
        "name": "part_with_port_empty",
        "body": "(role.oclIsKindOf(Port) and role.owner = connector.owner) implies partWithPort->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 6,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ConnectorEnd::role",
          "UML::ConnectorEnd::partWithPort",
          "UML::Element::owner"
        ]
      },
      {
        "operations": {
          "at": 1,
          "indexOf": 1,
          "=": 1
        },
        "name": "definingEnd",
        "body": "if connector.type = null \r\nthen\r\n  null \r\nelse\r\n  let index : Integer = connector.end->indexOf(self) in\r\n    connector.type.memberEnd->at(index)\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "LetExpImpl": 1,
          "OppositePropertyCallExpImpl": 3,
          "NullLiteralExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Connector::end",
          "UML::Association::memberEnd",
          "UML::Connector::type"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "includes": 1,
          "notEmpty": 1,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "role_and_part_with_port",
        "body": "partWithPort->notEmpty() implies \r\n  (role.oclIsKindOf(Port) and partWithPort.type.oclAsType(Namespace).member->includes(role))",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ConnectorEnd::role",
          "UML::ConnectorEnd::partWithPort",
          "UML::Namespace::member"
        ]
      }
    ],
    "properties": [
      "connector",
      "definingEnd",
      "role",
      "partWithPort"
    ]
  },
  {
    "name": "ConsiderIgnoreFragment",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2
        },
        "name": "type",
        "body": "message->forAll(m | m.oclIsKindOf(Operation) or m.oclIsKindOf(Signal))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ConsiderIgnoreFragment::message"]
      },
      {
        "operations": {
          "or": 1,
          "=": 2
        },
        "name": "consider_or_ignore",
        "body": "(interactionOperator =  InteractionOperatorKind::consider) or (interactionOperator =  InteractionOperatorKind::ignore)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::CombinedFragment::interactionOperator"]
      }
    ],
    "properties": ["message"]
  },
  {
    "name": "SequenceNode",
    "expressions": [],
    "properties": ["executableNode"]
  },
  {
    "name": "Connector",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "or": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "allRoles": 2,
          "includes": 2
        },
        "name": "roles",
        "body": "structuredClassifier <> null\r\nand\r\n  end->forAll( e | structuredClassifier.allRoles()->includes(e.role)\r\nor\r\n  e.role.oclIsKindOf(Port) and structuredClassifier.allRoles()->includes(e.partWithPort))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 9,
          "OppositePropertyCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Connector::end",
          "UML::ConnectorEnd::role",
          "UML::ConnectorEnd::partWithPort"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "oclAsSet": 1,
          "isEmpty": 1,
          "oclAsType": 1
        },
        "name": "kind",
        "body": "if end->exists(\r\n\t\trole.oclIsKindOf(Port) \r\n\t\tand partWithPort->isEmpty()\r\n\t\tand not role.oclAsType(Port).isBehavior)\r\nthen ConnectorKind::delegation \r\nelse ConnectorKind::assembly \r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 7,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Connector::end",
          "UML::ConnectorEnd::role",
          "UML::ConnectorEnd::partWithPort",
          "UML::Port::isBehavior"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "at": 2,
          "size": 2,
          "and": 1,
          "conformsTo": 1,
          "implies": 1,
          "=": 1
        },
        "name": "types",
        "body": "type<>null implies \r\n  let noOfEnds : Integer = end->size() in \r\n  (type.memberEnd->size() = noOfEnds) and Sequence{1..noOfEnds}->forAll(i | end->at(i).role.type.conformsTo(type.memberEnd->at(i).type))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 9,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Connector::end",
          "UML::Association::memberEnd",
          "UML::ConnectorEnd::role",
          "UML::Connector::type"
        ]
      }
    ],
    "properties": [
      "redefinedConnector",
      "message",
      "end",
      "kind",
      "structuredClassifier",
      "informationFlow",
      "connector",
      "type",
      "contract"
    ]
  },
  {
    "name": "IntervalConstraint",
    "expressions": [],
    "properties": ["specification"]
  },
  {
    "name": "QualifierValue",
    "expressions": [
      {
        "operations": {"includes": 1},
        "name": "qualifier_attribute",
        "body": "linkEndData.end.qualifier->includes(qualifier)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "OppositePropertyCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::QualifierValue::qualifier",
          "UML::Property::qualifier"
        ]
      },
      {
        "operations": {"conformsTo": 1},
        "name": "type_of_qualifier",
        "body": "value.type.conformsTo(qualifier.type)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::QualifierValue::value",
          "UML::TypedElement::type",
          "UML::QualifierValue::qualifier"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity_of_qualifier",
        "body": "value.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::QualifierValue::value"]
      }
    ],
    "properties": [
      "value",
      "qualifier",
      "linkEndData"
    ]
  },
  {
    "name": "ReadLinkObjectEndQualifierAction",
    "expressions": [
      {
        "operations": {"not": 1},
        "name": "ends_of_association",
        "body": "qualifier.associationEnd.association.memberEnd->forAll(e | not e.isStatic)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Property::associationEnd",
          "UML::Association::memberEnd",
          "UML::Feature::isStatic",
          "UML::ReadLinkObjectEndQualifierAction::qualifier",
          "UML::Property::association"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "association_of_association",
        "body": "qualifier.associationEnd.association.oclIsKindOf(AssociationClass)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Property::associationEnd",
          "UML::ReadLinkObjectEndQualifierAction::qualifier",
          "UML::Property::association"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "same_type",
        "body": "result.type = qualifier.type",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ReadLinkObjectEndQualifierAction::result",
          "UML::TypedElement::type",
          "UML::ReadLinkObjectEndQualifierAction::qualifier"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity_of_object",
        "body": "object.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkObjectEndQualifierAction::object"]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity_of_qualifier",
        "body": "qualifier.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkObjectEndQualifierAction::qualifier"]
      },
      {
        "operations": {"=": 1},
        "name": "type_of_object",
        "body": "object.type = qualifier.associationEnd.association",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Property::associationEnd",
          "UML::TypedElement::type",
          "UML::ReadLinkObjectEndQualifierAction::object",
          "UML::Property::association",
          "UML::ReadLinkObjectEndQualifierAction::qualifier"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity_of_result",
        "body": "result.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkObjectEndQualifierAction::result"]
      },
      {
        "operations": {"<>": 1},
        "name": "qualifier_attribute",
        "body": "qualifier.associationEnd <> null",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Property::associationEnd",
          "UML::ReadLinkObjectEndQualifierAction::qualifier"
        ]
      }
    ],
    "properties": [
      "result",
      "object",
      "qualifier"
    ]
  },
  {
    "name": "Interval",
    "expressions": [],
    "properties": [
      "max",
      "intervalConstraint",
      "min"
    ]
  },
  {
    "name": "ProtocolConformance",
    "expressions": [],
    "properties": [
      "specificMachine",
      "generalMachine"
    ]
  },
  {
    "name": "CombinedFragment",
    "expressions": [
      {
        "operations": {
          "or": 4,
          "size": 1,
          "implies": 1,
          "=": 6
        },
        "name": "opt_loop_break_neg",
        "body": "(interactionOperator =  InteractionOperatorKind::opt or interactionOperator = InteractionOperatorKind::loop or\r\ninteractionOperator = InteractionOperatorKind::break or interactionOperator = InteractionOperatorKind::assert or\r\ninteractionOperator = InteractionOperatorKind::neg)\r\nimplies operand->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 6,
          "EnumLiteralExpImpl": 5,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::CombinedFragment::operand",
          "UML::CombinedFragment::interactionOperator"
        ]
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 1,
          "implies": 1,
          "=": 2
        },
        "name": "consider_and_ignore",
        "body": "((interactionOperator = InteractionOperatorKind::consider) or (interactionOperator =  InteractionOperatorKind::ignore)) implies oclIsKindOf(ConsiderIgnoreFragment)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::CombinedFragment::interactionOperator"]
      },
      {
        "operations": {
          "oclAsSet": 2,
          "union": 1,
          "asSet": 4,
          "implies": 1,
          "oclAsType": 2,
          "=": 2
        },
        "name": "break",
        "body": "interactionOperator=InteractionOperatorKind::break  implies   \r\nenclosingInteraction.oclAsType(InteractionFragment)->asSet()->union(\r\n   enclosingOperand.oclAsType(InteractionFragment)->asSet()).covered->asSet() = self.covered->asSet()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 12,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::InteractionFragment::enclosingOperand",
          "UML::InteractionFragment::covered",
          "UML::InteractionFragment::enclosingInteraction",
          "UML::CombinedFragment::interactionOperator"
        ]
      }
    ],
    "properties": [
      "cfragmentGate",
      "operand",
      "interactionOperator"
    ]
  },
  {
    "name": "GeneralOrdering",
    "expressions": [{
      "operations": {
        "excludes": 1,
        "oclAsSet": 1
      },
      "name": "irreflexive_transitive_closure",
      "body": "after->closure(toAfter.after)->excludes(before)",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "VariableExpImpl": 4,
        "OperationCallExpImpl": 2,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "UML::GeneralOrdering::after",
        "UML::GeneralOrdering::before",
        "UML::OccurrenceSpecification::toAfter"
      ]
    }],
    "properties": [
      "after",
      "before",
      "interactionFragment"
    ]
  },
  {
    "name": "InteractionOperand",
    "expressions": [
      {
        "operations": {},
        "name": "guard_contain_references",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {},
        "name": "guard_directly_prior",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      }
    ],
    "properties": [
      "fragment",
      "guard",
      "combinedFragment"
    ]
  },
  {
    "name": "Region",
    "expressions": [
      {
        "operations": {},
        "name": "isConsistentWith",
        "body": "-- the following is merely a default body; it is expected that the specific form of this constraint will be specified by profiles\r\ntrue",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "or": 1,
          "notEmpty": 1,
          "=": 1,
          "containingStateMachine": 1
        },
        "name": "redefinitionContext",
        "body": "let sm : StateMachine = containingStateMachine() in\nif sm._'context' = null or sm.general->notEmpty() then\n  sm\nelse\n  sm._'context'\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 4,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Classifier::general",
          "UML::Behavior::context"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "oclIsKindOf": 1,
          "implies": 1,
          "belongsToPSM": 1
        },
        "name": "belongsToPSM",
        "body": "if  stateMachine <> null \nthen\n  stateMachine.oclIsKindOf(ProtocolStateMachine)\nelse \n  state <> null  implies  state.container.belongsToPSM()\nendif ",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Region::stateMachine",
          "UML::Region::state",
          "UML::Vertex::container"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "oclIsKindOf": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "initial_vertex",
        "body": "self.subvertex->select (oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->\n  select(kind = PseudostateKind::initial)->size() <= 1\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Region::subvertex"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "oclIsKindOf": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "shallow_history_vertex",
        "body": "subvertex->select(oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->\n  select(kind = PseudostateKind::shallowHistory)->size() <= 1\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Region::subvertex"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 2,
          "oclAsSet": 2,
          "isEmpty": 1,
          "includes": 2,
          "notEmpty": 2,
          "oclAsType": 1
        },
        "name": "isRedefinitionContextValid",
        "body": "if redefinedElement.oclIsKindOf(Region) then\r\n  let redefinedRegion : Region = redefinedElement.oclAsType(Region) in\r\n    if stateMachine->isEmpty() then\r\n    -- the Region is owned by a State\r\n      (state.redefinedState->notEmpty() and state.redefinedState.region->includes(redefinedRegion))\r\n    else -- the region is owned by a StateMachine\r\n      (stateMachine.extendedStateMachine->notEmpty() and\r\n        stateMachine.extendedStateMachine->exists(sm : StateMachine |\r\n          sm.region->includes(redefinedRegion)))\r\n    endif\r\nelse\r\n  false\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 10,
          "OperationCallExpImpl": 11,
          "LetExpImpl": 1,
          "TypeExpImpl": 2,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 11,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "UML::Region::stateMachine",
          "UML::State::region",
          "UML::Region::state",
          "UML::StateMachine::region",
          "UML::StateMachine::extendedStateMachine",
          "UML::State::redefinedState"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "oclIsKindOf": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "deep_history_vertex",
        "body": "self.subvertex->select (oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))->\n   select(kind = PseudostateKind::deepHistory)->size() <= 1\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Region::subvertex"
        ]
      },
      {
        "operations": {
          "=": 1,
          "containingStateMachine": 1
        },
        "name": "containingStateMachine",
        "body": "if stateMachine = null \nthen\n  state.containingStateMachine()\nelse\n  stateMachine\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Region::stateMachine",
          "UML::Region::state"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "and": 1,
          "implies": 2,
          "=": 2
        },
        "name": "owned",
        "body": "(stateMachine <> null implies state = null) and (state <> null implies stateMachine = null)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 7,
          "NullLiteralExpImpl": 4,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Region::stateMachine",
          "UML::Region::state"
        ]
      }
    ],
    "properties": [
      "stateMachine",
      "transition",
      "state",
      "subvertex",
      "redefinitionContext",
      "region",
      "extendedRegion"
    ]
  },
  {
    "name": "StructuralFeatureAction",
    "expressions": [
      {
        "operations": {
          "size": 1,
          "oclAsSet": 1,
          "=": 1
        },
        "name": "one_featuring_classifier",
        "body": "structuralFeature.featuringClassifier->size() = 1",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::Feature::featuringClassifier"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity",
        "body": "object.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::StructuralFeatureAction::object"]
      },
      {
        "operations": {"not": 1},
        "name": "not_static",
        "body": "not structuralFeature.isStatic",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Feature::isStatic",
          "UML::StructuralFeatureAction::structuralFeature"
        ]
      },
      {
        "operations": {
          "or": 2,
          "and": 1,
          "allFeatures": 1,
          "includes": 1,
          "conformsTo": 1,
          "oclAsType": 2,
          "=": 2
        },
        "name": "visibility",
        "body": "structuralFeature.visibility = VisibilityKind::public or\n_'context'.allFeatures()->includes(structuralFeature) or\nstructuralFeature.visibility=VisibilityKind::protected and\n_'context'.conformsTo(structuralFeature.oclAsType(Property).opposite.type.oclAsType(Classifier))\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 6,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::Action::context",
          "UML::TypedElement::type",
          "UML::Property::opposite",
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::NamedElement::visibility"
        ]
      },
      {
        "operations": {
          "or": 1,
          "allFeatures": 1,
          "includes": 1,
          "conformsTo": 1,
          "oclAsType": 2
        },
        "name": "object_type",
        "body": "object.type.oclAsType(Classifier).allFeatures()->includes(structuralFeature) or\r\n\tobject.type.conformsTo(structuralFeature.oclAsType(Property).opposite.type)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 4,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::StructuralFeatureAction::object",
          "UML::TypedElement::type",
          "UML::Property::opposite",
          "UML::StructuralFeatureAction::structuralFeature"
        ]
      }
    ],
    "properties": [
      "object",
      "structuralFeature"
    ]
  },
  {
    "name": "LiteralReal",
    "expressions": [
      {
        "operations": {},
        "name": "realValue",
        "body": "value",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::LiteralReal::value"]
      },
      {
        "operations": {},
        "name": "isComputable",
        "body": "true",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": ["value"]
  },
  {
    "name": "ObjectNodeOrderingKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ActionInputPin",
    "expressions": [
      {
        "operations": {
          "and": 2,
          "isEmpty": 3,
          "union": 1
        },
        "name": "no_control_or_object_flow",
        "body": "fromAction.incoming->union(outgoing)->isEmpty() and\r\nfromAction.input.incoming->isEmpty() and\r\nfromAction.output.outgoing->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 6,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::Action::input",
          "UML::ActionInputPin::fromAction",
          "UML::ActivityNode::outgoing",
          "UML::Action::output",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "one_output_pin",
        "body": "fromAction.output->size() = 1",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActionInputPin::fromAction",
          "UML::Action::output"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "input_pin",
        "body": "fromAction.input->forAll(oclIsKindOf(ActionInputPin))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Action::input",
          "UML::ActionInputPin::fromAction"
        ]
      }
    ],
    "properties": ["fromAction"]
  },
  {
    "name": "Extend",
    "expressions": [{
      "operations": {"includes": 1},
      "name": "extension_points",
      "body": "extensionLocation->forAll (xp | extendedCase.extensionPoint->includes(xp))",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::UseCase::extensionPoint",
        "UML::Extend::extendedCase",
        "UML::Extend::extensionLocation"
      ]
    }],
    "properties": [
      "extendedCase",
      "extensionLocation",
      "condition",
      "extension"
    ]
  },
  {
    "name": "OpaqueExpression",
    "expressions": [
      {
        "operations": {},
        "name": "isPositive",
        "body": "false",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "<>": 1,
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "one_return_result_parameter",
        "body": "behavior <> null implies\r\n   behavior.ownedParameter->select(direction=ParameterDirectionKind::return)->size() = 1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction",
          "UML::OpaqueExpression::behavior"
        ]
      },
      {
        "operations": {
          "size": 2,
          "implies": 1,
          "notEmpty": 1,
          "=": 1
        },
        "name": "language_body_size",
        "body": "language->notEmpty() implies (_'body'->size() = language->size())",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::OpaqueExpression::body",
          "UML::OpaqueExpression::language"
        ]
      },
      {
        "operations": {
          "=": 1,
          "first": 1
        },
        "name": "result",
        "body": "if behavior = null then\r\n\tnull\r\nelse\r\n\tbehavior.ownedParameter->first()\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Behavior::ownedParameter",
          "UML::OpaqueExpression::behavior"
        ]
      },
      {
        "operations": {},
        "name": "value",
        "body": "0",
        "type": "OperationImpl",
        "constructs": {"IntegerLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "<>": 2,
          "isEmpty": 1,
          "implies": 1
        },
        "name": "only_return_result_parameters",
        "body": "behavior <> null implies behavior.ownedParameter->select(direction<>ParameterDirectionKind::return)->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Behavior::ownedParameter",
          "UML::OpaqueExpression::behavior",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {},
        "name": "isIntegral",
        "body": "false",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "isNonNegative",
        "body": "false",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": [
      "body",
      "result",
      "language",
      "abstraction",
      "behavior"
    ]
  },
  {
    "name": "CallOperationAction",
    "expressions": [
      {
        "operations": {"inputParameters": 1},
        "name": "inputParameters",
        "body": "operation.inputParameters()",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CallOperationAction::operation"]
      },
      {
        "operations": {
          "and": 1,
          "allFeatures": 3,
          "includes": 3,
          "union": 1,
          "=": 1,
          "oclAsType": 2
        },
        "name": "type_target_pin",
        "body": "if onPort=null then  target.type.oclAsType(Classifier).allFeatures()->includes(operation)\r\nelse target.type.oclAsType(Classifier).allFeatures()->includes(onPort) and onPort.provided->union(onPort.required).allFeatures()->includes(operation)\r\nendif",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 9,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "UML::CallOperationAction::target",
          "UML::CallOperationAction::operation",
          "UML::TypedElement::type",
          "UML::Port::provided",
          "UML::InvocationAction::onPort",
          "UML::Port::required"
        ]
      },
      {
        "operations": {"outputParameters": 1},
        "name": "outputParameters",
        "body": "operation.outputParameters()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CallOperationAction::operation"]
      }
    ],
    "properties": [
      "target",
      "operation"
    ]
  },
  {
    "name": "TemplateSignature",
    "expressions": [
      {
        "operations": {
          "includesAll": 1,
          "asSet": 2,
          "-": 1
        },
        "name": "own_elements",
        "body": "template.ownedElement->includesAll(parameter.parameteredElement->asSet() - parameter.ownedParameteredElement->asSet())",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 4,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::TemplateSignature::template",
          "UML::TemplateSignature::parameter",
          "UML::Element::ownedElement",
          "UML::TemplateParameter::parameteredElement",
          "UML::TemplateParameter::ownedParameteredElement"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "oclIsKindOf": 2,
          "and": 2,
          "implies": 1,
          "oclAsType": 2
        },
        "name": "unique_parameters",
        "body": "parameter->forAll( p1, p2 | (p1 <> p2 and p1.parameteredElement.oclIsKindOf(NamedElement) and p2.parameteredElement.oclIsKindOf(NamedElement) ) implies\r\n   p1.parameteredElement.oclAsType(NamedElement).name <> p2.parameteredElement.oclAsType(NamedElement).name)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 7,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::TemplateSignature::parameter",
          "UML::NamedElement::name",
          "UML::TemplateParameter::parameteredElement"
        ]
      }
    ],
    "properties": [
      "ownedParameter",
      "template",
      "parameter",
      "templateBinding"
    ]
  },
  {
    "name": "OpaqueAction",
    "expressions": [{
      "operations": {
        "size": 2,
        "notEmpty": 1,
        "implies": 1,
        "=": 1
      },
      "name": "language_body_size",
      "body": "language->notEmpty() implies (_'body'->size() = language->size())",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 5,
        "VariableExpImpl": 3,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::OpaqueAction::body",
        "UML::OpaqueAction::language"
      ]
    }],
    "properties": [
      "outputValue",
      "body",
      "inputValue",
      "language"
    ]
  },
  {
    "name": "TimeConstraint",
    "expressions": [{
      "operations": {
        "size": 1,
        "=": 1
      },
      "name": "has_one_constrainedElement",
      "body": "constrainedElement->size() = 1",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::Constraint::constrainedElement"]
    }],
    "properties": [
      "firstEvent",
      "specification"
    ]
  },
  {
    "name": "Relationship",
    "expressions": [],
    "properties": [
      "abstraction",
      "relatedElement"
    ]
  },
  {
    "name": "Element",
    "expressions": [
      {
        "operations": {
          "mustBeOwned": 1,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1
        },
        "name": "has_owner",
        "body": "mustBeOwned() implies owner->notEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Element::owner"]
      },
      {
        "operations": {},
        "name": "mustBeOwned",
        "body": "true",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "not": 1,
          "allOwnedElements": 1,
          "includes": 1
        },
        "name": "not_own_self",
        "body": "not allOwnedElements()->includes(self)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {
          "allOwnedElements": 1,
          "union": 1,
          "asSet": 1
        },
        "name": "allOwnedElements",
        "body": "ownedElement->union(ownedElement->collect(e | e.allOwnedElements()))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Element::ownedElement"]
      }
    ],
    "properties": [
      "ownedComment",
      "directedRelationship",
      "comment",
      "constraint",
      "ownedElement",
      "relationship",
      "activityPartition",
      "owner",
      "directedRelationship"
    ]
  },
  {
    "name": "Transition",
    "expressions": [
      {
        "operations": {},
        "name": "isConsistentWith",
        "body": "-- the following is merely a default body; it is expected that the specific form of this constraint will be specified by profiles\r\ntrue",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 2,
          "isEmpty": 1,
          "implies": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "join_segment_guards",
        "body": "(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (guard = null and trigger->isEmpty())",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Transition::guard",
          "UML::Transition::target",
          "UML::Transition::trigger"
        ]
      },
      {
        "operations": {
          "or": 1,
          "notEmpty": 1,
          "=": 1,
          "containingStateMachine": 1
        },
        "name": "redefinitionContext",
        "body": "let sm : StateMachine = containingStateMachine() in\nif sm._'context' = null or sm.general->notEmpty() then\n  sm\nelse\n  sm._'context'\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 4,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Classifier::general",
          "UML::Behavior::context"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "isEmpty": 1,
          "implies": 1,
          "notEmpty": 1
        },
        "name": "initial_transition",
        "body": "(source.oclIsKindOf(Pseudostate) and container.stateMachine->notEmpty()) implies\n\ttrigger->isEmpty()\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 6,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Transition::container",
          "UML::Region::stateMachine",
          "UML::Transition::source",
          "UML::Transition::trigger"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "and": 1,
          "implies": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "fork_segment_state",
        "body": "(source.oclIsKindOf(Pseudostate) and  source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (target.oclIsKindOf(State))",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Transition::source",
          "UML::Transition::target"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 2,
          "isEmpty": 1,
          "implies": 1,
          "oclAsType": 1,
          "=": 2
        },
        "name": "fork_segment_guards",
        "body": "(source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (guard = null and trigger->isEmpty())",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 8,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Transition::source",
          "UML::Transition::guard",
          "UML::Transition::trigger"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "implies": 1,
          "=": 2
        },
        "name": "state_is_internal",
        "body": "(kind = TransitionKind::internal) implies\r\n\t\t(source.oclIsKindOf (State) and source = target)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Transition::kind",
          "UML::Transition::source",
          "UML::Transition::target"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "isEmpty": 1,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "outgoing_pseudostates",
        "body": "source.oclIsKindOf(Pseudostate) and (source.oclAsType(Pseudostate).kind <> PseudostateKind::initial) implies trigger->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 6,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Transition::source",
          "UML::Transition::trigger"
        ]
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2,
          "and": 2,
          "implies": 1,
          "=": 2,
          "oclAsType": 2
        },
        "name": "state_is_local",
        "body": "(kind = TransitionKind::local) implies\r\n\t\t((source.oclIsKindOf (State) and source.oclAsType(State).isComposite) or\r\n\t\t(source.oclIsKindOf (Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint))",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 10,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::State::isComposite",
          "UML::Transition::kind",
          "UML::Transition::source"
        ]
      },
      {
        "operations": {"containingStateMachine": 1},
        "name": "containingStateMachine",
        "body": "container.containingStateMachine()",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Transition::container"]
      },
      {
        "operations": {
          "not": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "implies": 1,
          "oclAsType": 1,
          "=": 2
        },
        "name": "state_is_external",
        "body": "(kind = TransitionKind::external) implies\r\n\tnot (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Transition::kind",
          "UML::Transition::source"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "and": 1,
          "implies": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "join_segment_state",
        "body": "(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (source.oclIsKindOf(State))",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 6,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Transition::source",
          "UML::Transition::target"
        ]
      }
    ],
    "properties": [
      "container",
      "effect",
      "kind",
      "redefinitionContext",
      "source",
      "guard",
      "redefinedTransition",
      "target",
      "transition",
      "trigger"
    ]
  },
  {
    "name": "StateMachine",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "isEmpty": 1,
          "implies": 1
        },
        "name": "method",
        "body": "specification <> null implies connectionPoint->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Behavior::specification",
          "UML::StateMachine::connectionPoint"
        ]
      },
      {
        "operations": {
          "ancestor": 2,
          "LCA": 1
        },
        "name": "LCA",
        "body": "if ancestor(s1, s2) then \r\n    s2.container\r\nelse\r\n\tif ancestor(s2, s1) then\r\n\t    s1.container \r\n\telse \r\n\t    LCA(s1.container.state, s2.container.state)\r\n\tendif\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 11,
          "OperationCallExpImpl": 3,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Region::state",
          "UML::Vertex::container"
        ]
      },
      {
        "operations": {
          "or": 1,
          "oclIsTypeOf": 2,
          "and": 2,
          "ancestor": 2,
          "isEmpty": 2,
          "oclAsSet": 2,
          "LCAState": 1,
          "oclAsType": 3
        },
        "name": "LCAState",
        "body": "if v2.oclIsTypeOf(State) and ancestor(v1, v2) then\r\n\tv2.oclAsType(State)\r\nelse if v1.oclIsTypeOf(State) and ancestor(v2, v1) then\r\n\tv1.oclAsType(State)\r\nelse if (v1.container.state->isEmpty() or v2.container.state->isEmpty()) then \r\n\tnull.oclAsType(State)\r\nelse LCAState(v1.container.state, v2.container.state)\r\nendif endif endif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 15,
          "VariableExpImpl": 15,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 5,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::Region::state",
          "UML::Vertex::container"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "context": 2,
          "includes": 1,
          "oclAsType": 2
        },
        "name": "isRedefinitionContextValid",
        "body": "if redefinedElement.oclIsKindOf(StateMachine) then\r\n  let redefinedStateMachine : StateMachine = redefinedElement.oclAsType(StateMachine) in\r\n    self._'context'().oclAsType(BehavioredClassifier).redefinedClassifier->\r\n      includes(redefinedStateMachine._'context'())\r\nelse\r\n  false\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 4,
          "LetExpImpl": 1,
          "TypeExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 1,
          "BooleanLiteralExpImpl": 1
        },
        "properties": ["UML::Classifier::redefinedClassifier"]
      },
      {
        "operations": {
          "or": 1,
          "=": 2
        },
        "name": "connection_points",
        "body": "connectionPoint->forAll (kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::StateMachine::connectionPoint"
        ]
      },
      {
        "operations": {
          "not": 1,
          "<>": 1,
          "oclIsKindOf": 1,
          "implies": 1
        },
        "name": "classifier_context",
        "body": "_'context' <> null implies not _'context'.oclIsKindOf(Interface)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Behavior::context"]
      },
      {
        "operations": {
          "ancestor": 1,
          "oclAsSet": 2,
          "notEmpty": 2,
          "=": 1
        },
        "name": "ancestor",
        "body": "if (s2 = s1) then \r\n\ttrue \r\nelse \r\n\tif s1.container.stateMachine->notEmpty() then \r\n\t    true\r\n\telse \r\n\t    if s2.container.stateMachine->notEmpty() then \r\n\t        false\r\n\t    else\r\n\t        ancestor(s1, s2.container.state)\r\n\t     endif\r\n\t endif\r\nendif  ",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 6,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 6,
          "BooleanLiteralExpImpl": 3
        },
        "properties": [
          "UML::Region::stateMachine",
          "UML::Region::state",
          "UML::Vertex::container"
        ]
      },
      {
        "operations": {},
        "name": "isConsistentWith",
        "body": "-- the following is merely a default body; it is expected that the specific form of this constraint will be specified by profiles\r\ntrue",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "<>": 2,
          "and": 1,
          "oclAsSet": 1,
          "implies": 1,
          "=": 1
        },
        "name": "context_classifier",
        "body": "specification <> null implies ( _'context' <> null and specification.featuringClassifier->exists(c | c = _'context'))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 6,
          "NullLiteralExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Behavior::specification",
          "UML::Behavior::context",
          "UML::Feature::featuringClassifier"
        ]
      }
    ],
    "properties": [
      "region",
      "stateMachine",
      "extendedStateMachine",
      "connectionPoint",
      "submachineState"
    ]
  },
  {
    "name": "PackageImport",
    "expressions": [{
      "operations": {
        "or": 1,
        "=": 2
      },
      "name": "public_or_private",
      "body": "visibility = VisibilityKind::public or visibility = VisibilityKind::private",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 3,
        "EnumLiteralExpImpl": 2,
        "PropertyCallExpImpl": 2
      },
      "properties": ["UML::PackageImport::visibility"]
    }],
    "properties": [
      "importingNamespace",
      "importedPackage",
      "profile",
      "visibility"
    ]
  },
  {
    "name": "AssociationClass",
    "expressions": [
      {
        "operations": {
          "flatten": 1,
          "excludes": 2,
          "endType": 2,
          "and": 1,
          "allParents": 1,
          "oclAsType": 1
        },
        "name": "cannot_be_defined",
        "body": "self.endType()->excludes(self) and self.endType()->collect(et|et.oclAsType(Classifier).allParents())->flatten()->excludes(self)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 5,
          "TypeExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "intersection": 1,
          "isEmpty": 1
        },
        "name": "disjoint_attributes_ends",
        "body": "ownedAttribute->intersection(ownedEnd)->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Association::ownedEnd",
          "UML::Class::ownedAttribute"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ProtocolStateMachine",
    "expressions": [
      {
        "operations": {
          "<>": 2,
          "oclIsKindOf": 1,
          "and": 1,
          "implies": 1,
          "oclAsType": 2
        },
        "name": "deep_or_shallow_history",
        "body": "region->forAll (r | r.subvertex->forAll (v | v.oclIsKindOf(Pseudostate) implies\n((v.oclAsType(Pseudostate).kind <>  PseudostateKind::deepHistory) and (v.oclAsType(Pseudostate).kind <> PseudostateKind::shallowHistory))))\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 7,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Region::subvertex",
          "UML::StateMachine::region"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 2,
          "oclAsSet": 3,
          "isEmpty": 3,
          "implies": 1,
          "oclAsType": 3
        },
        "name": "entry_exit_do",
        "body": "region->forAll(r | r.subvertex->forAll(v | v.oclIsKindOf(State) implies\n(v.oclAsType(State).entry->isEmpty() and v.oclAsType(State).exit->isEmpty() and v.oclAsType(State).doActivity->isEmpty())))\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 13,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Region::subvertex",
          "UML::StateMachine::region",
          "UML::State::entry",
          "UML::State::exit",
          "UML::State::doActivity"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "and": 1,
          "=": 1
        },
        "name": "classifier_context",
        "body": "_'context' <> null and specification = null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Behavior::specification",
          "UML::Behavior::context"
        ]
      },
      {
        "operations": {"oclIsTypeOf": 1},
        "name": "protocol_transitions",
        "body": "region->forAll(r | r.transition->forAll(t | t.oclIsTypeOf(ProtocolTransition)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Region::transition",
          "UML::StateMachine::region"
        ]
      }
    ],
    "properties": [
      "port",
      "conformance",
      "protocolConformance",
      "interface"
    ]
  },
  {
    "name": "InterruptibleActivityRegion",
    "expressions": [{
      "operations": {
        "excludes": 1,
        "and": 2,
        "includes": 1,
        "oclBadOperation": 1,
        "=": 1
      },
      "name": "interrupting_edges",
      "body": "interruptingEdge->forAll(edge | \n  node->includes(edge.source) and node->excludes(edge.target) and edge.target.containingActivity() = inActivity)",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 7,
        "PropertyCallExpImpl": 7
      },
      "properties": [
        "UML::ActivityEdge::target",
        "UML::InterruptibleActivityRegion::node",
        "UML::ActivityEdge::source",
        "UML::InterruptibleActivityRegion::interruptingEdge",
        "UML::ActivityGroup::inActivity"
      ]
    }],
    "properties": [
      "node",
      "interruptingEdge"
    ]
  },
  {
    "name": "Classifier",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "parents": 1
        },
        "name": "non_final_parents",
        "body": "parents()->forAll(not isFinalSpecialization)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Classifier::isFinalSpecialization"]
      },
      {
        "operations": {"asSet": 1},
        "name": "parents",
        "body": "generalization.general->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Generalization::general",
          "UML::Classifier::generalization"
        ]
      },
      {
        "operations": {
          "allParents": 1,
          "union": 1,
          "asSet": 1,
          "parents": 2
        },
        "name": "allParents",
        "body": "parents()->union(parents()->collect(allParents())->asSet())",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5
        },
        "properties": []
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 1,
          "allParents": 1,
          "includes": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "conformsTo",
        "body": "if other.oclIsKindOf(Classifier) then\r\n  let otherClassifier : Classifier = other.oclAsType(Classifier) in\r\n    self = otherClassifier or allParents()->includes(otherClassifier)\r\nelse\r\n  false\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 6,
          "LetExpImpl": 1,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "BooleanLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "asOrderedSet": 1,
          "allAttributes": 1,
          "includes": 1,
          "union": 1,
          "asSequence": 2,
          "parents": 1
        },
        "name": "allAttributes",
        "body": "attribute->asSequence()->union(parents()->asSequence().allAttributes())->select(p | member->includes(p))->asOrderedSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 7,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Classifier::attribute",
          "UML::Namespace::member"
        ]
      },
      {
        "operations": {
          "directlyUsedInterfaces": 2,
          "allParents": 1,
          "union": 1,
          "asSet": 1
        },
        "name": "allUsedInterfaces",
        "body": "directlyUsedInterfaces()->union(self.allParents()->collect(directlyUsedInterfaces()))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5
        },
        "properties": []
      },
      {
        "operations": {
          "<>": 1,
          "or": 1,
          "isTemplate": 1
        },
        "name": "isTemplate",
        "body": "ownedTemplateSignature <> null or general->exists(g | g.isTemplate())",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Classifier::general",
          "UML::Classifier::ownedTemplateSignature"
        ]
      },
      {
        "operations": {
          "not": 1,
          "allParents": 1,
          "includes": 1
        },
        "name": "no_cycles_in_generalization",
        "body": "not allParents()->includes(self)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "and": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "directlyRealizedInterfaces",
        "body": "(clientDependency->\r\n  select(oclIsKindOf(Realization) and supplier->forAll(oclIsKindOf(Interface))))->\r\n      collect(supplier.oclAsType(Interface))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 5,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::NamedElement::clientDependency",
          "UML::Dependency::supplier"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "hasVisibilityOf",
        "body": "n.visibility <> VisibilityKind::private",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::NamedElement::visibility"]
      },
      {
        "operations": {
          "maySpecializeType": 1,
          "parents": 1
        },
        "name": "specialize_type",
        "body": "parents()->forAll(c | self.maySpecializeType(c))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3
        },
        "properties": []
      },
      {
        "operations": {
          "not": 4,
          "and": 3,
          "allParents": 2,
          "includes": 2,
          "=": 2
        },
        "name": "maps_to_generalization_set",
        "body": "powertypeExtent->forAll( gs | \r\n  gs.generalization->forAll( gen | \r\n    not (gen.general = self) and not gen.general.allParents()->includes(self) and not (gen.specific = self) and not self.allParents()->includes(gen.specific) \r\n  ))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 10,
          "OperationCallExpImpl": 13,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Generalization::general",
          "UML::GeneralizationSet::generalization",
          "UML::Classifier::powertypeExtent",
          "UML::Generalization::specific"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "allFeatures",
        "body": "member->select(oclIsKindOf(Feature))->collect(oclAsType(Feature))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Namespace::member"]
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "and": 1,
          "includes": 1,
          "notEmpty": 1,
          "oclAsType": 1
        },
        "name": "inherit",
        "body": "inhs->reject(inh |\r\n  inh.oclIsKindOf(RedefinableElement) and\r\n  ownedMember->select(oclIsKindOf(RedefinableElement))->\r\n    select(redefinedElement->includes(inh.oclAsType(RedefinableElement)))\r\n       ->notEmpty())",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 6,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::RedefinableElement::redefinedElement",
          "UML::Namespace::ownedMember"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclType": 1
        },
        "name": "maySpecializeType",
        "body": "self.oclIsKindOf(c.oclType())",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {
          "allParents": 1,
          "union": 1,
          "asSet": 1,
          "directlyRealizedInterfaces": 2
        },
        "name": "allRealizedInterfaces",
        "body": "directlyRealizedInterfaces()->union(self.allParents()->collect(directlyRealizedInterfaces()))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5
        },
        "properties": []
      },
      {
        "operations": {"parents": 1},
        "name": "general",
        "body": "parents()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {"hasVisibilityOf": 1},
        "name": "inheritableMembers",
        "body": "member->select(m | c.hasVisibilityOf(m))",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Namespace::member"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "inherit": 1,
          "allParents": 1,
          "union": 1,
          "asSet": 2,
          "oclAsType": 2
        },
        "name": "allSlottableFeatures",
        "body": "member->select(oclIsKindOf(StructuralFeature))->\r\n  collect(oclAsType(StructuralFeature))->\r\n   union(self.inherit(self.allParents()->collect(p | p.attribute)->asSet())->\r\n     collect(oclAsType(StructuralFeature)))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 7,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Classifier::attribute",
          "UML::Namespace::member"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "and": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "directlyUsedInterfaces",
        "body": "(supplierDependency->\r\n  select(oclIsKindOf(Usage) and client->forAll(oclIsKindOf(Interface))))->\r\n    collect(client.oclAsType(Interface))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 6,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Dependency::client"]
      },
      {
        "operations": {
          "inherit": 1,
          "asSet": 1,
          "inheritableMembers": 1,
          "parents": 1
        },
        "name": "inheritedMember",
        "body": "inherit(parents()->collect(inheritableMembers(self))->asSet())",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 4
        },
        "properties": []
      },
      {
        "operations": {"includes": 1},
        "name": "isSubstitutableFor",
        "body": "substitution.contract->includes(contract)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Substitution::contract",
          "UML::Classifier::substitution"
        ]
      }
    ],
    "properties": [
      "redefinableElement",
      "action",
      "collaborationUse",
      "region",
      "useCase",
      "instanceSpecification",
      "componentRealization",
      "createObjectAction",
      "readIsClassifiedObjectAction",
      "substitution",
      "generalization",
      "classifierTemplateParameter",
      "general",
      "readExtentAction",
      "exceptionHandler",
      "attribute",
      "unmarshallAction",
      "classifier",
      "feature",
      "powertypeExtent",
      "representation",
      "ownedTemplateSignature",
      "nestingClass",
      "inheritedMember",
      "ownedUseCase",
      "reclassifyObjectAction",
      "representation",
      "classifier",
      "reclassifyObjectAction",
      "substitution",
      "transition",
      "isFinalSpecialization",
      "redefinedClassifier",
      "templateParameter",
      "conveyingFlow",
      "state",
      "interface",
      "generalization",
      "isAbstract"
    ]
  },
  {
    "name": "ExceptionHandler",
    "expressions": [
      {
        "operations": {
          "and": 2,
          "isEmpty": 3
        },
        "name": "handler_body_edges",
        "body": "handlerBody.incoming->isEmpty() and handlerBody.outgoing->isEmpty() and exceptionInput.incoming->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ExceptionHandler::exceptionInput",
          "UML::ActivityNode::incoming",
          "UML::ExceptionHandler::handlerBody"
        ]
      },
      {
        "operations": {
          "or": 1,
          "conformsTo": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "exception_input_type",
        "body": "exceptionInput.type=null or \r\nexceptionType->forAll(conformsTo(exceptionInput.type.oclAsType(Classifier)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ExceptionHandler::exceptionInput",
          "UML::ExceptionHandler::exceptionType"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "handler_body_owner",
        "body": "handlerBody.owner=protectedNode.owner",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ExceptionHandler::handlerBody",
          "UML::ExceptionHandler::protectedNode",
          "UML::Element::owner"
        ]
      },
      {
        "operations": {
          "at": 6,
          "size": 3,
          "compatibleWith": 1,
          "oclIsKindOf": 2,
          "and": 5,
          "conformsTo": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 2,
          "oclAsType": 3
        },
        "name": "output_pins",
        "body": "(protectedNode.oclIsKindOf(Action) and protectedNode.oclAsType(Action).output->notEmpty()) implies\r\n(\r\n  handlerBody.oclIsKindOf(Action) and \r\n  let protectedNodeOutput : OrderedSet(OutputPin) = protectedNode.oclAsType(Action).output,\r\n        handlerBodyOutput : OrderedSet(OutputPin) =  handlerBody.oclAsType(Action).output in\r\n    protectedNodeOutput->size() = handlerBodyOutput->size() and\r\n    Sequence{1..protectedNodeOutput->size()}->forAll(i |\r\n    \thandlerBodyOutput->at(i).type.conformsTo(protectedNodeOutput->at(i).type) and\r\n    \thandlerBodyOutput->at(i).isOrdered=protectedNodeOutput->at(i).isOrdered and\r\n    \thandlerBodyOutput->at(i).compatibleWith(protectedNodeOutput->at(i)))\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 25,
          "VariableExpImpl": 20,
          "LetExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 5,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::Action::output",
          "UML::ExceptionHandler::handlerBody",
          "UML::ExceptionHandler::protectedNode"
        ]
      },
      {
        "operations": {
          "size": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "=": 2,
          "oclAsType": 1,
          "first": 1
        },
        "name": "one_input",
        "body": "handlerBody.oclIsKindOf(Action) and\r\nlet inputs: OrderedSet(InputPin) = handlerBody.oclAsType(Action).input in\r\ninputs->size()=1 and inputs->first()=exceptionInput",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 8,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Action::input",
          "UML::ExceptionHandler::exceptionInput",
          "UML::ExceptionHandler::handlerBody"
        ]
      },
      {
        "operations": {
          "and": 1,
          "includes": 2,
          "allOwnedNodes": 1,
          "oclAsType": 1
        },
        "name": "edge_source_target",
        "body": "let nodes:Set(ActivityNode) = handlerBody.oclAsType(Action).allOwnedNodes() in\r\nnodes.outgoing->forAll(nodes->includes(target)) and\r\nnodes.incoming->forAll(nodes->includes(source))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 9,
          "LetExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ActivityEdge::target",
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming",
          "UML::ActivityEdge::source",
          "UML::ExceptionHandler::handlerBody"
        ]
      }
    ],
    "properties": [
      "exceptionInput",
      "exceptionType",
      "handlerBody",
      "protectedNode"
    ]
  },
  {
    "name": "Event",
    "expressions": [],
    "properties": ["trigger"]
  },
  {
    "name": "CallEvent",
    "expressions": [],
    "properties": ["operation"]
  },
  {
    "name": "OutputPin",
    "expressions": [{
      "operations": {
        "includesAll": 1,
        "<>": 1,
        "oclIsKindOf": 1,
        "and": 2,
        "allOwnedNodes": 1,
        "implies": 1,
        "notEmpty": 1,
        "oclAsType": 1
      },
      "name": "incoming_edges_structured_only",
      "body": "incoming->notEmpty() implies\r\n\taction<>null and\r\n\taction.oclIsKindOf(StructuredActivityNode) and\r\n\taction.oclAsType(StructuredActivityNode).allOwnedNodes()->includesAll(incoming.source)",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 9,
        "VariableExpImpl": 6,
        "OppositePropertyCallExpImpl": 3,
        "NullLiteralExpImpl": 1,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::ActivityNode::incoming",
        "UML::ActivityEdge::source"
      ]
    }],
    "properties": [
      "readLinkAction",
      "unmarshallAction",
      "createLinkObjectAction",
      "clearStructuralFeatureAction",
      "testIdentityAction",
      "readIsClassifiedObjectAction",
      "callAction",
      "createObjectAction",
      "readSelfAction",
      "readExtentAction",
      "structuredActivityNode",
      "valueSpecificationAction",
      "clause",
      "acceptCallAction",
      "action",
      "loopNode",
      "conditionalNode",
      "writeStructuralFeatureAction",
      "reduceAction",
      "loopNode",
      "loopNode",
      "acceptEventAction",
      "readVariableAction",
      "readLinkObjectEndQualifierAction",
      "loopNode",
      "readStructuralFeatureAction",
      "clause",
      "opaqueAction",
      "readLinkObjectEndAction"
    ]
  },
  {
    "name": "ValueSpecification",
    "expressions": [
      {
        "operations": {},
        "name": "realValue",
        "body": "null",
        "type": "OperationImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "and": 1,
          "conformsTo": 1,
          "implies": 1,
          "oclAsType": 1,
          "oclType": 1
        },
        "name": "isCompatibleWith",
        "body": "self.oclIsKindOf(p.oclType()) and (p.oclIsKindOf(TypedElement) implies \r\nself.type.conformsTo(p.oclAsType(TypedElement).type))",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 5,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::TypedElement::type"]
      },
      {
        "operations": {},
        "name": "stringValue",
        "body": "null",
        "type": "OperationImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "isComputable",
        "body": "false",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "unlimitedValue",
        "body": "null",
        "type": "OperationImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "booleanValue",
        "body": "null",
        "type": "OperationImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "isNull",
        "body": "false",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "integerValue",
        "body": "null",
        "type": "OperationImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": [
      "interactionConstraint",
      "owningUpper",
      "interactionUse",
      "timeExpression",
      "owningInstanceSpec",
      "activityEdge",
      "owningParameter",
      "valueSpecificationAction",
      "interval",
      "owningProperty",
      "valuePin",
      "owningSlot",
      "activityEdge",
      "interactionConstraint",
      "interactionUse",
      "joinNode",
      "objectNode",
      "interval",
      "message",
      "lifeline",
      "expression",
      "owningConstraint",
      "duration",
      "owningLower",
      "changeEvent"
    ]
  },
  {
    "name": "BehavioredClassifier",
    "expressions": [{
      "operations": {
        "oclAsSet": 2,
        "isEmpty": 1,
        "notEmpty": 1,
        "implies": 1
      },
      "name": "class_behavior",
      "body": "classifierBehavior->notEmpty() implies classifierBehavior.specification->isEmpty()",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 5,
        "VariableExpImpl": 2,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::Behavior::specification",
        "UML::BehavioredClassifier::classifierBehavior"
      ]
    }],
    "properties": [
      "ownedBehavior",
      "interfaceRealization",
      "classifierBehavior",
      "behavior"
    ]
  },
  {
    "name": "ReadStructuralFeatureAction",
    "expressions": [
      {
        "operations": {"compatibleWith": 1},
        "name": "multiplicity",
        "body": "structuralFeature.compatibleWith(result)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::ReadStructuralFeatureAction::result"
        ]
      },
      {
        "operations": {
          "and": 1,
          "=": 2
        },
        "name": "type_and_ordering",
        "body": "result.type =structuralFeature.type and \nresult.isOrdered = structuralFeature.isOrdered\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::ReadStructuralFeatureAction::result"
        ]
      }
    ],
    "properties": ["result"]
  },
  {
    "name": "StateInvariant",
    "expressions": [],
    "properties": [
      "covered",
      "invariant"
    ]
  },
  {
    "name": "ConnectionPointReference",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "entry_pseudostates",
        "body": "entry->forAll(kind = PseudostateKind::entryPoint)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::ConnectionPointReference::entry"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "exit_pseudostates",
        "body": "exit->forAll(kind = PseudostateKind::exitPoint)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::ConnectionPointReference::exit"
        ]
      }
    ],
    "properties": [
      "exit",
      "entry",
      "state"
    ]
  },
  {
    "name": "ClearAssociationAction",
    "expressions": [
      {
        "operations": {"conformsTo": 1},
        "name": "same_type",
        "body": "association.memberEnd->exists(self.object.type.conformsTo(type))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Association::memberEnd",
          "UML::ClearAssociationAction::association",
          "UML::ClearAssociationAction::object"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity",
        "body": "object.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ClearAssociationAction::object"]
      }
    ],
    "properties": [
      "association",
      "object"
    ]
  },
  {
    "name": "FinalNode",
    "expressions": [{
      "operations": {"isEmpty": 1},
      "name": "no_outgoing_edges",
      "body": "outgoing->isEmpty()",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::ActivityNode::outgoing"]
    }],
    "properties": []
  },
  {
    "name": "ReplyAction",
    "expressions": [
      {
        "operations": {"oclIsKindOf": 1},
        "name": "event_on_reply_to_call_trigger",
        "body": "replyToCall.event.oclIsKindOf(CallEvent)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReplyAction::replyToCall",
          "UML::Trigger::event"
        ]
      },
      {
        "operations": {
          "at": 6,
          "compatibleWith": 1,
          "size": 3,
          "and": 3,
          "conformsTo": 1,
          "=": 2,
          "oclAsType": 1,
          "outputParameters": 1
        },
        "name": "pins_match_parameter",
        "body": "let parameter:OrderedSet(Parameter) = replyToCall.event.oclAsType(CallEvent).operation.outputParameters() in\r\nreplyValue->size()=parameter->size() and\r\nSequence{1..replyValue->size()}->forAll(i |\r\n\treplyValue->at(i).type.conformsTo(parameter->at(i).type) and\r\n\treplyValue->at(i).isOrdered=parameter->at(i).isOrdered and\r\n\treplyValue->at(i).compatibleWith(parameter->at(i)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 16,
          "OperationCallExpImpl": 18,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "UML::ReplyAction::replyToCall",
          "UML::Trigger::event",
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::CallEvent::operation",
          "UML::ReplyAction::replyValue"
        ]
      }
    ],
    "properties": [
      "replyToCall",
      "returnInformation",
      "replyValue"
    ]
  },
  {
    "name": "Device",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Class",
    "expressions": [
      {
        "operations": {
          "general": 1,
          "oclIsKindOf": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "superClass",
        "body": "self.general()->select(oclIsKindOf(Class))->collect(oclAsType(Class))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "TypeExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {
          "not": 1,
          "and": 1,
          "isEmpty": 1,
          "implies": 1,
          "=": 1
        },
        "name": "passive_class",
        "body": "not isActive implies (ownedReception->isEmpty() and classifierBehavior = null)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Class::ownedReception",
          "UML::BehavioredClassifier::classifierBehavior",
          "UML::Class::isActive"
        ]
      },
      {
        "operations": {
          "or": 1,
          "allParents": 1,
          "allInstances": 1,
          "includes": 2,
          "oclAsType": 1
        },
        "name": "extension",
        "body": "Extension.allInstances()->select(ext | \r\n  let endTypes : Sequence(Classifier) = ext.memberEnd->collect(type.oclAsType(Classifier)) in\r\n  endTypes->includes(self) or endTypes.allParents()->includes(self) )",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 7,
          "LetExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Association::memberEnd"
        ]
      }
    ],
    "properties": [
      "isAbstract",
      "superClass",
      "nestedClassifier",
      "ownedReception",
      "ownedOperation",
      "isActive",
      "ownedAttribute",
      "class",
      "extension"
    ]
  },
  {
    "name": "TypedElement",
    "expressions": [],
    "properties": ["type"]
  },
  {
    "name": "UnlimitedNatural",
    "expressions": [],
    "properties": []
  },
  {
    "name": "InteractionUse",
    "expressions": [
      {
        "operations": {},
        "name": "arguments_are_constants",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "oclAsSet": 3,
          "notEmpty": 1,
          "implies": 1,
          "=": 1,
          "first": 2,
          "asSequence": 3
        },
        "name": "returnValue_type_recipient_correspondence",
        "body": "returnValue.type->asSequence()->notEmpty() implies returnValue.type->asSequence()->first() = returnValueRecipient.type->asSequence()->first()\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::InteractionUse::returnValueRecipient",
          "UML::TypedElement::type",
          "UML::InteractionUse::returnValue"
        ]
      },
      {
        "operations": {
          "size": 1,
          "oclIsKindOf": 4,
          "and": 5,
          "oclAsSet": 2,
          "includes": 1,
          "union": 1,
          "asSet": 3,
          "implies": 3,
          "oclAsType": 5,
          "=": 4
        },
        "name": "all_lifelines",
        "body": "let parentInteraction : Set(Interaction) = enclosingInteraction->asSet()->\r\nunion(enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->\r\ncollect(enclosingInteraction).oclAsType(Interaction)->asSet()) in\r\nparentInteraction->size()=1 and let refInteraction : Interaction = refersTo in\r\nparentInteraction.covered-> forAll(intLifeline : Lifeline | refInteraction.covered->\r\nforAll( refLifeline : Lifeline | refLifeline.represents = intLifeline.represents and \r\n(\r\n( refLifeline.selector.oclIsKindOf(LiteralString) implies\r\n  intLifeline.selector.oclIsKindOf(LiteralString) and \r\n  refLifeline.selector.oclAsType(LiteralString).value = intLifeline.selector.oclAsType(LiteralString).value ) and\r\n( refLifeline.selector.oclIsKindOf(LiteralInteger) implies\r\n  intLifeline.selector.oclIsKindOf(LiteralInteger) and \r\n  refLifeline.selector.oclAsType(LiteralInteger).value = intLifeline.selector.oclAsType(LiteralInteger).value )\r\n)\r\n implies self.covered->asSet()->includes(intLifeline)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "OperationCallExpImpl": 29,
          "VariableExpImpl": 22,
          "LetExpImpl": 2,
          "OppositePropertyCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 9,
          "PropertyCallExpImpl": 22
        },
        "properties": [
          "UML::InteractionFragment::enclosingOperand",
          "UML::InteractionUse::refersTo",
          "UML::LiteralString::value",
          "UML::InteractionFragment::covered",
          "UML::LiteralInteger::value",
          "UML::Lifeline::represents",
          "UML::InteractionFragment::enclosingInteraction",
          "UML::Lifeline::selector"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "allParents": 1,
          "includes": 1,
          "union": 1,
          "asSet": 4,
          "implies": 1,
          "notEmpty": 2,
          "oclAsType": 1
        },
        "name": "returnValueRecipient_coverage",
        "body": "returnValueRecipient->asSet()->notEmpty() implies\r\nlet covCE : Set(ConnectableElement) = covered.represents->asSet() in \r\ncovCE->notEmpty() and let classes:Set(Classifier) = covCE.type.oclIsKindOf(Classifier).oclAsType(Classifier)->asSet() in \r\nlet allProps : Set(Property) = classes.attribute->union(classes.allParents().attribute)->asSet() in \r\nallProps->includes(returnValueRecipient)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 7,
          "VariableExpImpl": 15,
          "OperationCallExpImpl": 14,
          "LetExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::InteractionUse::returnValueRecipient",
          "UML::Classifier::attribute",
          "UML::TypedElement::type",
          "UML::InteractionFragment::covered",
          "UML::Lifeline::represents"
        ]
      },
      {
        "operations": {},
        "name": "arguments_correspond_to_parameters",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "size": 2,
          "and": 1,
          "notEmpty": 1,
          "implies": 1,
          "=": 2,
          "matches": 2
        },
        "name": "gates_match",
        "body": "actualGate->notEmpty() implies \r\nrefersTo.formalGate->forAll( fg : Gate | self.actualGate->select(matches(fg))->size()=1) and\r\nself.actualGate->forAll(ag : Gate | refersTo.formalGate->select(matches(ag))->size()=1)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 9,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::InteractionUse::refersTo",
          "UML::Interaction::formalGate",
          "UML::InteractionUse::actualGate"
        ]
      }
    ],
    "properties": [
      "returnValueRecipient",
      "refersTo",
      "argument",
      "actualGate",
      "returnValue"
    ]
  },
  {
    "name": "TimeEvent",
    "expressions": [{
      "operations": {
        "integerValue": 1,
        ">=": 1
      },
      "name": "when_non_negative",
      "body": "when.integerValue() >= 0",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::TimeEvent::when"]
    }],
    "properties": [
      "isRelative",
      "when"
    ]
  },
  {
    "name": "FlowFinalNode",
    "expressions": [],
    "properties": []
  },
  {
    "name": "InformationFlow",
    "expressions": [
      {
        "operations": {},
        "name": "must_conform",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "or": 4,
          "oclIsKindOf": 5
        },
        "name": "convey_classifiers",
        "body": "self.conveyed->forAll(oclIsKindOf(Class) or oclIsKindOf(Interface)\r\n  or oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 6,
          "TypeExpImpl": 5,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InformationFlow::conveyed"]
      },
      {
        "operations": {
          "not": 2,
          "or": 24,
          "oclIsKindOf": 28,
          "and": 3,
          "oclAsType": 2
        },
        "name": "sources_and_targets_kind",
        "body": "(self.informationSource->forAll( sis |\r\n  oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact) or \r\n  oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) or \r\n  oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or oclIsKindOf(ActivityPartition) or \r\n  (oclIsKindOf(InstanceSpecification) and not sis.oclAsType(InstanceSpecification).classifier->exists(oclIsKindOf(Relationship))))) \r\n\r\nand\r\n\r\n(self.informationTarget->forAll( sit | \r\n  oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact) or \r\n  oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) or \r\n  oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or oclIsKindOf(ActivityPartition) or \r\n(oclIsKindOf(InstanceSpecification) and not sit.oclAsType(InstanceSpecification).classifier->exists(oclIsKindOf(Relationship)))))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 32,
          "OperationCallExpImpl": 59,
          "TypeExpImpl": 30,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::InstanceSpecification::classifier",
          "UML::InformationFlow::informationTarget",
          "UML::InformationFlow::informationSource"
        ]
      }
    ],
    "properties": [
      "conveyed",
      "realizingActivityEdge",
      "realizingConnector",
      "informationTarget",
      "realization",
      "informationSource",
      "realizingMessage"
    ]
  },
  {
    "name": "ValuePin",
    "expressions": [
      {
        "operations": {"isEmpty": 1},
        "name": "no_incoming_edges",
        "body": "incoming->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::incoming"]
      },
      {
        "operations": {"conformsTo": 1},
        "name": "compatible_type",
        "body": "value.type.conformsTo(type)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ValuePin::value"
        ]
      }
    ],
    "properties": ["value"]
  },
  {
    "name": "CommunicationPath",
    "expressions": [{
      "operations": {"oclIsKindOf": 1},
      "name": "association_ends",
      "body": "endType->forAll (oclIsKindOf(DeploymentTarget))",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::Association::endType"]
    }],
    "properties": []
  },
  {
    "name": "DestroyObjectAction",
    "expressions": [
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity",
        "body": "target.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::DestroyObjectAction::target"]
      },
      {
        "operations": {"=": 1},
        "name": "no_type",
        "body": "target.type= null",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::DestroyObjectAction::target",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": [
      "isDestroyLinks",
      "target",
      "isDestroyOwnedObjects"
    ]
  },
  {
    "name": "RedefinableTemplateSignature",
    "expressions": [
      {
        "operations": {
          "isEmpty": 1,
          "asSet": 1
        },
        "name": "inheritedParameter",
        "body": "if extendedSignature->isEmpty() then Set{} else extendedSignature.parameter->asSet() endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "CollectionLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::TemplateSignature::parameter",
          "UML::RedefinableTemplateSignature::extendedSignature"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "isConsistentWith",
        "body": "redefiningElement.oclIsKindOf(RedefinableTemplateSignature)",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "oclAsSet": 2,
          "allParents": 1,
          "includes": 1,
          "implies": 1,
          "notEmpty": 1
        },
        "name": "redefines_parents",
        "body": "classifier.allParents()->forAll(c | c.ownedTemplateSignature->notEmpty() implies self->closure(extendedSignature)->includes(c.ownedTemplateSignature))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 5,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::RedefinableTemplateSignature::extendedSignature",
          "UML::RedefinableTemplateSignature::classifier",
          "UML::Classifier::ownedTemplateSignature"
        ]
      }
    ],
    "properties": [
      "redefinableTemplateSignature",
      "extendedSignature",
      "inheritedParameter",
      "classifier"
    ]
  },
  {
    "name": "RaiseExceptionAction",
    "expressions": [],
    "properties": ["exception"]
  },
  {
    "name": "TimeInterval",
    "expressions": [],
    "properties": [
      "max",
      "timeConstraint",
      "min"
    ]
  },
  {
    "name": "ClearVariableAction",
    "expressions": [],
    "properties": []
  },
  {
    "name": "WriteStructuralFeatureAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "implies": 1,
          "=": 1
        },
        "name": "type_of_result",
        "body": "result <> null implies result.type = object.type",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::StructuralFeatureAction::object",
          "UML::TypedElement::type",
          "UML::WriteStructuralFeatureAction::result"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "is": 1,
          "toUnlimitedNatural": 1,
          "implies": 1
        },
        "name": "multiplicity_of_value",
        "body": "value<>null implies value.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::WriteStructuralFeatureAction::value"]
      },
      {
        "operations": {
          "<>": 1,
          "toUnlimitedNatural": 1,
          "is": 1,
          "implies": 1
        },
        "name": "multiplicity_of_result",
        "body": "result <> null implies result.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::WriteStructuralFeatureAction::result"]
      },
      {
        "operations": {
          "<>": 1,
          "conformsTo": 1,
          "implies": 1
        },
        "name": "type_of_value",
        "body": "value <> null implies value.type.conformsTo(structuralFeature.type)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::WriteStructuralFeatureAction::value"
        ]
      }
    ],
    "properties": [
      "result",
      "value"
    ]
  },
  {
    "name": "ReadLinkObjectEndAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "type_of_result",
        "body": "result.type = end.type",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ReadLinkObjectEndAction::end",
          "UML::ReadLinkObjectEndAction::result"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "property",
        "body": "end.association <> null",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReadLinkObjectEndAction::end",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_result",
        "body": "result.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkObjectEndAction::result"]
      },
      {
        "operations": {"=": 1},
        "name": "type_of_object",
        "body": "object.type = end.association",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ReadLinkObjectEndAction::end",
          "UML::ReadLinkObjectEndAction::object",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity_of_object",
        "body": "object.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkObjectEndAction::object"]
      },
      {
        "operations": {"not": 1},
        "name": "ends_of_association",
        "body": "end.association.memberEnd->forAll(e | not e.isStatic)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::Feature::isStatic",
          "UML::ReadLinkObjectEndAction::end",
          "UML::Property::association"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "association_of_association",
        "body": "end.association.oclIsKindOf(AssociationClass)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReadLinkObjectEndAction::end",
          "UML::Property::association"
        ]
      }
    ],
    "properties": [
      "end",
      "object",
      "result"
    ]
  },
  {
    "name": "ActivityParameterNode",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "same_type",
        "body": "type = parameter.type",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ActivityParameterNode::parameter"
        ]
      },
      {
        "operations": {
          "or": 1,
          "and": 1,
          "isEmpty": 1,
          "notEmpty": 1,
          "implies": 1,
          "=": 2
        },
        "name": "no_incoming_edges",
        "body": "(outgoing->notEmpty() and incoming->isEmpty()) implies \r\n\t(parameter.direction = ParameterDirectionKind::_'in' or \r\n\t parameter.direction = ParameterDirectionKind::inout)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::ActivityParameterNode::parameter",
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "or": 1,
          "isEmpty": 2
        },
        "name": "no_edges",
        "body": "incoming->isEmpty() or outgoing->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {"includes": 1},
        "name": "has_parameters",
        "body": "activity.ownedParameter->includes(parameter)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ActivityNode::activity",
          "UML::ActivityParameterNode::parameter",
          "UML::Behavior::ownedParameter"
        ]
      },
      {
        "operations": {
          "or": 2,
          "and": 1,
          "isEmpty": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 3
        },
        "name": "no_outgoing_edges",
        "body": "(incoming->notEmpty() and outgoing->isEmpty()) implies \r\n\t(parameter.direction = ParameterDirectionKind::out or \r\n\t parameter.direction = ParameterDirectionKind::inout or \r\n\t parameter.direction = ParameterDirectionKind::return)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 5,
          "EnumLiteralExpImpl": 3,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::ActivityParameterNode::parameter",
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming",
          "UML::Parameter::direction"
        ]
      }
    ],
    "properties": ["parameter"]
  },
  {
    "name": "Dependency",
    "expressions": [],
    "properties": [
      "collaborationUse",
      "client",
      "supplier"
    ]
  },
  {
    "name": "Abstraction",
    "expressions": [],
    "properties": ["mapping"]
  },
  {
    "name": "TemplateableElement",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "allOwnedElements": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "parameterableElements",
        "body": "self.allOwnedElements()->select(oclIsKindOf(ParameterableElement)).oclAsType(ParameterableElement)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {"<>": 1},
        "name": "isTemplate",
        "body": "ownedTemplateSignature <> null",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::TemplateableElement::ownedTemplateSignature"]
      }
    ],
    "properties": [
      "ownedTemplateSignature",
      "templateBinding"
    ]
  },
  {
    "name": "Operation",
    "expressions": [
      {
        "operations": {
          "returnResult": 2,
          "notEmpty": 1
        },
        "name": "isUnique",
        "body": "if returnResult()->notEmpty() then returnResult()->exists(isUnique) else true endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 1,
          "BooleanLiteralExpImpl": 1
        },
        "properties": ["UML::MultiplicityElement::isUnique"]
      },
      {
        "operations": {
          "returnResult": 2,
          "notEmpty": 1
        },
        "name": "upper",
        "body": "if returnResult()->notEmpty() then returnResult()->any(true).upper else null endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 1,
          "BooleanLiteralExpImpl": 1
        },
        "properties": ["UML::MultiplicityElement::upper"]
      },
      {
        "operations": {
          "at": 2,
          "or": 2,
          "size": 3,
          "compatibleWith": 4,
          "oclIsKindOf": 1,
          "and": 9,
          "conformsTo": 2,
          "implies": 3,
          "=": 8,
          "oclAsType": 1
        },
        "name": "isConsistentWith",
        "body": "redefiningElement.oclIsKindOf(Operation) and\r\nlet op : Operation = redefiningElement.oclAsType(Operation) in\r\n\tself.ownedParameter->size() = op.ownedParameter->size() and\r\n\tSequence{1..self.ownedParameter->size()}->\r\n\t\tforAll(i |  \r\n\t\t  let redefiningParam : Parameter = op.ownedParameter->at(i),\r\n               redefinedParam : Parameter = self.ownedParameter->at(i) in\r\n                 (redefiningParam.isUnique = redefinedParam.isUnique) and\r\n                 (redefiningParam.isOrdered = redefinedParam. isOrdered) and\r\n                 (redefiningParam.direction = redefinedParam.direction) and\r\n                 (redefiningParam.type.conformsTo(redefinedParam.type) or\r\n                     redefinedParam.type.conformsTo(redefiningParam.type)) and\r\n                 (redefiningParam.direction = ParameterDirectionKind::inout implies\r\n                         (redefinedParam.compatibleWith(redefiningParam) and\r\n                         redefiningParam.compatibleWith(redefinedParam))) and\r\n                 (redefiningParam.direction = ParameterDirectionKind::_'in' implies\r\n                         redefinedParam.compatibleWith(redefiningParam)) and\r\n                 ((redefiningParam.direction = ParameterDirectionKind::out or\r\n                      redefiningParam.direction = ParameterDirectionKind::return) implies\r\n                         redefiningParam.compatibleWith(redefinedParam))\r\n\t\t)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 35,
          "VariableExpImpl": 31,
          "LetExpImpl": 3,
          "EnumLiteralExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 19
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::Operation::ownedParameter",
          "UML::Parameter::direction",
          "UML::MultiplicityElement::isUnique"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "returnResult",
        "body": "ownedParameter->select (direction = ParameterDirectionKind::return)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Operation::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "returnResult": 2,
          "notEmpty": 1
        },
        "name": "isOrdered",
        "body": "if returnResult()->notEmpty() then returnResult()-> exists(isOrdered) else false endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "IfExpImpl": 1,
          "BooleanLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::MultiplicityElement::isOrdered"]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "=": 1
        },
        "name": "at_most_one_return",
        "body": "self.ownedParameter->select(direction = ParameterDirectionKind::return)->size() <= 1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Operation::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "returnResult": 2,
          "notEmpty": 1
        },
        "name": "lower",
        "body": "if returnResult()->notEmpty() then returnResult()->any(true).lower else null endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "BooleanLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::MultiplicityElement::lower"]
      },
      {
        "operations": {
          "returnResult": 2,
          "notEmpty": 1
        },
        "name": "type",
        "body": "if returnResult()->notEmpty() then returnResult()->any(true).type else null endif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "BooleanLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::TypedElement::type"]
      },
      {
        "operations": {
          "<>": 1,
          "implies": 1
        },
        "name": "only_body_for_query",
        "body": "bodyCondition <> null implies isQuery",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Operation::bodyCondition",
          "UML::Operation::isQuery"
        ]
      }
    ],
    "properties": [
      "callEvent",
      "operation",
      "callOperationAction",
      "type",
      "ownedParameter",
      "isQuery",
      "isUnique",
      "redefinedOperation",
      "protocolTransition",
      "lower",
      "postcondition",
      "upper",
      "artifact",
      "precondition",
      "bodyCondition",
      "class",
      "datatype",
      "raisedException",
      "interface",
      "isOrdered",
      "templateParameter"
    ]
  },
  {
    "name": "VisibilityKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ExecutionSpecification",
    "expressions": [{
      "operations": {"=": 1},
      "name": "same_lifeline",
      "body": "start.covered = finish.covered",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "UML::ExecutionSpecification::finish",
        "UML::ExecutionSpecification::start",
        "UML::OccurrenceSpecification::covered"
      ]
    }],
    "properties": [
      "finish",
      "start",
      "executionOccurrenceSpecification"
    ]
  },
  {
    "name": "Extension",
    "expressions": [
      {
        "operations": {
          "metaclassEnd": 1,
          "oclAsType": 1
        },
        "name": "metaclass",
        "body": "metaclassEnd().type.oclAsType(Class)",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::TypedElement::type"]
      },
      {
        "operations": {
          "metaclassEnd": 2,
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "non_owned_end",
        "body": "metaclassEnd()->notEmpty() and metaclassEnd().type.oclIsKindOf(Class)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::TypedElement::type"]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "includes": 1,
          "oclAsType": 1
        },
        "name": "metaclassEnd",
        "body": "memberEnd->reject(p | ownedEnd->includes(p.oclAsType(ExtensionEnd)))->any(true)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "UML::Extension::ownedEnd",
          "UML::Association::memberEnd"
        ]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "is_binary",
        "body": "memberEnd->size() = 2",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Association::memberEnd"]
      },
      {
        "operations": {
          "lowerBound": 1,
          "=": 1
        },
        "name": "isRequired",
        "body": "ownedEnd.lowerBound() = 1",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Extension::ownedEnd"]
      }
    ],
    "properties": [
      "ownedEnd",
      "isRequired",
      "metaclass"
    ]
  },
  {
    "name": "Image",
    "expressions": [],
    "properties": [
      "stereotype",
      "format",
      "content",
      "location"
    ]
  },
  {
    "name": "DeploymentTarget",
    "expressions": [{
      "operations": {
        "oclIsKindOf": 1,
        "asSet": 1,
        "oclAsType": 1
      },
      "name": "deployedElement",
      "body": "deployment.deployedArtifact->select(oclIsKindOf(Artifact))->collect(oclAsType(Artifact).manifestation)->collect(utilizedElement)->asSet()",
      "type": "OperationImpl",
      "constructs": {
        "IteratorExpImpl": 4,
        "VariableExpImpl": 5,
        "OperationCallExpImpl": 3,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "UML::Artifact::manifestation",
        "UML::Manifestation::utilizedElement",
        "UML::DeploymentTarget::deployment",
        "UML::Deployment::deployedArtifact"
      ]
    }],
    "properties": [
      "deployedElement",
      "deployment"
    ]
  },
  {
    "name": "TransitionKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "InformationItem",
    "expressions": [
      {
        "operations": {
          "and": 1,
          "isEmpty": 2
        },
        "name": "has_no",
        "body": "self.generalization->isEmpty() and self.feature->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Classifier::feature",
          "UML::Classifier::generalization"
        ]
      },
      {
        "operations": {
          "or": 4,
          "oclIsKindOf": 6,
          "and": 2,
          "includes": 2
        },
        "name": "sources_and_targets",
        "body": "(self.represented->select(oclIsKindOf(InformationItem))->forAll(p |\r\n  p.conveyingFlow.source->forAll(q | self.conveyingFlow.source->includes(q)) and\r\n    p.conveyingFlow.target->forAll(q | self.conveyingFlow.target->includes(q)))) and\r\n      (self.represented->forAll(oclIsKindOf(Class) or oclIsKindOf(Interface) or\r\n        oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 9,
          "OperationCallExpImpl": 14,
          "VariableExpImpl": 18,
          "OppositePropertyCallExpImpl": 4,
          "TypeExpImpl": 6,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::DirectedRelationship::source",
          "UML::DirectedRelationship::target",
          "UML::InformationItem::represented"
        ]
      },
      {
        "operations": {},
        "name": "not_instantiable",
        "body": "isAbstract",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Classifier::isAbstract"]
      }
    ],
    "properties": ["represented"]
  },
  {
    "name": "FunctionBehavior",
    "expressions": [
      {
        "operations": {
          "or": 2,
          "size": 1,
          "=": 3,
          ">=": 1
        },
        "name": "one_output_parameter",
        "body": "self.ownedParameter->\r\n  select(p | p.direction = ParameterDirectionKind::out or p.direction= ParameterDirectionKind::inout or p.direction= ParameterDirectionKind::return)->size() >= 1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 7,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "oclIsTypeOf": 1,
          "and": 2,
          "oclAsType": 1,
          "hasAllDataTypeAttributes": 1
        },
        "name": "types_of_parameters",
        "body": "ownedParameter->forAll(p | p.type <> null and\r\n  p.type.oclIsTypeOf(DataType) and hasAllDataTypeAttributes(p.type.oclAsType(DataType)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Behavior::ownedParameter"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsType": 1,
          "hasAllDataTypeAttributes": 1
        },
        "name": "hasAllDataTypeAttributes",
        "body": "d.ownedAttribute->forAll(a |\r\n    a.type.oclIsKindOf(DataType) and\r\n      hasAllDataTypeAttributes(a.type.oclAsType(DataType)))",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 4,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::DataType::ownedAttribute"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Lifeline",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2,
          "oclAsSet": 1,
          "notEmpty": 1,
          "implies": 1
        },
        "name": "selector_int_or_string",
        "body": "self.selector->notEmpty() implies \r\nself.selector.oclIsKindOf(LiteralInteger) or \r\nself.selector.oclIsKindOf(LiteralString)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": ["UML::Lifeline::selector"]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "includes": 1
        },
        "name": "same_classifier",
        "body": "represents.namespace->closure(namespace)->includes(interaction._'context')",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Behavior::context",
          "UML::Lifeline::interaction",
          "UML::NamedElement::namespace",
          "UML::Lifeline::represents"
        ]
      },
      {
        "operations": {
          "isMultivalued": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "notEmpty": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "selector_specified",
        "body": " self.selector->notEmpty() = (self.represents.oclIsKindOf(MultiplicityElement) and self.represents.oclAsType(MultiplicityElement).isMultivalued())",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Lifeline::represents",
          "UML::Lifeline::selector"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 12,
          "and": 8,
          "excluding": 1,
          "oclAsSet": 2,
          "union": 2,
          "implies": 5,
          "asSet": 6,
          "oclAsType": 12,
          "=": 6
        },
        "name": "interaction_uses_share_lifeline",
        "body": "let intUses : Set(InteractionUse) = interaction.interactionUse  in \r\nintUses->forAll\r\n( iuse : InteractionUse | \r\nlet usingInteraction : Set(Interaction)  = iuse.enclosingInteraction->asSet()\r\n->union(\r\niuse.enclosingOperand.combinedFragment->asSet()->closure(enclosingOperand.combinedFragment).enclosingInteraction->asSet()\r\n               ) \r\nin\r\nlet peerUses : Set(InteractionUse) = usingInteraction.fragment->select(oclIsKindOf(InteractionUse)).oclAsType(InteractionUse)->asSet()\r\n->union(\r\nusingInteraction.fragment->select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)->asSet()\r\n->closure(operand.fragment->select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)).operand.fragment->\r\nselect(oclIsKindOf(InteractionUse)).oclAsType(InteractionUse)->asSet()\r\n               )->excluding(iuse)\r\n in\r\npeerUses->forAll( peerUse : InteractionUse |\r\n peerUse.refersTo.lifeline->forAll( l : Lifeline | (l.represents = self.represents and \r\n ( self.selector.oclIsKindOf(LiteralString) implies\r\n  l.selector.oclIsKindOf(LiteralString) and \r\n  self.selector.oclAsType(LiteralString).value = l.selector.oclAsType(LiteralString).value )\r\n  and \r\n( self.selector.oclIsKindOf(LiteralInteger) implies\r\n  l.selector.oclIsKindOf(LiteralInteger) and \r\n  self.selector.oclAsType(LiteralInteger).value = l.selector.oclAsType(LiteralInteger).value )\r\n)  \r\nimplies\r\n usingInteraction.lifeline->exists(represents = self.represents and\r\n ( self.selector.oclIsKindOf(LiteralString) implies\r\n  l.selector.oclIsKindOf(LiteralString) and \r\n  self.selector.oclAsType(LiteralString).value = l.selector.oclAsType(LiteralString).value )\r\nand \r\n( self.selector.oclIsKindOf(LiteralInteger) implies\r\n  l.selector.oclIsKindOf(LiteralInteger) and \r\n  self.selector.oclAsType(LiteralInteger).value = l.selector.oclAsType(LiteralInteger).value )\r\n)\r\n                                                )\r\n                    )\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 21,
          "OperationCallExpImpl": 54,
          "VariableExpImpl": 47,
          "LetExpImpl": 3,
          "OppositePropertyCallExpImpl": 3,
          "TypeExpImpl": 24,
          "PropertyCallExpImpl": 42
        },
        "properties": [
          "UML::InteractionOperand::fragment",
          "UML::InteractionFragment::enclosingOperand",
          "UML::InteractionUse::refersTo",
          "UML::Interaction::lifeline",
          "UML::Lifeline::interaction",
          "UML::LiteralString::value",
          "UML::LiteralInteger::value",
          "UML::CombinedFragment::operand",
          "UML::Lifeline::represents",
          "UML::InteractionFragment::enclosingInteraction",
          "UML::Interaction::fragment",
          "UML::Lifeline::selector"
        ]
      }
    ],
    "properties": [
      "events",
      "coveredBy",
      "stateInvariant",
      "interaction",
      "represents",
      "decomposedAs",
      "selector"
    ]
  },
  {
    "name": "PackageMerge",
    "expressions": [],
    "properties": [
      "receivingPackage",
      "mergedPackage"
    ]
  },
  {
    "name": "DurationConstraint",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "size": 2,
          "=": 2
        },
        "name": "has_one_or_two_constrainedElements",
        "body": "constrainedElement->size() = 1 or constrainedElement->size()=2",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Constraint::constrainedElement"]
      },
      {
        "operations": {
          "size": 3,
          "=": 3
        },
        "name": "first_event_multiplicity",
        "body": "if (constrainedElement->size() = 2)\r\n  then (firstEvent->size() = 2) else (firstEvent->size() = 0) \r\nendif",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Constraint::constrainedElement",
          "UML::DurationConstraint::firstEvent"
        ]
      }
    ],
    "properties": [
      "specification",
      "firstEvent"
    ]
  },
  {
    "name": "Property",
    "expressions": [
      {
        "operations": {
          "and": 1,
          "allFeatures": 1,
          "allParents": 1,
          "includes": 1,
          "notEmpty": 2,
          "implies": 1,
          "asSet": 2
        },
        "name": "redefined_property_inherited",
        "body": "(redefinedProperty->notEmpty()) implies\r\n  (redefinitionContext->notEmpty() and\r\n      redefinedProperty->forAll(rp|\r\n        ((redefinitionContext->collect(fc|\r\n          fc.allParents()))->asSet())->collect(c| c.allFeatures())->asSet()->includes(rp)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 7,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::RedefinableElement::redefinitionContext",
          "UML::Property::redefinedProperty"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "upperBound": 4,
          "and": 2,
          "oclAsSet": 2,
          "conformsTo": 1,
          "implies": 1,
          "notEmpty": 2
        },
        "name": "subsetting_rules",
        "body": "subsettedProperty->forAll(sp |\n  self.type.conformsTo(sp.type) and\n    ((self.upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies\n      self.upperBound() <= sp.upperBound() ))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 7,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Property::subsettedProperty"
        ]
      },
      {
        "operations": {
          "not": 1,
          "or": 1,
          "oclAsSet": 1,
          "isEmpty": 1,
          "includes": 1
        },
        "name": "isNavigable",
        "body": "not classifier->isEmpty() or association.navigableOwnedEnd->includes(self)",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "OppositePropertyCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Association::navigableOwnedEnd",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "<>": 1,
          "upperBound": 1,
          "and": 1,
          "implies": 1
        },
        "name": "multiplicity_of_composite",
        "body": "isComposite and association <> null implies opposite.upperBound() <= 1\r\n\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Property::opposite",
          "UML::Property::isComposite",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "and": 1,
          "conformsTo": 1,
          "implies": 1,
          "oclAsType": 1,
          "oclType": 1
        },
        "name": "isCompatibleWith",
        "body": "self.oclIsKindOf(p.oclType()) and (p.oclIsKindOf(TypedElement) implies\r\nself.type.conformsTo(p.oclAsType(TypedElement).type))",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 5,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::TypedElement::type"]
      },
      {
        "operations": {"implies": 1},
        "name": "derived_union_is_read_only",
        "body": "isDerivedUnion implies isReadOnly",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::StructuralFeature::isReadOnly",
          "UML::Property::isDerivedUnion"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "isAttribute": 2,
          "and": 2,
          "notEmpty": 1,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "binding_to_attribute",
        "body": "(self.isAttribute()\r\nand (templateParameterSubstitution->notEmpty())\r\nimplies (templateParameterSubstitution->forAll(ts |\r\n    ts.formal.oclIsKindOf(Property)\r\n    and ts.formal.oclAsType(Property).isAttribute())))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 5,
          "OppositePropertyCallExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::TemplateParameterSubstitution::formal"]
      },
      {
        "operations": {
          "and": 1,
          "oclAsSet": 2,
          "isEmpty": 1,
          "notEmpty": 1,
          "implies": 1,
          "=": 1
        },
        "name": "type_of_opposite_end",
        "body": "(opposite->notEmpty() and owningAssociation->isEmpty()) implies classifier = opposite.type",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4,
          "OppositePropertyCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Property::owningAssociation",
          "UML::TypedElement::type",
          "UML::Property::opposite"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "allInstances": 1,
          "notEmpty": 1,
          "implies": 1,
          "=": 1
        },
        "name": "deployment_target",
        "body": "deployment->notEmpty() implies owner.oclIsKindOf(Node) and Node.allInstances()->exists(n | n.part->exists(p | p = self))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 5,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::StructuredClassifier::part",
          "UML::Element::owner",
          "UML::DeploymentTarget::deployment"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "isComposite",
        "body": "aggregation = AggregationKind::composite",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Property::aggregation"]
      },
      {
        "operations": {
          "subsettingContext": 3,
          "and": 1,
          "conformsTo": 1,
          "notEmpty": 2,
          "implies": 1
        },
        "name": "subsetting_context_conforms",
        "body": "subsettedProperty->notEmpty() implies\n  (subsettingContext()->notEmpty() and subsettingContext()->forAll (sc |\n    subsettedProperty->forAll(sp |\n      sp.subsettingContext()->exists(c | sc.conformsTo(c)))))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 8,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Property::subsettedProperty"]
      },
      {
        "operations": {"implies": 1},
        "name": "derived_union_is_derived",
        "body": "isDerivedUnion implies isDerived",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Property::isDerivedUnion",
          "UML::Property::isDerived"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "excluding": 1,
          "oclAsSet": 1,
          "asSet": 2
        },
        "name": "subsettingContext",
        "body": "if association <> null\nthen association.memberEnd->excluding(self)->collect(type)->asSet()\nelse \n  if classifier<>null\n  then classifier->asSet()\n  else Set{} \n  endif\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 6,
          "OppositePropertyCallExpImpl": 2,
          "NullLiteralExpImpl": 2,
          "CollectionLiteralExpImpl": 1,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Association::memberEnd",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "oclIsKindOf": 1,
          "upperBound": 2,
          "and": 6,
          "oclAsSet": 4,
          "lowerBound": 6,
          "conformsTo": 1,
          "implies": 3,
          "notEmpty": 4,
          "oclAsType": 1,
          ">=": 1
        },
        "name": "isConsistentWith",
        "body": "redefiningElement.oclIsKindOf(Property) and \n  let prop : Property = redefiningElement.oclAsType(Property) in \n  (prop.type.conformsTo(self.type) and \n  ((prop.lowerBound()->notEmpty() and self.lowerBound()->notEmpty()) implies prop.lowerBound() >= self.lowerBound()) and \n  ((prop.upperBound()->notEmpty() and self.upperBound()->notEmpty()) implies prop.lowerBound() <= self.lowerBound()) and \n  (self.isComposite implies prop.isComposite))",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 30,
          "VariableExpImpl": 14,
          "LetExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Property::isComposite"
        ]
      },
      {
        "operations": {
          "not": 1,
          "isEmpty": 1,
          "oclAsSet": 1
        },
        "name": "isAttribute",
        "body": "not classifier->isEmpty()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 1,
          "OppositePropertyCallExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 2,
          "implies": 1
        },
        "name": "qualified_is_association_end",
        "body": "qualifier->notEmpty() implies association->notEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Property::association",
          "UML::Property::qualifier"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "subsetted_property_names",
        "body": "subsettedProperty->forAll(sp | sp.name <> name)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::NamedElement::name",
          "UML::Property::subsettedProperty"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "size": 1,
          "and": 1,
          "=": 1
        },
        "name": "opposite",
        "body": "if association <> null and association.memberEnd->size() = 2\nthen\n    association.memberEnd->any(e | e <> self)\nelse\n    null\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::Property::association"
        ]
      }
    ],
    "properties": [
      "associationEnd",
      "redefinedProperty",
      "connectorEnd",
      "association",
      "qualifierValue",
      "property",
      "isID",
      "opposite",
      "isDerivedUnion",
      "readLinkObjectEndAction",
      "connectorEnd",
      "property",
      "classifier",
      "property",
      "owningSignal",
      "datatype",
      "linkEndData",
      "subsettedProperty",
      "isDerived",
      "association",
      "owningAssociation",
      "class",
      "structuredClassifier",
      "structuredClassifier",
      "interactionUse",
      "artifact",
      "interface",
      "isComposite",
      "defaultValue",
      "aggregation",
      "readLinkObjectEndQualifierAction",
      "qualifier"
    ]
  },
  {
    "name": "StartObjectBehaviorAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "behavior": 1
        },
        "name": "type_of_object",
        "body": "self.behavior()<>null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "behavior": 1,
          "outputParameters": 1
        },
        "name": "outputParameters",
        "body": "self.behavior().outputParameters()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "behavior": 1,
          "inputParameters": 1
        },
        "name": "inputParameters",
        "body": "self.behavior().inputParameters()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "oclAsType": 2
        },
        "name": "behavior",
        "body": "if object.type.oclIsKindOf(Behavior) then\r\n  object.type.oclAsType(Behavior)\r\nelse if object.type.oclIsKindOf(BehavioredClassifier) then\r\n  object.type.oclAsType(BehavioredClassifier).classifierBehavior\r\nelse\r\n  null\r\nendif\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 4,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::BehavioredClassifier::classifierBehavior",
          "UML::StartObjectBehaviorAction::object"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "isEmpty": 1
        },
        "name": "no_onport",
        "body": "onPort->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InvocationAction::onPort"]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_object",
        "body": "object.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::StartObjectBehaviorAction::object"]
      }
    ],
    "properties": ["object"]
  },
  {
    "name": "CallAction",
    "expressions": [
      {
        "operations": {
          "implies": 1,
          "notEmpty": 1
        },
        "name": "synchronous_call",
        "body": "result->notEmpty() implies isSynchronous",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::CallAction::isSynchronous",
          "UML::CallAction::result"
        ]
      },
      {
        "operations": {
          "at": 6,
          "compatibleWith": 1,
          "size": 3,
          "and": 3,
          "conformsTo": 1,
          "=": 2,
          "outputParameters": 1
        },
        "name": "result_pins",
        "body": "let parameter: OrderedSet(Parameter) = self.outputParameters() in\r\nresult->size() = parameter->size() and\r\nSequence{1..result->size()}->forAll(i | \r\n\tparameter->at(i).type.conformsTo(result->at(i).type) and \r\n\tparameter->at(i).isOrdered = result->at(i).isOrdered and\r\n\tparameter->at(i).compatibleWith(result->at(i)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 16,
          "OperationCallExpImpl": 17,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::CallAction::result"
        ]
      },
      {
        "operations": {
          "at": 6,
          "size": 3,
          "compatibleWith": 1,
          "and": 3,
          "conformsTo": 1,
          "=": 2,
          "inputParameters": 1
        },
        "name": "argument_pins",
        "body": "let parameter: OrderedSet(Parameter) = self.inputParameters() in\r\nargument->size() = parameter->size() and\r\nSequence{1..argument->size()}->forAll(i | \r\n\targument->at(i).type.conformsTo(parameter->at(i).type) and \r\n\targument->at(i).isOrdered = parameter->at(i).isOrdered and\r\n\targument->at(i).compatibleWith(parameter->at(i)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 16,
          "OperationCallExpImpl": 17,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::InvocationAction::argument",
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": [
      "isSynchronous",
      "result"
    ]
  },
  {
    "name": "Signal",
    "expressions": [],
    "properties": [
      "broadcastSignalAction",
      "sendSignalAction",
      "signalEvent",
      "ownedAttribute",
      "reception"
    ]
  },
  {
    "name": "SignalEvent",
    "expressions": [],
    "properties": ["signal"]
  },
  {
    "name": "ControlFlow",
    "expressions": [{
      "operations": {
        "oclIsKindOf": 2,
        "and": 1,
        "implies": 2,
        "oclAsType": 2
      },
      "name": "object_nodes",
      "body": "(source.oclIsKindOf(ObjectNode) implies source.oclAsType(ObjectNode).isControlType) and \r\n(target.oclIsKindOf(ObjectNode) implies target.oclAsType(ObjectNode).isControlType)",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 7,
        "VariableExpImpl": 4,
        "TypeExpImpl": 4,
        "PropertyCallExpImpl": 6
      },
      "properties": [
        "UML::ActivityEdge::target",
        "UML::ObjectNode::isControlType",
        "UML::ActivityEdge::source"
      ]
    }],
    "properties": []
  },
  {
    "name": "ExecutableNode",
    "expressions": [],
    "properties": [
      "loopNode",
      "clause",
      "clause",
      "handler",
      "exceptionHandler",
      "loopNode",
      "sequenceNode",
      "loopNode"
    ]
  },
  {
    "name": "StructuralFeature",
    "expressions": [],
    "properties": [
      "isReadOnly",
      "structuralFeatureAction",
      "slot"
    ]
  },
  {
    "name": "NamedElement",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsSet": 1,
          "union": 1,
          "allOwningPackages": 1,
          "oclAsType": 1
        },
        "name": "allOwningPackages",
        "body": "if namespace.oclIsKindOf(Package)\r\nthen\r\n  let owningPackage : Package = namespace.oclAsType(Package) in\r\n    owningPackage->union(owningPackage.allOwningPackages())\r\nelse\r\n  null\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::NamedElement::namespace"]
      },
      {
        "operations": {
          "getNamesOfMember": 2,
          "or": 1,
          "oclIsKindOf": 2,
          "intersection": 1,
          "isEmpty": 1,
          "implies": 1,
          "oclType": 2
        },
        "name": "isDistinguishableFrom",
        "body": "(self.oclIsKindOf(n.oclType()) or n.oclIsKindOf(self.oclType())) implies\n    ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->isEmpty()\n",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 8
        },
        "properties": []
      },
      {
        "operations": {
          "<>": 1,
          "allNamespaces": 2,
          "and": 1,
          "isEmpty": 1,
          "concat": 2,
          "separator": 1,
          "=": 1
        },
        "name": "qualifiedName",
        "body": "if self.name <> null and self.allNamespaces()->select( ns | ns.name=null )->isEmpty()\nthen \n    self.allNamespaces()->iterate( ns : Namespace; agg: String = self.name | ns.name.concat(self.separator()).concat(agg))\nelse\n   null\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 8,
          "NullLiteralExpImpl": 3,
          "IterateExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": ["UML::NamedElement::name"]
      },
      {
        "operations": {
          "allNamespaces": 2,
          "oclIsKindOf": 2,
          "and": 1,
          "prepend": 2,
          "isEmpty": 1,
          "oclAsSet": 1,
          "oclAsType": 3
        },
        "name": "allNamespaces",
        "body": "if owner.oclIsKindOf(TemplateParameter) and\n  owner.oclAsType(TemplateParameter).signature.template.oclIsKindOf(Namespace) then\n    let enclosingNamespace : Namespace =\n      owner.oclAsType(TemplateParameter).signature.template.oclAsType(Namespace) in\n        enclosingNamespace.allNamespaces()->prepend(enclosingNamespace)\nelse\n  if namespace->isEmpty()\n    then OrderedSet{}\n  else\n    namespace.allNamespaces()->prepend(namespace)\n  endif\nendif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 8,
          "LetExpImpl": 1,
          "TypeExpImpl": 5,
          "CollectionLiteralExpImpl": 1,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::TemplateSignature::template",
          "UML::TemplateParameter::signature",
          "UML::NamedElement::namespace",
          "UML::Element::owner"
        ]
      },
      {
        "operations": {
          "allNamespaces": 2,
          "<>": 1,
          "and": 1,
          "isEmpty": 1,
          "concat": 2,
          "implies": 1,
          "=": 2,
          "separator": 1
        },
        "name": "has_qualified_name",
        "body": "(name <> null and allNamespaces()->select(ns | ns.name = null)->isEmpty()) implies\n  qualifiedName = allNamespaces()->iterate( ns : Namespace; agg: String = name | ns.name.concat(self.separator()).concat(agg))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 9,
          "OperationCallExpImpl": 11,
          "NullLiteralExpImpl": 2,
          "IterateExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::NamedElement::qualifiedName",
          "UML::NamedElement::name"
        ]
      },
      {
        "operations": {
          "allInstances": 1,
          "includes": 1
        },
        "name": "clientDependency",
        "body": "Dependency.allInstances()->select(d | d.client->includes(self))",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Dependency::client"]
      },
      {
        "operations": {
          "<>": 1,
          "and": 1,
          "implies": 1,
          "=": 2
        },
        "name": "visibility_needs_ownership",
        "body": "(namespace = null and owner <> null) implies visibility = null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Element::owner",
          "UML::NamedElement::namespace",
          "UML::NamedElement::visibility"
        ]
      },
      {
        "operations": {
          "allNamespaces": 1,
          "or": 1,
          "notEmpty": 1,
          "implies": 1,
          "=": 3
        },
        "name": "has_no_qualified_name",
        "body": "name=null or allNamespaces()->select( ns | ns.name=null )->notEmpty() implies qualifiedName = null",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 7,
          "NullLiteralExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::NamedElement::qualifiedName",
          "UML::NamedElement::name"
        ]
      },
      {
        "operations": {},
        "name": "separator",
        "body": "'::'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": [
      "informationFlow",
      "supplierDependency",
      "qualifiedName",
      "clientDependency",
      "durationObservation",
      "memberNamespace",
      "visibility",
      "message",
      "name",
      "inheritingClassifier",
      "nameExpression",
      "considerIgnoreFragment",
      "namespace",
      "timeObservation",
      "informationFlow"
    ]
  },
  {
    "name": "LinkAction",
    "expressions": [
      {
        "operations": {
          "association": 1,
          "asBag": 1,
          "=": 1
        },
        "name": "same_association",
        "body": "endData.end = self.association().memberEnd->asBag()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::Association::memberEnd",
          "UML::LinkAction::endData"
        ]
      },
      {
        "operations": {"not": 1},
        "name": "not_static",
        "body": "endData->forAll(not end.isStatic)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::Feature::isStatic",
          "UML::LinkAction::endData"
        ]
      },
      {
        "operations": {
          "allPins": 1,
          "asBag": 1,
          "=": 1
        },
        "name": "same_pins",
        "body": "inputValue->asBag()=endData.allPins()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::LinkAction::inputValue",
          "UML::LinkAction::endData"
        ]
      },
      {
        "operations": {
          "first": 1,
          "asSequence": 1
        },
        "name": "association",
        "body": "endData->asSequence()->first().end.association",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::LinkAction::endData",
          "UML::Property::association"
        ]
      }
    ],
    "properties": [
      "inputValue",
      "endData"
    ]
  },
  {
    "name": "ParameterableElement",
    "expressions": [
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "isTemplateParameter",
        "body": "templateParameter->notEmpty()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ParameterableElement::templateParameter"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclType": 1
        },
        "name": "isCompatibleWith",
        "body": "self.oclIsKindOf(p.oclType())",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2
        },
        "properties": []
      }
    ],
    "properties": [
      "templateParameterSubstitution",
      "templateParameter",
      "templateParameter",
      "templateParameter",
      "owningTemplateParameterSubstitution",
      "owningTemplateParameter"
    ]
  },
  {
    "name": "ActionExecutionSpecification",
    "expressions": [{
      "operations": {
        "or": 1,
        "size": 1,
        "and": 2,
        "oclAsSet": 5,
        "union": 1,
        "notEmpty": 2,
        "asSet": 3,
        "oclAsType": 2,
        "=": 2
      },
      "name": "action_referenced",
      "body": "(enclosingInteraction->notEmpty() or enclosingOperand.combinedFragment->notEmpty()) and\r\nlet parentInteraction : Set(Interaction) = enclosingInteraction.oclAsType(Interaction)->asSet()->union(\r\nenclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->\r\ncollect(enclosingInteraction).oclAsType(Interaction)->asSet()) in\r\n(parentInteraction->size() = 1) and self.action.interaction->asSet() = parentInteraction",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 3,
        "OperationCallExpImpl": 19,
        "VariableExpImpl": 10,
        "LetExpImpl": 1,
        "OppositePropertyCallExpImpl": 4,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 7
      },
      "properties": [
        "UML::InteractionFragment::enclosingOperand",
        "UML::ActionExecutionSpecification::action",
        "UML::InteractionFragment::enclosingInteraction"
      ]
    }],
    "properties": ["action"]
  },
  {
    "name": "Stereotype",
    "expressions": [
      {
        "operations": {"containingProfile": 1},
        "name": "profile",
        "body": "self.containingProfile()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {},
        "name": "base_property_upper_bound",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "not": 2,
          "oclIsKindOf": 2,
          "and": 2,
          "oclAsSet": 1,
          "notEmpty": 1,
          "=": 1
        },
        "name": "associationEndOwnership",
        "body": "ownedAttribute\r\n->select(association->notEmpty() and not association.oclIsKindOf(Extension) and not type.oclIsKindOf(Stereotype))\r\n->forAll(opposite.owner = association)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 6,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::Property::opposite",
          "UML::Class::ownedAttribute",
          "UML::Element::owner",
          "UML::Property::association"
        ]
      },
      {
        "operations": {},
        "name": "base_property_multiplicity_single_extension",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "binaryAssociationsOnly",
        "body": "ownedAttribute.association->forAll(memberEnd->size()=2)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::Class::ownedAttribute",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "oclAsType": 1,
          "containingProfile": 1
        },
        "name": "containingProfile",
        "body": "self.namespace.oclAsType(Package).containingProfile()",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::NamedElement::namespace"]
      },
      {
        "operations": {
          "oclIsKindOf": 3,
          "and": 1,
          "allParents": 2,
          "allInstances": 1,
          "implies": 1
        },
        "name": "generalize",
        "body": "allParents()->forAll(oclIsKindOf(Stereotype)) \r\nand Classifier.allInstances()->forAll(c | c.allParents()->exists(oclIsKindOf(Stereotype)) implies c.oclIsKindOf(Stereotype))\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 5,
          "TypeExpImpl": 4
        },
        "properties": []
      },
      {
        "operations": {},
        "name": "name_not_clash",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {},
        "name": "base_property_multiplicity_multiple_extension",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      }
    ],
    "properties": [
      "owningPackage",
      "profile",
      "extensionEnd",
      "icon"
    ]
  },
  {
    "name": "SendObjectAction",
    "expressions": [{
      "operations": {
        "<>": 1,
        "allFeatures": 1,
        "includes": 1,
        "implies": 1,
        "oclAsType": 1
      },
      "name": "type_target_pin",
      "body": "onPort<>null implies target.type.oclAsType(Classifier).allFeatures()->includes(onPort)",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 5,
        "VariableExpImpl": 3,
        "NullLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "UML::TypedElement::type",
        "UML::SendObjectAction::target",
        "UML::InvocationAction::onPort"
      ]
    }],
    "properties": [
      "target",
      "request"
    ]
  },
  {
    "name": "DecisionNode",
    "expressions": [
      {
        "operations": {
          "<>": 2,
          "size": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "implies": 1,
          "inputParameters": 1,
          "=": 1
        },
        "name": "incoming_control_one_input_parameter",
        "body": "(decisionInput<>null and decisionInputFlow<>null and incoming->exists(oclIsKindOf(ControlFlow))) implies\r\n\tdecisionInput.inputParameters()->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInput",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "size": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "implies": 1,
          "=": 2,
          "inputParameters": 1
        },
        "name": "incoming_object_one_input_parameter",
        "body": "(decisionInput<>null and decisionInputFlow=null and incoming->forAll(oclIsKindOf(ObjectFlow))) implies\r\n\tdecisionInput.inputParameters()->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 9,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInput",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2,
          "excluding": 1,
          "oclAsSet": 1,
          "union": 1,
          "notEmpty": 1
        },
        "name": "edges",
        "body": "let allEdges: Set(ActivityEdge) = incoming->union(outgoing) in\r\nlet allRelevantEdges: Set(ActivityEdge) = if decisionInputFlow->notEmpty() then allEdges->excluding(decisionInputFlow) else allEdges endif in\r\nallRelevantEdges->forAll(oclIsKindOf(ControlFlow)) or allRelevantEdges->forAll(oclIsKindOf(ObjectFlow))\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 10,
          "OperationCallExpImpl": 7,
          "LetExpImpl": 2,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "isEmpty": 1,
          "implies": 1,
          "=": 1,
          "inputParameters": 1
        },
        "name": "zero_input_parameters",
        "body": "(decisionInput<>null and decisionInputFlow=null and incoming->exists(oclIsKindOf(ControlFlow))) implies\r\n   decisionInput.inputParameters()->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 8,
          "NullLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInput",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "size": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "implies": 1,
          "=": 1,
          "inputParameters": 1
        },
        "name": "two_input_parameters",
        "body": "(decisionInput<>null and decisionInputFlow<>null and incoming->forAll(oclIsKindOf(ObjectFlow))) implies\r\n\tdecisionInput.inputParameters()->size()=2",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 9,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInput",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {
          "or": 1,
          "size": 3,
          "and": 1,
          "=": 2,
          ">": 1
        },
        "name": "incoming_outgoing_edges",
        "body": "(incoming->size() = 1 or incoming->size() = 2) and outgoing->size() > 0",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {"includes": 1},
        "name": "decision_input_flow_incoming",
        "body": "incoming->includes(decisionInputFlow)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {
          "<>": 4,
          "and": 2,
          "implies": 1
        },
        "name": "parameters",
        "body": "decisionInput<>null implies \r\n  (decisionInput.ownedParameter->forAll(par | \r\n     par.direction <> ParameterDirectionKind::out and \r\n     par.direction <> ParameterDirectionKind::inout ) and\r\n   decisionInput.ownedParameter->one(par | \r\n     par.direction <> ParameterDirectionKind::return))\r\n     ",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 7,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 3,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::DecisionNode::decisionInput",
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction"
        ]
      }
    ],
    "properties": [
      "decisionInput",
      "decisionInputFlow"
    ]
  },
  {
    "name": "TemplateParameterSubstitution",
    "expressions": [{
      "operations": {
        "oclAsSet": 1,
        "isCompatibleWith": 1
      },
      "name": "must_be_compatible",
      "body": "actual->forAll(a | a.isCompatibleWith(formal.parameteredElement))",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 2,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::TemplateParameterSubstitution::actual",
        "UML::TemplateParameterSubstitution::formal",
        "UML::TemplateParameter::parameteredElement"
      ]
    }],
    "properties": [
      "actual",
      "formal",
      "ownedActual",
      "templateBinding"
    ]
  },
  {
    "name": "Actor",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "or": 1,
          "size": 1,
          "oclIsKindOf": 3,
          "and": 2,
          "allInstances": 1,
          "includes": 1,
          "implies": 1,
          "=": 2
        },
        "name": "associations",
        "body": "Association.allInstances()->forAll( a |\n  a.memberEnd->collect(type)->includes(self) implies\n  (\n    a.memberEnd->size() = 2 and\n    let actorEnd : Property = a.memberEnd->any(type = self) in\n      actorEnd.opposite.class.oclIsKindOf(UseCase) or\n      ( actorEnd.opposite.class.oclIsKindOf(Class) and not\n         actorEnd.opposite.class.oclIsKindOf(Behavior))\n      )\n  )",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 10,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 11
        },
        "properties": [
          "UML::Property::class",
          "UML::TypedElement::type",
          "UML::Association::memberEnd",
          "UML::Property::opposite"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "must_have_name",
        "body": "name->notEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::NamedElement::name"]
      }
    ],
    "properties": []
  },
  {
    "name": "ExtensionPoint",
    "expressions": [{
      "operations": {
        "oclAsSet": 1,
        "notEmpty": 1
      },
      "name": "must_have_name",
      "body": "name->notEmpty ()",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 2,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::NamedElement::name"]
    }],
    "properties": [
      "useCase",
      "extension"
    ]
  },
  {
    "name": "Manifestation",
    "expressions": [],
    "properties": [
      "artifact",
      "utilizedElement"
    ]
  },
  {
    "name": "Deployment",
    "expressions": [],
    "properties": [
      "configuration",
      "deployedArtifact",
      "location"
    ]
  },
  {
    "name": "LinkEndData",
    "expressions": [
      {
        "operations": {
          "excludesAll": 1,
          "oclAsSet": 1
        },
        "name": "end_object_input_pin",
        "body": "value->excludesAll(qualifier.value)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::QualifierValue::value",
          "UML::LinkEndData::value",
          "UML::LinkEndData::qualifier"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "property_is_association_end",
        "body": "end.association <> null",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "asBag": 1,
          "union": 1
        },
        "name": "allPins",
        "body": "value->asBag()->union(qualifier.value)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::QualifierValue::value",
          "UML::LinkEndData::value",
          "UML::LinkEndData::qualifier"
        ]
      },
      {
        "operations": {"includesAll": 1},
        "name": "qualifiers",
        "body": "end.qualifier->includesAll(qualifier.qualifier)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::LinkEndData::qualifier",
          "UML::QualifierValue::qualifier",
          "UML::Property::qualifier"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "toUnlimitedNatural": 1,
          "is": 1,
          "implies": 1
        },
        "name": "multiplicity",
        "body": "value<>null implies value.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::LinkEndData::value"]
      },
      {
        "operations": {
          "<>": 1,
          "conformsTo": 1,
          "implies": 1
        },
        "name": "same_type",
        "body": "value<>null implies value.type.conformsTo(end.type)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::TypedElement::type",
          "UML::LinkEndData::value"
        ]
      }
    ],
    "properties": [
      "end",
      "linkAction",
      "value",
      "qualifier"
    ]
  },
  {
    "name": "DestroyLinkAction",
    "expressions": [],
    "properties": ["endData"]
  },
  {
    "name": "ReadExtentAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "type_is_classifier",
        "body": "result.type = classifier",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ReadExtentAction::classifier",
          "UML::ReadExtentAction::result"
        ]
      },
      {
        "operations": {"is": 1},
        "name": "multiplicity_of_result",
        "body": "result.is(0,*)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "UnlimitedNaturalLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadExtentAction::result"]
      }
    ],
    "properties": [
      "classifier",
      "result"
    ]
  },
  {
    "name": "Activity",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "size": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "implies": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "maximum_one_parameter_node",
        "body": "ownedParameter->forAll(p | \r\n   p.direction <> ParameterDirectionKind::inout implies node->select(\r\n       oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter = p)->size()= 1)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 6,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityParameterNode::parameter",
          "UML::Activity::node",
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "<=": 2,
          "size": 3,
          "oclIsKindOf": 1,
          "and": 3,
          "implies": 1,
          "notEmpty": 2,
          "=": 3,
          "oclAsType": 1
        },
        "name": "maximum_two_parameter_nodes",
        "body": "ownedParameter->forAll(p | \r\np.direction = ParameterDirectionKind::inout implies\r\nlet associatedNodes : Set(ActivityNode) = node->select(\r\n       oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter = p) in \r\n  associatedNodes->size()=2 and\r\n  associatedNodes->select(incoming->notEmpty())->size()<=1 and\r\n  associatedNodes->select(outgoing->notEmpty())->size()<=1\r\n)\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 16,
          "VariableExpImpl": 11,
          "LetExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::ActivityParameterNode::parameter",
          "UML::ActivityNode::outgoing",
          "UML::Activity::node",
          "UML::ActivityNode::incoming",
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction"
        ]
      }
    ],
    "properties": [
      "variable",
      "partition",
      "isSingleExecution",
      "node",
      "structuredNode",
      "group",
      "isReadOnly",
      "edge"
    ]
  },
  {
    "name": "InitialNode",
    "expressions": [
      {
        "operations": {"oclIsKindOf": 1},
        "name": "control_edges",
        "body": "outgoing->forAll(oclIsKindOf(ControlFlow))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::outgoing"]
      },
      {
        "operations": {"isEmpty": 1},
        "name": "no_incoming_edges",
        "body": "incoming->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::incoming"]
      }
    ],
    "properties": []
  },
  {
    "name": "MessageEvent",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Node",
    "expressions": [{
      "operations": {"oclIsKindOf": 1},
      "name": "internal_structure",
      "body": "part->forAll(oclIsKindOf(Node))",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 2,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::StructuredClassifier::part"]
    }],
    "properties": [
      "node",
      "nestedNode"
    ]
  },
  {
    "name": "RealObject",
    "expressions": [],
    "properties": []
  },
  {
    "name": "EnumerationLiteral",
    "expressions": [{
      "operations": {},
      "name": "classifier",
      "body": "enumeration",
      "type": "OperationImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::EnumerationLiteral::enumeration"]
    }],
    "properties": [
      "enumeration",
      "classifier"
    ]
  },
  {
    "name": "PrimitiveType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "MessageEnd",
    "expressions": [
      {
        "operations": {
          "oclAsSet": 1,
          "includes": 1,
          "asSet": 1
        },
        "name": "isReceive",
        "body": "message.receiveEvent->asSet()->includes(self)",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Message::receiveEvent",
          "UML::MessageEnd::message"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "includes": 1,
          "asSet": 1
        },
        "name": "isSend",
        "body": "message.sendEvent->asSet()->includes(self)",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Message::sendEvent",
          "UML::MessageEnd::message"
        ]
      },
      {
        "operations": {
          "isActual": 1,
          "oclIsKindOf": 3,
          "isFormal": 1,
          "asOrderedSet": 2,
          "isOutsideCF": 1,
          "oclAsSet": 12,
          "union": 2,
          "asSet": 8,
          "notEmpty": 2,
          "oclAsType": 10,
          "isInsideCF": 1,
          "first": 2
        },
        "name": "enclosingFragment",
        "body": "if self->select(oclIsKindOf(Gate))->notEmpty() \r\nthen -- it is a Gate\r\nlet endGate : Gate = \r\n  self->select(oclIsKindOf(Gate)).oclAsType(Gate)->asOrderedSet()->first()\r\n  in\r\n  if endGate.isOutsideCF() \r\n  then endGate.combinedFragment.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->\r\n     union(endGate.combinedFragment.enclosingOperand.oclAsType(InteractionFragment)->asSet())\r\n  else if endGate.isInsideCF() \r\n    then endGate.combinedFragment.oclAsType(InteractionFragment)->asSet()\r\n    else if endGate.isFormal() \r\n      then endGate.interaction.oclAsType(InteractionFragment)->asSet()\r\n      else if endGate.isActual() \r\n        then endGate.interactionUse.enclosingInteraction.oclAsType(InteractionFragment)->asSet()->\r\n     union(endGate.interactionUse.enclosingOperand.oclAsType(InteractionFragment)->asSet())\r\n        else null\r\n        endif\r\n      endif\r\n    endif\r\n  endif\r\nelse -- it is a MessageOccurrenceSpecification\r\nlet endMOS : MessageOccurrenceSpecification  = \r\n  self->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() \r\n  in\r\n  if endMOS.enclosingInteraction->notEmpty() \r\n  then endMOS.enclosingInteraction.oclAsType(InteractionFragment)->asSet()\r\n  else endMOS.enclosingOperand.oclAsType(InteractionFragment)->asSet()\r\n  endif\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 5,
          "OperationCallExpImpl": 45,
          "VariableExpImpl": 21,
          "LetExpImpl": 2,
          "OppositePropertyCallExpImpl": 6,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 13,
          "IfExpImpl": 6,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::InteractionFragment::enclosingOperand",
          "UML::InteractionFragment::enclosingInteraction"
        ]
      },
      {
        "operations": {
          "excluding": 1,
          "oclAsSet": 1,
          "asSet": 2
        },
        "name": "oppositeEnd",
        "body": "message->asSet().messageEnd->asSet()->excluding(self)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "OppositePropertyCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::MessageEnd::message"]
      }
    ],
    "properties": [
      "endMessage",
      "message",
      "endMessage"
    ]
  },
  {
    "name": "Duration",
    "expressions": [{
      "operations": {
        "size": 1,
        "oclIsKindOf": 1,
        "and": 1,
        "implies": 1,
        "=": 2
      },
      "name": "no_expr_requires_observation",
      "body": "expr = null implies (observation->size() = 1 and observation->forAll(oclIsKindOf(DurationObservation)))",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 4,
        "NullLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::Duration::observation",
        "UML::Duration::expr"
      ]
    }],
    "properties": [
      "durationInterval",
      "observation",
      "durationInterval",
      "expr"
    ]
  },
  {
    "name": "MergeNode",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2,
          "union": 1
        },
        "name": "edges",
        "body": "let allEdges : Set(ActivityEdge) = incoming->union(outgoing) in\r\nallEdges->forAll(oclIsKindOf(ControlFlow)) or allEdges->forAll(oclIsKindOf(ObjectFlow))\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 4,
          "LetExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "one_outgoing_edge",
        "body": "outgoing->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::outgoing"]
      }
    ],
    "properties": []
  },
  {
    "name": "Generalization",
    "expressions": [],
    "properties": [
      "general",
      "generalizationSet",
      "isSubstitutable",
      "specific"
    ]
  },
  {
    "name": "Behavior",
    "expressions": [
      {
        "operations": {
          "or": 2,
          "=": 3
        },
        "name": "outputParameters",
        "body": "ownedParameter->select(direction=ParameterDirectionKind::out or direction=ParameterDirectionKind::inout or direction=ParameterDirectionKind::return)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5,
          "EnumLiteralExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "behavioredClassifier": 1,
          "<>": 2,
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsType": 2
        },
        "name": "context",
        "body": "if nestingClass <> null then\r\n    null\r\nelse\r\n    let b:BehavioredClassifier = self.behavioredClassifier(self.owner) in\r\n    if b.oclIsKindOf(Behavior) and b.oclAsType(Behavior)._'context' <> null then \r\n        b.oclAsType(Behavior)._'context'\r\n    else \r\n        b \r\n    endif\r\nendif\r\n        ",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 7,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 3,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 3,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Behavior::context",
          "UML::Element::owner"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "most_one_behavior",
        "body": "specification <> null implies _'context'.ownedBehavior->select(specification=self.specification)->size() = 1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::BehavioredClassifier::ownedBehavior",
          "UML::Behavior::specification",
          "UML::Behavior::context"
        ]
      },
      {
        "operations": {
          "or": 1,
          "=": 2
        },
        "name": "inputParameters",
        "body": "ownedParameter->select(direction=ParameterDirectionKind::_'in' or direction=ParameterDirectionKind::inout)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "size": 2,
          "implies": 1,
          "=": 1
        },
        "name": "parameters_match",
        "body": "specification <> null implies ownedParameter->size() = specification.ownedParameter->size()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Behavior::specification",
          "UML::BehavioralFeature::ownedParameter",
          "UML::Behavior::ownedParameter"
        ]
      },
      {
        "operations": {"includes": 1},
        "name": "feature_of_context_classifier",
        "body": "_'context'.feature->includes(specification)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Behavior::specification",
          "UML::Behavior::context",
          "UML::Classifier::feature"
        ]
      }
    ],
    "properties": [
      "state",
      "objectNode",
      "behaviorExecutionSpecification",
      "context",
      "redefinedBehavior",
      "ownedParameterSet",
      "objectFlow",
      "behavior",
      "isReentrant",
      "ownedParameter",
      "behavioredClassifier",
      "opaqueExpression",
      "callBehaviorAction",
      "specification",
      "connector",
      "objectFlow",
      "state",
      "decisionNode",
      "behavioredClassifier",
      "transition",
      "postcondition",
      "state",
      "reduceAction",
      "precondition"
    ]
  },
  {
    "name": "TimeObservation",
    "expressions": [],
    "properties": [
      "event",
      "firstEvent"
    ]
  },
  {
    "name": "ObjectFlow",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "oclIsKindOf": 1,
          "implies": 1
        },
        "name": "selection_behavior",
        "body": "selection<>null implies source.oclIsKindOf(ObjectNode)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ObjectFlow::selection",
          "UML::ActivityEdge::source"
        ]
      },
      {
        "operations": {},
        "name": "same_upper_bounds",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "not": 1,
          "<>": 1,
          "size": 2,
          "and": 3,
          "is": 1,
          "implies": 1,
          "inputParameters": 2,
          "=": 2,
          "outputParameters": 1
        },
        "name": "input_and_output_parameter",
        "body": "selection<>null implies\r\n\tselection.inputParameters()->size()=1 and\r\n\tselection.inputParameters()->forAll(not isUnique and is(0,*)) and\r\n\tselection.outputParameters()->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 14,
          "VariableExpImpl": 6,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 3,
          "UnlimitedNaturalLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ObjectFlow::selection",
          "UML::MultiplicityElement::isUnique"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "size": 2,
          "and": 1,
          "implies": 1,
          "inputParameters": 1,
          "=": 2,
          "outputParameters": 1
        },
        "name": "transformation_behavior",
        "body": "transformation<>null implies\r\n\ttransformation.inputParameters()->size()=1 and\r\n\ttransformation.outputParameters()->size()=1",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": ["UML::ObjectFlow::transformation"]
      },
      {
        "operations": {
          "not": 1,
          "or": 1,
          "oclIsKindOf": 2
        },
        "name": "no_executable_nodes",
        "body": "not (source.oclIsKindOf(ExecutableNode) or target.oclIsKindOf(ExecutableNode))",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityEdge::target",
          "UML::ActivityEdge::source"
        ]
      },
      {
        "operations": {},
        "name": "compatible_types",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "not": 1,
          "and": 1
        },
        "name": "is_multicast_or_is_multireceive",
        "body": "not (isMulticast and isMultireceive)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ObjectFlow::isMulticast",
          "UML::ObjectFlow::isMultireceive"
        ]
      },
      {
        "operations": {},
        "name": "target",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      }
    ],
    "properties": [
      "selection",
      "decisionNode",
      "isMulticast",
      "isMultireceive",
      "transformation"
    ]
  },
  {
    "name": "TemplateBinding",
    "expressions": [
      {
        "operations": {"includes": 1},
        "name": "parameter_substitution_formal",
        "body": "parameterSubstitution->forAll(b | signature.parameter->includes(b.formal))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TemplateBinding::parameterSubstitution",
          "UML::TemplateParameterSubstitution::formal",
          "UML::TemplateSignature::parameter",
          "UML::TemplateBinding::signature"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "=": 1
        },
        "name": "one_parameter_substitution",
        "body": "signature.parameter->forAll(p | parameterSubstitution->select(b | b.formal = p)->size() <= 1)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TemplateBinding::parameterSubstitution",
          "UML::TemplateParameterSubstitution::formal",
          "UML::TemplateSignature::parameter",
          "UML::TemplateBinding::signature"
        ]
      }
    ],
    "properties": [
      "parameterSubstitution",
      "signature",
      "boundElement"
    ]
  },
  {
    "name": "Variable",
    "expressions": [{
      "operations": {
        "<>": 1,
        "oclBadOperation": 1,
        "includes": 1,
        "allOwnedNodes": 1,
        "=": 1
      },
      "name": "isAccessibleBy",
      "body": "if scope<>null then scope.allOwnedNodes()->includes(a)\nelse a.containingActivity()=activityScope\nendif",
      "type": "OperationImpl",
      "constructs": {
        "VariableExpImpl": 5,
        "OperationCallExpImpl": 5,
        "NullLiteralExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::Variable::activityScope",
        "UML::Variable::scope"
      ]
    }],
    "properties": [
      "variableAction",
      "activityScope",
      "scope"
    ]
  },
  {
    "name": "Pin",
    "expressions": [
      {
        "operations": {"not": 1},
        "name": "not_unique",
        "body": "not isUnique",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::MultiplicityElement::isUnique"]
      },
      {
        "operations": {"implies": 1},
        "name": "control_pins",
        "body": "isControl implies isControlType",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Pin::isControl",
          "UML::ObjectNode::isControlType"
        ]
      }
    ],
    "properties": ["isControl"]
  },
  {
    "name": "OperationTemplateParameter",
    "expressions": [{
      "operations": {
        "at": 2,
        "size": 3,
        "oclIsKindOf": 1,
        "and": 7,
        "oclAsSet": 1,
        "implies": 1,
        "notEmpty": 1,
        "=": 7,
        "oclAsType": 1
      },
      "name": "match_default_signature",
      "body": "default->notEmpty() implies (default.oclIsKindOf(Operation) and (let defaultOp : Operation = default.oclAsType(Operation) in \r\n    defaultOp.ownedParameter->size() = parameteredElement.ownedParameter->size() and\r\n    Sequence{1.. defaultOp.ownedParameter->size()}->forAll( ix | \r\n        let p1: Parameter = defaultOp.ownedParameter->at(ix), p2 : Parameter = parameteredElement.ownedParameter->at(ix) in\r\n          p1.type = p2.type and p1.upper = p2.upper and p1.lower = p2.lower and p1.direction = p2.direction and p1.isOrdered = p2.isOrdered and p1.isUnique = p2.isUnique)))",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 24,
        "VariableExpImpl": 22,
        "LetExpImpl": 3,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 2,
        "CollectionLiteralExpImpl": 1,
        "PropertyCallExpImpl": 22
      },
      "properties": [
        "UML::MultiplicityElement::isOrdered",
        "UML::TypedElement::type",
        "UML::MultiplicityElement::lower",
        "UML::MultiplicityElement::upper",
        "UML::OperationTemplateParameter::parameteredElement",
        "UML::Operation::ownedParameter",
        "UML::Parameter::direction",
        "UML::TemplateParameter::default",
        "UML::MultiplicityElement::isUnique"
      ]
    }],
    "properties": ["parameteredElement"]
  },
  {
    "name": "ReadIsClassifiedObjectAction",
    "expressions": [
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_output",
        "body": "result.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadIsClassifiedObjectAction::result"]
      },
      {
        "operations": {"=": 1},
        "name": "boolean_result",
        "body": "result.type = Boolean",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ReadIsClassifiedObjectAction::result"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "no_type",
        "body": "object.type = null",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReadIsClassifiedObjectAction::object",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity_of_input",
        "body": "object.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadIsClassifiedObjectAction::object"]
      }
    ],
    "properties": [
      "classifier",
      "object",
      "isDirect",
      "result"
    ]
  },
  {
    "name": "BehavioralFeature",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "=": 2
        },
        "name": "inputParameters",
        "body": "ownedParameter->select(direction=ParameterDirectionKind::_'in' or direction=ParameterDirectionKind::inout)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::BehavioralFeature::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "or": 2,
          "=": 3
        },
        "name": "outputParameters",
        "body": "ownedParameter->select(direction=ParameterDirectionKind::out or direction=ParameterDirectionKind::inout or direction=ParameterDirectionKind::return)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5,
          "EnumLiteralExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::BehavioralFeature::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "isEmpty": 1,
          "implies": 1
        },
        "name": "abstract_no_method",
        "body": "isAbstract implies method->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::BehavioralFeature::isAbstract",
          "UML::BehavioralFeature::method"
        ]
      },
      {
        "operations": {
          "getNamesOfMember": 2,
          "including": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "intersection": 1,
          "notEmpty": 1,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "isDistinguishableFrom",
        "body": "(n.oclIsKindOf(BehavioralFeature) and ns.getNamesOfMember(self)->intersection(ns.getNamesOfMember(n))->notEmpty()) implies\n  Set{self}->including(n.oclAsType(BehavioralFeature))->isUnique(ownedParameter->collect(p|\n  Tuple { name=p.name, type=p.type,effect=p.effect,direction=p.direction,isException=p.isException,\n              isStream=p.isStream,isOrdered=p.isOrdered,isUnique=p.isUnique,lower=p.lower, upper=p.upper }))\n  ",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 18,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 11
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::BehavioralFeature::ownedParameter",
          "UML::TypedElement::type",
          "UML::Parameter::effect",
          "UML::Parameter::isStream",
          "UML::MultiplicityElement::lower",
          "UML::MultiplicityElement::upper",
          "UML::NamedElement::name",
          "UML::Parameter::isException",
          "UML::MultiplicityElement::isUnique",
          "UML::Parameter::direction"
        ]
      }
    ],
    "properties": [
      "ownedParameterSet",
      "isAbstract",
      "ownedParameter",
      "concurrency",
      "raisedException",
      "method"
    ]
  },
  {
    "name": "Reception",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "same_name_as_signal",
        "body": "name = signal.name",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::NamedElement::name",
          "UML::Reception::signal"
        ]
      },
      {
        "operations": {
          "at": 9,
          "size": 3,
          "upperBound": 2,
          "and": 5,
          "lowerBound": 2,
          "=": 6
        },
        "name": "same_structure_as_signal",
        "body": "signal.ownedAttribute->size() = ownedParameter->size() and\r\nSequence{1..signal.ownedAttribute->size()}->forAll( i | \r\n    ownedParameter->at(i).direction = ParameterDirectionKind::_'in' and \r\n    ownedParameter->at(i).name = signal.ownedAttribute->at(i).name and\r\n    ownedParameter->at(i).type = signal.ownedAttribute->at(i).type and\r\n    ownedParameter->at(i).lowerBound() = signal.ownedAttribute->at(i).lowerBound() and\r\n    ownedParameter->at(i).upperBound() = signal.ownedAttribute->at(i).upperBound()\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 21,
          "OperationCallExpImpl": 27,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 23
        },
        "properties": [
          "UML::BehavioralFeature::ownedParameter",
          "UML::TypedElement::type",
          "UML::NamedElement::name",
          "UML::Signal::ownedAttribute",
          "UML::Reception::signal",
          "UML::Parameter::direction"
        ]
      }
    ],
    "properties": [
      "signal",
      "class",
      "interface"
    ]
  },
  {
    "name": "BroadcastSignalAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "no_onport",
        "body": "onPort=null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InvocationAction::onPort"]
      },
      {
        "operations": {
          "at": 6,
          "compatibleWith": 1,
          "size": 1,
          "and": 2,
          "allAttributes": 1,
          "conformsTo": 1,
          "=": 1
        },
        "name": "type_ordering_multiplicity",
        "body": "let attribute: OrderedSet(Property) = signal.allAttributes() in\r\nSequence{1..argument->size()}->forAll(i | \r\n\targument->at(i).type.conformsTo(attribute->at(i).type) and \r\n\targument->at(i).isOrdered = attribute->at(i).isOrdered and\r\n\targument->at(i).compatibleWith(attribute->at(i)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 14,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::InvocationAction::argument",
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::BroadcastSignalAction::signal"
        ]
      },
      {
        "operations": {
          "size": 2,
          "allAttributes": 1,
          "=": 1
        },
        "name": "number_of_arguments",
        "body": "argument->size() = signal.allAttributes()->size()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::InvocationAction::argument",
          "UML::BroadcastSignalAction::signal"
        ]
      }
    ],
    "properties": ["signal"]
  },
  {
    "name": "ChangeEvent",
    "expressions": [],
    "properties": ["changeExpression"]
  },
  {
    "name": "CentralBufferNode",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ControlNode",
    "expressions": [],
    "properties": []
  },
  {
    "name": "RemoveStructuralFeatureValueAction",
    "expressions": [{
      "operations": {
        "not": 2,
        "<>": 2,
        "and": 6,
        "is": 1,
        "toUnlimitedNatural": 1,
        "=": 3
      },
      "name": "removeAt_and_value",
      "body": "if structuralFeature.isOrdered and not structuralFeature.isUnique and  not isRemoveDuplicates then\r\n  value = null and\r\n  removeAt <> null and\r\n  removeAt.type = UnlimitedNatural and\r\n  removeAt.is(1,1)\r\nelse\r\n  removeAt = null and value <> null\r\nendif",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 9,
        "OperationCallExpImpl": 15,
        "NullLiteralExpImpl": 4,
        "IntegerLiteralExpImpl": 2,
        "TypeExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 12
      },
      "properties": [
        "UML::MultiplicityElement::isOrdered",
        "UML::TypedElement::type",
        "UML::RemoveStructuralFeatureValueAction::removeAt",
        "UML::StructuralFeatureAction::structuralFeature",
        "UML::RemoveStructuralFeatureValueAction::isRemoveDuplicates",
        "UML::WriteStructuralFeatureAction::value",
        "UML::MultiplicityElement::isUnique"
      ]
    }],
    "properties": [
      "removeAt",
      "isRemoveDuplicates"
    ]
  },
  {
    "name": "ActivityGroup",
    "expressions": [
      {
        "operations": {
          "and": 3,
          "excludesAll": 4,
          "oclAsSet": 2
        },
        "name": "not_contained",
        "body": "subgroup->closure(subgroup).containedNode->excludesAll(containedNode) and\r\nsuperGroup->closure(superGroup).containedNode->excludesAll(containedNode) and \r\nsubgroup->closure(subgroup).containedEdge->excludesAll(containedEdge) and \r\nsuperGroup->closure(superGroup).containedEdge->excludesAll(containedEdge)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 8,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 16,
          "PropertyCallExpImpl": 16
        },
        "properties": [
          "UML::ActivityGroup::containedEdge",
          "UML::ActivityGroup::superGroup",
          "UML::ActivityGroup::containedNode",
          "UML::ActivityGroup::subgroup"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "containingActivity": 1
        },
        "name": "containingActivity",
        "body": "if superGroup<>null then superGroup.containingActivity()\r\nelse inActivity\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ActivityGroup::superGroup",
          "UML::ActivityGroup::inActivity"
        ]
      },
      {
        "operations": {
          "and": 1,
          "=": 2,
          "containingActivity": 2
        },
        "name": "nodes_and_edges",
        "body": "containedNode->forAll(activity = self.containingActivity()) and \r\ncontainedEdge->forAll(activity = self.containingActivity())",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 5,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityGroup::containedEdge",
          "UML::ActivityNode::activity",
          "UML::ActivityGroup::containedNode",
          "UML::ActivityEdge::activity"
        ]
      }
    ],
    "properties": [
      "containedEdge",
      "superGroup",
      "containedNode",
      "subgroup",
      "inActivity"
    ]
  },
  {
    "name": "WriteLinkAction",
    "expressions": [{
      "operations": {
        "<>": 1,
        "or": 2,
        "and": 2,
        "conformsTo": 1,
        "oclAsType": 1,
        "=": 3
      },
      "name": "allow_access",
      "body": "endData.end->exists(end |\r\n  end.type=_'context' or\r\n  end.visibility=VisibilityKind::public or \r\n  end.visibility=VisibilityKind::protected and\r\n  endData.end->exists(other | \r\n    other<>end and _'context'.conformsTo(other.type.oclAsType(Classifier))))\r\n",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 4,
        "VariableExpImpl": 12,
        "OperationCallExpImpl": 10,
        "EnumLiteralExpImpl": 2,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 10
      },
      "properties": [
        "UML::Action::context",
        "UML::LinkEndData::end",
        "UML::TypedElement::type",
        "UML::NamedElement::visibility",
        "UML::LinkAction::endData"
      ]
    }],
    "properties": []
  },
  {
    "name": "LinkEndDestructionData",
    "expressions": [
      {
        "operations": {
          "allPins": 1,
          "including": 1
        },
        "name": "allPins",
        "body": "self.LinkEndData::allPins()->including(destroyAt)",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::LinkEndDestructionData::destroyAt"]
      },
      {
        "operations": {
          "<>": 1,
          "not": 1,
          "or": 2,
          "and": 2,
          "oclAsSet": 1,
          "toUnlimitedNatural": 1,
          "is": 1,
          "=": 2
        },
        "name": "destroyAt_pin",
        "body": "if  not end.isOrdered or end.isUnique or isDestroyDuplicates\r\nthen destroyAt = null\r\nelse\r\n\tdestroyAt <> null and \r\n\tdestroyAt->forAll(type=UnlimitedNatural and is(1,1))\r\nendif\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 8,
          "OperationCallExpImpl": 11,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::LinkEndDestructionData::isDestroyDuplicates",
          "UML::LinkEndDestructionData::destroyAt",
          "UML::MultiplicityElement::isUnique"
        ]
      }
    ],
    "properties": [
      "isDestroyDuplicates",
      "destroyAt",
      "destroyLinkAction"
    ]
  },
  {
    "name": "LiteralNull",
    "expressions": [
      {
        "operations": {},
        "name": "isNull",
        "body": "true",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "isComputable",
        "body": "true",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "ActivityEdge",
    "expressions": [
      {
        "operations": {"oclIsKindOf": 1},
        "name": "isConsistentWith",
        "body": "redefiningElement.oclIsKindOf(ActivityEdge)",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "<>": 1,
          "and": 1,
          "oclBadOperation": 2,
          "implies": 1,
          "=": 2
        },
        "name": "source_and_target",
        "body": "activity<>null implies source.containingActivity() = activity and target.containingActivity() = activity",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ActivityEdge::target",
          "UML::ActivityEdge::source",
          "UML::ActivityEdge::activity"
        ]
      }
    ],
    "properties": [
      "activityEdge",
      "target",
      "guard",
      "redefinedEdge",
      "weight",
      "inGroup",
      "inStructuredNode",
      "informationFlow",
      "source",
      "interrupts",
      "activity",
      "inPartition"
    ]
  },
  {
    "name": "Boolean",
    "expressions": [],
    "properties": []
  },
  {
    "name": "InteractionFragment",
    "expressions": [],
    "properties": [
      "enclosingOperand",
      "covered",
      "enclosingInteraction",
      "generalOrdering"
    ]
  },
  {
    "name": "Constraint",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "includes": 1
        },
        "name": "not_apply_to_self",
        "body": "not constrainedElement->includes(self)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Constraint::constrainedElement"]
      },
      {
        "operations": {},
        "name": "boolean_value",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {},
        "name": "no_side_effects",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      }
    ],
    "properties": [
      "constrainedElement",
      "preContext",
      "behavior",
      "behavior",
      "bodyContext",
      "context",
      "specification",
      "transition",
      "action",
      "stateInvariant",
      "action",
      "protocolTransition",
      "parameterSet",
      "extend",
      "owningState",
      "postContext",
      "owningTransition"
    ]
  },
  {
    "name": "Realization",
    "expressions": [],
    "properties": []
  },
  {
    "name": "LiteralUnlimitedNatural",
    "expressions": [
      {
        "operations": {},
        "name": "isComputable",
        "body": "true",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "unlimitedValue",
        "body": "value",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::LiteralUnlimitedNatural::value"]
      }
    ],
    "properties": ["value"]
  },
  {
    "name": "DirectedRelationship",
    "expressions": [],
    "properties": [
      "source",
      "target"
    ]
  },
  {
    "name": "StructuredClassifier",
    "expressions": [
      {
        "operations": {},
        "name": "part",
        "body": "ownedAttribute->select(isComposite)",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Property::isComposite",
          "UML::StructuredClassifier::ownedAttribute"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "allFeatures": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "allRoles",
        "body": "allFeatures()->select(oclIsKindOf(ConnectableElement))->collect(oclAsType(ConnectableElement))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2
        },
        "properties": []
      }
    ],
    "properties": [
      "part",
      "role",
      "ownedAttribute",
      "ownedConnector"
    ]
  },
  {
    "name": "BooleanObject",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Observation",
    "expressions": [],
    "properties": [
      "timeExpression",
      "duration"
    ]
  },
  {
    "name": "ReclassifyObjectAction",
    "expressions": [
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity",
        "body": "object.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReclassifyObjectAction::object"]
      },
      {
        "operations": {"=": 1},
        "name": "input_pin",
        "body": "object.type = null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ReclassifyObjectAction::object"
        ]
      },
      {
        "operations": {"not": 1},
        "name": "classifier_not_abstract",
        "body": "not newClassifier->exists(isAbstract)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReclassifyObjectAction::newClassifier",
          "UML::Classifier::isAbstract"
        ]
      }
    ],
    "properties": [
      "isReplaceAll",
      "newClassifier",
      "oldClassifier",
      "object"
    ]
  },
  {
    "name": "Package",
    "expressions": [
      {
        "operations": {},
        "name": "mustBeOwned",
        "body": "false",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "ownedType",
        "body": "packagedElement->select(oclIsKindOf(Type))->collect(oclAsType(Type))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Package::packagedElement"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "ownedStereotype",
        "body": "packagedElement->select(oclIsKindOf(Stereotype))->collect(oclAsType(Stereotype))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Package::packagedElement"]
      },
      {
        "operations": {
          "makesVisible": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "visibleMembers",
        "body": "member->select( m | m.oclIsKindOf(PackageableElement) and self.makesVisible(m))->collect(oclAsType(PackageableElement))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 5,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Namespace::member"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsType": 2,
          "containingProfile": 1
        },
        "name": "containingProfile",
        "body": "if self.oclIsKindOf(Profile) then \r\n\tself.oclAsType(Profile)\r\nelse\r\n\tself.namespace.oclAsType(Package).containingProfile()\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "TypeExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::NamedElement::namespace"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "nestedPackage",
        "body": "packagedElement->select(oclIsKindOf(Package))->collect(oclAsType(Package))->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Package::packagedElement"]
      },
      {
        "operations": {
          "<>": 1,
          "or": 1,
          "implies": 1,
          "=": 2
        },
        "name": "elements_public_or_private",
        "body": "packagedElement->forAll(e | e.visibility<> null implies e.visibility = VisibilityKind::public or e.visibility = VisibilityKind::private)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Package::packagedElement",
          "UML::PackageableElement::visibility"
        ]
      },
      {
        "operations": {
          "flatten": 1,
          "allApplicableStereotypes": 1,
          "oclIsKindOf": 1,
          "union": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "allApplicableStereotypes",
        "body": "let ownedPackages : Bag(Package) = ownedMember->select(oclIsKindOf(Package))->collect(oclAsType(Package)) in\r\n ownedStereotype->union(ownedPackages.allApplicableStereotypes())->flatten()->asSet()\r\n",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 6,
          "LetExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Namespace::ownedMember",
          "UML::Package::ownedStereotype"
        ]
      },
      {
        "operations": {
          "or": 2,
          "includes": 3,
          "notEmpty": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "makesVisible",
        "body": "ownedMember->includes(el) or\n(elementImport->select(ei|ei.importedElement = VisibilityKind::public)->collect(importedElement.oclAsType(NamedElement))->includes(el)) or\n(packageImport->select(visibility = VisibilityKind::public)->collect(importedPackage.member->includes(el))->notEmpty())",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 10,
          "OperationCallExpImpl": 9,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::PackageImport::importedPackage",
          "UML::ElementImport::importedElement",
          "UML::Namespace::packageImport",
          "UML::PackageImport::visibility",
          "UML::Namespace::ownedMember",
          "UML::Namespace::elementImport",
          "UML::Namespace::member"
        ]
      }
    ],
    "properties": [
      "URI",
      "packageImport",
      "ownedType",
      "packagedElement",
      "packageMerge",
      "profileApplication",
      "nestedPackage",
      "nestingPackage",
      "ownedStereotype",
      "packageMerge"
    ]
  },
  {
    "name": "IntegerObject",
    "expressions": [],
    "properties": []
  },
  {
    "name": "InstanceSpecification",
    "expressions": [
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "allSlottableFeatures": 1,
          "=": 1
        },
        "name": "structural_feature",
        "body": "classifier->forAll(c | (c.allSlottableFeatures()->forAll(f | slot->select(s | s.definingFeature = f)->size() <= 1)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::InstanceSpecification::classifier",
          "UML::Slot::definingFeature",
          "UML::InstanceSpecification::slot"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "allInstances": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 1
        },
        "name": "deployment_target",
        "body": "deployment->notEmpty() implies classifier->exists(node | node.oclIsKindOf(Node) and Node.allInstances()->exists(n | n.part->exists(p | p.type = node)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 6,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::InstanceSpecification::classifier",
          "UML::TypedElement::type",
          "UML::StructuredClassifier::part",
          "UML::DeploymentTarget::deployment"
        ]
      },
      {
        "operations": {
          "allSlottableFeatures": 1,
          "includes": 1
        },
        "name": "defining_feature",
        "body": "slot->forAll(s | classifier->exists (c | c.allSlottableFeatures()->includes (s.definingFeature)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::InstanceSpecification::classifier",
          "UML::Slot::definingFeature",
          "UML::InstanceSpecification::slot"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "implies": 1,
          "notEmpty": 1
        },
        "name": "deployment_artifact",
        "body": "deploymentForArtifact->notEmpty() implies classifier->exists(oclIsKindOf(Artifact))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InstanceSpecification::classifier"]
      }
    ],
    "properties": [
      "classifier",
      "instanceValue",
      "specification",
      "slot"
    ]
  },
  {
    "name": "Usage",
    "expressions": [],
    "properties": []
  },
  {
    "name": "InteractionConstraint",
    "expressions": [
      {
        "operations": {},
        "name": "dynamic_variables",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {},
        "name": "global_data",
        "body": null,
        "type": "ConstraintImpl",
        "constructs": {},
        "properties": []
      },
      {
        "operations": {
          "oclAsSet": 2,
          "integerValue": 1,
          "notEmpty": 1,
          "implies": 1,
          "first": 1,
          ">=": 1,
          "asSequence": 1
        },
        "name": "minint_non_negative",
        "body": "minint->notEmpty() implies \r\nminint->asSequence()->first().integerValue() >= 0",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::InteractionConstraint::minint"]
      },
      {
        "operations": {
          "oclAsSet": 2,
          "integerValue": 1,
          "notEmpty": 1,
          "implies": 1,
          "first": 1,
          ">": 1,
          "asSequence": 1
        },
        "name": "maxint_positive",
        "body": "maxint->notEmpty() implies \r\nmaxint->asSequence()->first().integerValue() > 0",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::InteractionConstraint::maxint"]
      },
      {
        "operations": {
          "or": 1,
          "oclAsSet": 2,
          "implies": 1,
          "notEmpty": 2,
          "=": 1
        },
        "name": "minint_maxint",
        "body": "maxint->notEmpty() or minint->notEmpty() implies\r\ninteractionOperand.combinedFragment.interactionOperator =\r\nInteractionOperatorKind::loop",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "OppositePropertyCallExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::InteractionConstraint::maxint",
          "UML::InteractionConstraint::minint",
          "UML::CombinedFragment::interactionOperator"
        ]
      },
      {
        "operations": {
          "and": 1,
          "oclAsSet": 4,
          "integerValue": 2,
          "notEmpty": 2,
          "implies": 1,
          "first": 2,
          ">=": 1,
          "asSequence": 2
        },
        "name": "maxint_greater_equal_minint",
        "body": "maxint->notEmpty() implies (minint->notEmpty() and \r\nmaxint->asSequence()->first().integerValue() >=\r\nminint->asSequence()->first().integerValue() )",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 15,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::InteractionConstraint::maxint",
          "UML::InteractionConstraint::minint"
        ]
      }
    ],
    "properties": [
      "maxint",
      "interactionOperand",
      "minint"
    ]
  },
  {
    "name": "RedefinableElement",
    "expressions": [
      {
        "operations": {
          "includesAll": 1,
          "allParents": 1
        },
        "name": "isRedefinitionContextValid",
        "body": "redefinitionContext->exists(c | c.allParents()->includesAll(redefinedElement.redefinitionContext))",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::RedefinableElement::redefinitionContext"]
      },
      {
        "operations": {"not": 1},
        "name": "non_leaf_redefinition",
        "body": "redefinedElement->forAll(re | not re.isLeaf)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::RedefinableElement::redefinedElement",
          "UML::RedefinableElement::isLeaf"
        ]
      },
      {
        "operations": {},
        "name": "isConsistentWith",
        "body": "false",
        "type": "OperationImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {"isRedefinitionContextValid": 1},
        "name": "redefinition_context_valid",
        "body": "redefinedElement->forAll(re | self.isRedefinitionContextValid(re))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::RedefinableElement::redefinedElement"]
      },
      {
        "operations": {"isConsistentWith": 1},
        "name": "redefinition_consistent",
        "body": "redefinedElement->forAll(re | re.isConsistentWith(self))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::RedefinableElement::redefinedElement"]
      }
    ],
    "properties": [
      "redefinedElement",
      "redefinableElement",
      "isLeaf",
      "redefinitionContext"
    ]
  },
  {
    "name": "CallConcurrencyKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Collaboration",
    "expressions": [],
    "properties": [
      "collaborationRole",
      "collaborationUse"
    ]
  },
  {
    "name": "InteractionOperatorKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "InstanceValue",
    "expressions": [],
    "properties": ["instance"]
  },
  {
    "name": "CallBehaviorAction",
    "expressions": [
      {
        "operations": {"inputParameters": 1},
        "name": "inputParameters",
        "body": "behavior.inputParameters()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CallBehaviorAction::behavior"]
      },
      {
        "operations": {"outputParameters": 1},
        "name": "outputParameters",
        "body": "behavior.outputParameters()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CallBehaviorAction::behavior"]
      },
      {
        "operations": {"=": 1},
        "name": "no_onport",
        "body": "onPort=null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InvocationAction::onPort"]
      }
    ],
    "properties": ["behavior"]
  },
  {
    "name": "RemoveVariableValueAction",
    "expressions": [{
      "operations": {
        "not": 2,
        "<>": 2,
        "and": 6,
        "toUnlimitedNatural": 1,
        "is": 1,
        "=": 3
      },
      "name": "removeAt_and_value",
      "body": "if  variable.isOrdered and not variable.isUnique and not isRemoveDuplicates then \r\n  value = null and\r\n  removeAt <> null and\r\n  removeAt.type = UnlimitedNatural and\r\n  removeAt.is(1,1)\r\nelse\r\n  removeAt = null and value <> null\r\nendif",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 9,
        "OperationCallExpImpl": 15,
        "NullLiteralExpImpl": 4,
        "IntegerLiteralExpImpl": 2,
        "TypeExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 12
      },
      "properties": [
        "UML::MultiplicityElement::isOrdered",
        "UML::TypedElement::type",
        "UML::RemoveVariableValueAction::isRemoveDuplicates",
        "UML::WriteVariableAction::value",
        "UML::RemoveVariableValueAction::removeAt",
        "UML::MultiplicityElement::isUnique",
        "UML::VariableAction::variable"
      ]
    }],
    "properties": [
      "isRemoveDuplicates",
      "removeAt"
    ]
  },
  {
    "name": "Comment",
    "expressions": [],
    "properties": [
      "annotatedElement",
      "body",
      "owningElement"
    ]
  },
  {
    "name": "ReadSelfAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "type",
        "body": "result.type = _'context'",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Action::context",
          "UML::TypedElement::type",
          "UML::ReadSelfAction::result"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity",
        "body": "result.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadSelfAction::result"]
      },
      {
        "operations": {"<>": 1},
        "name": "contained",
        "body": "_'context' <> null",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Action::context"]
      },
      {
        "operations": {
          "not": 1,
          "<>": 1,
          "containingBehavior": 1,
          "implies": 1
        },
        "name": "not_static",
        "body": "let behavior: Behavior = self.containingBehavior() in\r\nbehavior.specification<>null implies not behavior.specification.isStatic",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 3,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Behavior::specification",
          "UML::Feature::isStatic"
        ]
      }
    ],
    "properties": ["result"]
  },
  {
    "name": "SendSignalAction",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "allFeatures": 1,
          "isEmpty": 1,
          "oclAsSet": 1,
          "includes": 1,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "type_target_pin",
        "body": "not onPort->isEmpty() implies target.type.oclAsType(Classifier).allFeatures()->includes(onPort)\r\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 7,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::SendSignalAction::target",
          "UML::TypedElement::type",
          "UML::InvocationAction::onPort"
        ]
      },
      {
        "operations": {
          "at": 6,
          "compatibleWith": 1,
          "size": 1,
          "and": 2,
          "allAttributes": 1,
          "conformsTo": 1,
          "=": 1
        },
        "name": "type_ordering_multiplicity",
        "body": "let attribute: OrderedSet(Property) = signal.allAttributes() in\r\nSequence{1..argument->size()}->forAll(i | \r\n\targument->at(i).type.conformsTo(attribute->at(i).type) and \r\n\targument->at(i).isOrdered = attribute->at(i).isOrdered and\r\n\targument->at(i).compatibleWith(attribute->at(i)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 14,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::InvocationAction::argument",
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::SendSignalAction::signal"
        ]
      },
      {
        "operations": {
          "size": 2,
          "allAttributes": 1,
          "=": 1
        },
        "name": "number_order",
        "body": "argument->size()=signal.allAttributes()->size()",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::InvocationAction::argument",
          "UML::SendSignalAction::signal"
        ]
      }
    ],
    "properties": [
      "target",
      "signal"
    ]
  },
  {
    "name": "Integer",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ExecutionOccurrenceSpecification",
    "expressions": [],
    "properties": ["execution"]
  },
  {
    "name": "Action",
    "expressions": [
      {
        "operations": {
          "union": 1,
          "asSet": 2,
          "oclAsType": 1
        },
        "name": "allOwnedNodes",
        "body": "input.oclAsType(Pin)->asSet()->union(output->asSet())",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 3,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Action::input",
          "UML::Action::output"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "asSet": 1
        },
        "name": "allActions",
        "body": "self->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "<>": 2,
          "containingBehavior": 1
        },
        "name": "containingBehavior",
        "body": "if inStructuredNode<>null then inStructuredNode.containingBehavior() \r\nelse if activity<>null then activity\r\nelse interaction \r\nendif\r\nendif\r\n",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 2,
          "OppositePropertyCallExpImpl": 1,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityNode::activity",
          "UML::ActivityNode::inStructuredNode"
        ]
      },
      {
        "operations": {
          "containingBehavior": 1,
          "=": 2
        },
        "name": "context",
        "body": "let behavior: Behavior = self.containingBehavior() in\r\nif behavior=null then null\r\nelse if behavior._'context' = null then behavior\r\nelse behavior._'context'\r\nendif\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 3,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Behavior::context"]
      }
    ],
    "properties": [
      "context",
      "input",
      "localPrecondition",
      "actionInputPin",
      "output",
      "interaction",
      "actionExecutionSpecification",
      "localPostcondition",
      "isLocallyReentrant"
    ]
  },
  {
    "name": "Real",
    "expressions": [],
    "properties": []
  },
  {
    "name": "TestIdentityAction",
    "expressions": [
      {
        "operations": {
          "and": 1,
          "toUnlimitedNatural": 2,
          "is": 2
        },
        "name": "multiplicity",
        "body": "first.is(1,1) and second.is(1,1)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 4,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TestIdentityAction::second",
          "UML::TestIdentityAction::first"
        ]
      },
      {
        "operations": {
          "and": 1,
          "=": 2
        },
        "name": "no_type",
        "body": "first.type= null and second.type = null\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::TestIdentityAction::second",
          "UML::TestIdentityAction::first"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "result_is_boolean",
        "body": "result.type=Boolean",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TestIdentityAction::result",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": [
      "result",
      "second",
      "first"
    ]
  },
  {
    "name": "StartClassifierBehaviorAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1,
          "oclAsType": 1
        },
        "name": "type_has_classifier",
        "body": "object.type->notEmpty() implies \r\n   (object.type.oclIsKindOf(BehavioredClassifier) and object.type.oclAsType(BehavioredClassifier).classifierBehavior<>null)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 7,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::StartClassifierBehaviorAction::object",
          "UML::BehavioredClassifier::classifierBehavior"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity",
        "body": "object.is(1,1)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::StartClassifierBehaviorAction::object"]
      }
    ],
    "properties": ["object"]
  },
  {
    "name": "Substitution",
    "expressions": [],
    "properties": [
      "substitutingClassifier",
      "contract"
    ]
  },
  {
    "name": "PackageableElement",
    "expressions": [{
      "operations": {
        "implies": 1,
        "=": 2
      },
      "name": "namespace_needs_visibility",
      "body": "visibility = null implies namespace = null",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 3,
        "VariableExpImpl": 2,
        "NullLiteralExpImpl": 2,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::PackageableElement::visibility",
        "UML::NamedElement::namespace"
      ]
    }],
    "properties": [
      "owningPackage",
      "import",
      "manifestation",
      "deploymentTarget",
      "component",
      "visibility",
      "namespace"
    ]
  },
  {
    "name": "PseudostateKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Continuation",
    "expressions": [
      {
        "operations": {
          "and": 2,
          "oclAsSet": 1,
          "includes": 1,
          "notEmpty": 2
        },
        "name": "global",
        "body": "enclosingOperand->notEmpty() and\r\n  let operandLifelines : Set(Lifeline) =  enclosingOperand.covered in \r\n    (operandLifelines->notEmpty() and \r\n    operandLifelines->forAll(ol :Lifeline |self.covered->includes(ol)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 6,
          "LetExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::InteractionFragment::enclosingOperand",
          "UML::InteractionFragment::covered"
        ]
      },
      {
        "operations": {
          "or": 1,
          "last": 1,
          "and": 2,
          "oclAsSet": 1,
          "notEmpty": 2,
          "=": 2,
          "first": 1
        },
        "name": "first_or_last_interaction_fragment",
        "body": " enclosingOperand->notEmpty() and \r\n let peerFragments : OrderedSet(InteractionFragment) =  enclosingOperand.fragment in \r\n   ( peerFragments->notEmpty() and \r\n   ((peerFragments->first() = self) or  (peerFragments->last() = self)))",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 7,
          "LetExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::InteractionOperand::fragment",
          "UML::InteractionFragment::enclosingOperand"
        ]
      },
      {
        "operations": {
          "size": 3,
          "oclIsKindOf": 4,
          "and": 7,
          "oclAsSet": 2,
          "union": 1,
          "asSet": 12,
          "notEmpty": 3,
          "implies": 1,
          "=": 8,
          "oclAsType": 5
        },
        "name": "same_name",
        "body": "enclosingOperand.combinedFragment->notEmpty() and\r\nlet parentInteraction : Set(Interaction) = \r\nenclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)->\r\ncollect(enclosingInteraction).oclAsType(Interaction)->asSet()\r\nin \r\n(parentInteraction->size() = 1) \r\nand let peerInteractions : Set(Interaction) =\r\n (parentInteraction->union(parentInteraction->collect(_'context')->collect(behavior)->\r\n select(oclIsKindOf(Interaction)).oclAsType(Interaction)->asSet())->asSet()) in\r\n (peerInteractions->notEmpty()) and \r\n  let combinedFragments1 : Set(CombinedFragment) = peerInteractions.fragment->\r\n select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)->asSet() in\r\n   combinedFragments1->notEmpty() and  combinedFragments1->closure(operand.fragment->\r\n   select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment))->asSet().operand.fragment->\r\n   select(oclIsKindOf(Continuation)).oclAsType(Continuation)->asSet()->\r\n   forAll(c : Continuation |  (c.name = self.name) implies \r\n  (c.covered->asSet()->forAll(cl : Lifeline | --  cl must be common to one lifeline covered by self\r\n  self.covered->asSet()->\r\n  select(represents = cl.represents and selector = cl.selector)->asSet()->size()=1))\r\n   and\r\n (self.covered->asSet()->forAll(cl : Lifeline | --  cl must be common to one lifeline covered by c\r\n c.covered->asSet()->\r\n  select(represents = cl.represents and selector = cl.selector)->asSet()->size()=1))\r\n  )",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 23,
          "OperationCallExpImpl": 46,
          "VariableExpImpl": 41,
          "LetExpImpl": 3,
          "OppositePropertyCallExpImpl": 4,
          "IntegerLiteralExpImpl": 3,
          "TypeExpImpl": 9,
          "PropertyCallExpImpl": 24
        },
        "properties": [
          "UML::InteractionOperand::fragment",
          "UML::InteractionFragment::enclosingOperand",
          "UML::Behavior::context",
          "UML::NamedElement::name",
          "UML::InteractionFragment::covered",
          "UML::CombinedFragment::operand",
          "UML::Lifeline::represents",
          "UML::Interaction::fragment",
          "UML::InteractionFragment::enclosingInteraction",
          "UML::Lifeline::selector"
        ]
      }
    ],
    "properties": ["setting"]
  },
  {
    "name": "DataType",
    "expressions": [],
    "properties": [
      "ownedOperation",
      "ownedAttribute"
    ]
  },
  {
    "name": "Enumeration",
    "expressions": [{
      "operations": {},
      "name": "immutable",
      "body": "ownedAttribute->forAll(isReadOnly)",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 2,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::StructuralFeature::isReadOnly",
        "UML::DataType::ownedAttribute"
      ]
    }],
    "properties": [
      "enumerationLiteral",
      "ownedLiteral"
    ]
  },
  {
    "name": "CollaborationUse",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 4,
          "and": 5,
          "=": 2,
          "oclAsType": 4
        },
        "name": "client_elements",
        "body": "roleBinding->collect(client)->forAll(ne1, ne2 |\r\n  ne1.oclIsKindOf(ConnectableElement) and ne2.oclIsKindOf(ConnectableElement) and\r\n    let ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement), ce2 : ConnectableElement = ne2.oclAsType(ConnectableElement) in\r\n      ce1.structuredClassifier = ce2.structuredClassifier)\r\nand\r\n  roleBinding->collect(supplier)->forAll(ne1, ne2 |\r\n  ne1.oclIsKindOf(ConnectableElement) and ne2.oclIsKindOf(ConnectableElement) and\r\n    let ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement), ce2 : ConnectableElement = ne2.oclAsType(ConnectableElement) in\r\n      ce1.collaboration = ce2.collaboration)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 16,
          "OperationCallExpImpl": 15,
          "LetExpImpl": 4,
          "OppositePropertyCallExpImpl": 4,
          "TypeExpImpl": 8,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::CollaborationUse::roleBinding",
          "UML::Dependency::client",
          "UML::Dependency::supplier"
        ]
      },
      {
        "operations": {
          "and": 2,
          "intersection": 1,
          "oclAsSet": 3,
          "includes": 1,
          "conformsTo": 1,
          "asSet": 2,
          "notEmpty": 3,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "connectors",
        "body": "type.ownedConnector->forAll(connector |\r\n  let rolesConnectedInCollab : Set(ConnectableElement) = connector.end.role->asSet(),\r\n        relevantBindings : Set(Dependency) = roleBinding->select(rb | rb.supplier->intersection(rolesConnectedInCollab)->notEmpty()),\r\n        boundRoles : Set(ConnectableElement) = relevantBindings->collect(client.oclAsType(ConnectableElement))->asSet(),\r\n        contextClassifier : StructuredClassifier = boundRoles->any(true).structuredClassifier->any(true) in\r\n          contextClassifier.ownedConnector->exists( correspondingConnector | \r\n              correspondingConnector.end.role->forAll( role | boundRoles->includes(role) )\r\n              and (connector.type->notEmpty() and correspondingConnector.type->notEmpty()) implies connector.type->forAll(conformsTo(correspondingConnector.type)) )\r\n)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 11,
          "OperationCallExpImpl": 15,
          "VariableExpImpl": 20,
          "LetExpImpl": 4,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 14,
          "BooleanLiteralExpImpl": 2
        },
        "properties": [
          "UML::CollaborationUse::roleBinding",
          "UML::Dependency::client",
          "UML::Connector::end",
          "UML::ConnectorEnd::role",
          "UML::Dependency::supplier",
          "UML::Connector::type",
          "UML::StructuredClassifier::ownedConnector",
          "UML::CollaborationUse::type"
        ]
      },
      {
        "operations": {"includes": 1},
        "name": "every_role",
        "body": "type.collaborationRole->forAll(role | roleBinding->exists(rb | rb.supplier->includes(role)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::CollaborationUse::roleBinding",
          "UML::Dependency::supplier",
          "UML::Collaboration::collaborationRole",
          "UML::CollaborationUse::type"
        ]
      }
    ],
    "properties": [
      "roleBinding",
      "classifier",
      "type",
      "classifier"
    ]
  },
  {
    "name": "OpaqueBehavior",
    "expressions": [],
    "properties": [
      "body",
      "language"
    ]
  },
  {
    "name": "AddVariableValueAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "not": 2,
          "and": 2,
          "oclAsSet": 1,
          "is": 1,
          "implies": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "insertAt_pin",
        "body": "if not variable.isOrdered then insertAt = null\nelse \n  not isReplaceAll implies\n  \tinsertAt<>null and \n  \tinsertAt->forAll(type=UnlimitedNatural and is(1,1.oclAsType(UnlimitedNatural)))\nendif\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 7,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::AddVariableValueAction::isReplaceAll",
          "UML::AddVariableValueAction::insertAt",
          "UML::VariableAction::variable"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "required_value",
        "body": "value <> null",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::WriteVariableAction::value"]
      }
    ],
    "properties": [
      "isReplaceAll",
      "insertAt"
    ]
  },
  {
    "name": "Interface",
    "expressions": [{
      "operations": {"=": 1},
      "name": "visibility",
      "body": "feature->forAll(visibility = VisibilityKind::public)",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "EnumLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::Classifier::feature",
        "UML::NamedElement::visibility"
      ]
    }],
    "properties": [
      "component",
      "ownedAttribute",
      "port",
      "component",
      "interfaceRealization",
      "protocol",
      "ownedReception",
      "nestedClassifier",
      "port",
      "ownedOperation",
      "redefinedInterface",
      "interface"
    ]
  },
  {
    "name": "LoopNode",
    "expressions": [
      {
        "operations": {
          "at": 8,
          "size": 3,
          "and": 4,
          "includesMultiplicity": 1,
          "conformsTo": 1,
          "=": 3
        },
        "name": "matching_output_pins",
        "body": "bodyOutput->size()=loopVariable->size() and\r\nSequence{1..loopVariable->size()}->forAll(i |\r\n\tbodyOutput->at(i).type.conformsTo(loopVariable->at(i).type) and\r\n\tbodyOutput->at(i).isOrdered = loopVariable->at(i).isOrdered and\r\n\tbodyOutput->at(i).isUnique = loopVariable->at(i).isUnique and\r\n\tloopVariable->at(i).includesMultiplicity(bodyOutput->at(i)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 19,
          "OperationCallExpImpl": 20,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 17
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::TypedElement::type",
          "UML::LoopNode::loopVariable",
          "UML::MultiplicityElement::isUnique",
          "UML::LoopNode::bodyOutput"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "asSet": 1
        },
        "name": "allActions",
        "body": "self->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "includesAll": 1,
          "allOwnedNodes": 1
        },
        "name": "loop_variable_outgoing",
        "body": "allOwnedNodes()->includesAll(loopVariable.outgoing.target)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ActivityEdge::target",
          "UML::ActivityNode::outgoing",
          "UML::LoopNode::loopVariable"
        ]
      },
      {
        "operations": {"isEmpty": 1},
        "name": "input_edges",
        "body": "loopVariableInput.outgoing->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::LoopNode::loopVariableInput",
          "UML::ActivityNode::outgoing"
        ]
      },
      {
        "operations": {"isEmpty": 1},
        "name": "result_no_incoming",
        "body": "result.incoming->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityNode::incoming",
          "UML::LoopNode::result"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "union": 2,
          "asSet": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "executable_nodes",
        "body": "setupPart->union(test)->union(bodyPart)=node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->asSet()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 6,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::LoopNode::setupPart",
          "UML::LoopNode::bodyPart",
          "UML::StructuredActivityNode::node",
          "UML::LoopNode::test"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 4,
          "=": 5
        },
        "name": "matching_result_pins",
        "body": "result->size()=loopVariable->size() and\r\nresult.type=loopVariable.type and\r\nresult.isUnique=loopVariable.isUnique and\r\nresult.lower=loopVariable.lower and\r\nresult.upper=loopVariable.upper",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 8,
          "VariableExpImpl": 18,
          "OperationCallExpImpl": 11,
          "PropertyCallExpImpl": 18
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::MultiplicityElement::lower",
          "UML::MultiplicityElement::upper",
          "UML::LoopNode::loopVariable",
          "UML::LoopNode::result",
          "UML::MultiplicityElement::isUnique"
        ]
      },
      {
        "operations": {
          "sourceNodes": 1,
          "union": 1
        },
        "name": "sourceNodes",
        "body": "self.StructuredActivityNode::sourceNodes()->union(loopVariable)",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::LoopNode::loopVariable"]
      },
      {
        "operations": {
          "and": 2,
          "intersection": 3,
          "isEmpty": 3
        },
        "name": "setup_test_and_body",
        "body": "setupPart->intersection(test)->isEmpty() and\r\nsetupPart->intersection(bodyPart)->isEmpty() and\r\ntest->intersection(bodyPart)->isEmpty()",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 8,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::LoopNode::setupPart",
          "UML::LoopNode::bodyPart",
          "UML::LoopNode::test"
        ]
      },
      {
        "operations": {
          "includesAll": 1,
          "allActions": 1,
          "oclAsType": 1
        },
        "name": "body_output_pins",
        "body": "bodyPart.oclAsType(Action).allActions().output->includesAll(bodyOutput)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LoopNode::bodyPart",
          "UML::Action::output",
          "UML::LoopNode::bodyOutput"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 4,
          "=": 5
        },
        "name": "matching_loop_variables",
        "body": "loopVariableInput->size()=loopVariable->size() and\r\nloopVariableInput.type=loopVariable.type and\r\nloopVariableInput.isUnique=loopVariable.isUnique and\r\nloopVariableInput.lower=loopVariable.lower and\r\nloopVariableInput.upper=loopVariable.upper",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 8,
          "VariableExpImpl": 18,
          "OperationCallExpImpl": 11,
          "PropertyCallExpImpl": 18
        },
        "properties": [
          "UML::LoopNode::loopVariableInput",
          "UML::TypedElement::type",
          "UML::MultiplicityElement::lower",
          "UML::MultiplicityElement::upper",
          "UML::LoopNode::loopVariable",
          "UML::MultiplicityElement::isUnique"
        ]
      }
    ],
    "properties": [
      "loopVariableInput",
      "decider",
      "setupPart",
      "loopVariable",
      "bodyPart",
      "isTestedFirst",
      "test",
      "result",
      "bodyOutput"
    ]
  },
  {
    "name": "StructuredActivityNode",
    "expressions": [
      {
        "operations": {
          "excludesAll": 1,
          "allOwnedNodes": 1,
          "-": 1
        },
        "name": "input_pin_edges",
        "body": "input.incoming.source->excludesAll(allOwnedNodes()-output)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Action::input",
          "UML::Action::output",
          "UML::ActivityEdge::source",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "allOwnedNodes": 2,
          "union": 2,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "allOwnedNodes",
        "body": "self.Action::allOwnedNodes()->union(node)->union(node->select(oclIsKindOf(Action)).oclAsType(Action).allOwnedNodes())->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 6,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::StructuredActivityNode::node"]
      },
      {
        "operations": {
          "sourceNodes": 1,
          "intersection": 2,
          "allOwnedNodes": 2,
          "union": 1,
          "asSet": 1,
          "=": 1,
          "targetNodes": 1
        },
        "name": "edges",
        "body": "edge=self.sourceNodes().outgoing->intersection(self.allOwnedNodes().incoming)->\r\n\tunion(self.targetNodes().incoming->intersection(self.allOwnedNodes().outgoing))->asSet()",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 9,
          "OperationCallExpImpl": 9,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::StructuredActivityNode::edge",
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "union": 2,
          "asSet": 2,
          "oclAsType": 2
        },
        "name": "sourceNodes",
        "body": "node->union(input.oclAsType(ActivityNode)->asSet())->\r\n  union(node->select(oclIsKindOf(Action)).oclAsType(Action).output)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 7,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Action::input",
          "UML::Action::output",
          "UML::StructuredActivityNode::node"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "union": 2,
          "asSet": 2,
          "oclAsType": 2
        },
        "name": "targetNodes",
        "body": "node->union(output.oclAsType(ActivityNode)->asSet())->\r\n  union(node->select(oclIsKindOf(Action)).oclAsType(Action).input)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 7,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Action::input",
          "UML::Action::output",
          "UML::StructuredActivityNode::node"
        ]
      },
      {
        "operations": {"oclBadOperation": 1},
        "name": "containingActivity",
        "body": "self.Action::containingActivity()",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "excludesAll": 1,
          "allOwnedNodes": 1,
          "-": 1
        },
        "name": "output_pin_edges",
        "body": "output.outgoing.target->excludesAll(allOwnedNodes()-input)",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Action::input",
          "UML::ActivityEdge::target",
          "UML::ActivityNode::outgoing",
          "UML::Action::output"
        ]
      },
      {
        "operations": {
          "including": 1,
          "oclIsKindOf": 1,
          "allActions": 1,
          "asSet": 1,
          "oclAsType": 1
        },
        "name": "allActions",
        "body": "node->select(oclIsKindOf(Action)).oclAsType(Action).allActions()->including(self)->asSet()",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 5,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::StructuredActivityNode::node"]
      }
    ],
    "properties": [
      "structuredNodeInput",
      "edge",
      "activity",
      "structuredNodeOutput",
      "variable",
      "node",
      "mustIsolate"
    ]
  },
  {
    "name": "AnyReceiveEvent",
    "expressions": [],
    "properties": []
  },
  {
    "name": "DeploymentSpecification",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsSet": 1
        },
        "name": "deployment_target",
        "body": "deployment->forAll (location.oclIsKindOf(ExecutionEnvironment))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::DeploymentSpecification::deployment",
          "UML::Deployment::location"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsSet": 1
        },
        "name": "deployed_elements",
        "body": "deployment->forAll (location.deployedElement->forAll (oclIsKindOf(Component)))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::DeploymentTarget::deployedElement",
          "UML::DeploymentSpecification::deployment",
          "UML::Deployment::location"
        ]
      }
    ],
    "properties": [
      "deploymentLocation",
      "executionLocation",
      "deployment"
    ]
  },
  {
    "name": "ParameterDirectionKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Type",
    "expressions": [{
      "operations": {},
      "name": "conformsTo",
      "body": "false",
      "type": "OperationImpl",
      "constructs": {"BooleanLiteralExpImpl": 1},
      "properties": []
    }],
    "properties": [
      "operation",
      "association",
      "operation",
      "behavioralFeature",
      "package",
      "typedElement"
    ]
  },
  {
    "name": "ActivityNode",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "containingActivity": 1
        },
        "name": "ActivityNode_containingActivity",
        "body": "if inStructuredNode<>null then inStructuredNode.containingActivity()\r\nelse activity\r\nendif",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ActivityNode::activity",
          "UML::ActivityNode::inStructuredNode"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "isConsistentWith",
        "body": "redefiningElement.oclIsKindOf(ActivityNode)",
        "type": "OperationImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1
        },
        "properties": []
      }
    ],
    "properties": [
      "redefinedNode",
      "inInterruptibleRegion",
      "activity",
      "outgoing",
      "activityNode",
      "inPartition",
      "inGroup",
      "inStructuredNode",
      "incoming"
    ]
  }
]
