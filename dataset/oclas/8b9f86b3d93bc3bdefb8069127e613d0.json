[
  {
    "name": "ObjectNode",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "=": 2
        },
        "name": "selection_behavior",
        "body": "\n\t\t\tselection <> null = ordering = ObjectNodeOrderingKind::ordered\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ObjectNode::selection",
          "UML::ObjectNode::ordering"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsKindOf": 1,
          "union": 1,
          "implies": 1
        },
        "name": "object_flow_edges",
        "body": "\n\t\t\tnot isControlType implies\n\t\t\tincoming->union(outgoing)\n\t\t\t->forAll(oclIsKindOf(ObjectFlow))\n\t\n\t\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 4,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming",
          "UML::ObjectNode::isControlType"
        ]
      },
      {
        "operations": {
          "not": 1,
          "<>": 1,
          "size": 2,
          "and": 5,
          "is": 1,
          "conformsTo": 2,
          "implies": 1,
          "=": 2,
          "inputParameters": 3,
          "outputParameters": 1
        },
        "name": "input_output_parameter",
        "body": "\n\t\t\tselection <> null implies\n\t\t\tselection.inputParameters()\n\t\t\t->size() = 1 and\n\t\t\tselection.inputParameters()\n\t\t\t->forAll(p | not p.isUnique and\n\t\t\t  p.is(0, *) and\n\t\t\t  self.type.conformsTo(p.type)) and\n\t\t\tselection.outputParameters()\n\t\t\t->size() = 1 and\n\t\t\tselection.inputParameters()\n\t\t\t->forAll(p | self.type.conformsTo(p.type))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 11,
          "OperationCallExpImpl": 19,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 3,
          "UnlimitedNaturalLiteralExpImpl": 1,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::ObjectNode::selection",
          "UML::MultiplicityElement::isUnique",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Package",
    "expressions": [{
      "operations": {
        "<>": 1,
        "or": 1,
        "implies": 1,
        "=": 2
      },
      "name": "elements_public_or_private",
      "body": "\n\t\t\tpackagedElement->forAll(e | e.visibility <> null implies e.visibility = VisibilityKind::public or e.visibility = VisibilityKind::private)\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 5,
        "VariableExpImpl": 4,
        "NullLiteralExpImpl": 1,
        "EnumLiteralExpImpl": 2,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "UML::Package::packagedElement",
        "UML::PackageableElement::visibility"
      ]
    }],
    "properties": []
  },
  {
    "name": "DeploymentSpecification",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsSet": 1
        },
        "name": "deployment_target",
        "body": "\n\t\t\tdeployment->forAll(\n\t\t\t  location.oclIsKindOf(ExecutionEnvironment))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Deployment::location",
          "UML::DeploymentSpecification::deployment"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsSet": 1
        },
        "name": "deployed_elements",
        "body": "\n\t\t\tdeployment->forAll(\n\t\t\t  location.deployedElement->forAll(\n\t\t\t    oclIsKindOf(Component)))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Deployment::location",
          "UML::DeploymentTarget::deployedElement",
          "UML::DeploymentSpecification::deployment"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "BehavioralFeature",
    "expressions": [{
      "operations": {
        "isEmpty": 1,
        "implies": 1
      },
      "name": "abstract_no_method",
      "body": "\n\t\t\tisAbstract implies method->isEmpty()\n\t\n\t\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 2,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::BehavioralFeature::isAbstract",
        "UML::BehavioralFeature::method"
      ]
    }],
    "properties": []
  },
  {
    "name": "UnmarshallAction",
    "expressions": [
      {
        "operations": {
          "at": 6,
          "compatibleWith": 1,
          "size": 1,
          "and": 2,
          "allAttributes": 1,
          "conformsTo": 1,
          "=": 1
        },
        "name": "type_ordering_and_multiplicity",
        "body": "\n\t\t\tlet\n\t\t\t  attribute : OrderedSet(Property) = unmarshallType.allAttributes()\n\t\t\tin\n\t\t\t  Sequence{1..result->size()\n\t\t\t  }\n\t\t\t  ->forAll(i |\n\t\t\t    attribute->at(i)\n\t\t\t    .type.conformsTo(result->at(i).type) and\n\t\t\t    attribute->at(i).isOrdered =\n\t\t\t    result->at(i).isOrdered and\n\t\t\t    attribute->at(i)\n\t\t\t    .compatibleWith(result->at(i)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 14,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::UnmarshallAction::result",
          "UML::UnmarshallAction::unmarshallType",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_object",
        "body": "\n\t\t\tobject.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::UnmarshallAction::object"]
      },
      {
        "operations": {
          "size": 1,
          "allAttributes": 1,
          ">=": 1
        },
        "name": "structural_feature",
        "body": "\n\t\t\tunmarshallType.allAttributes()->size() >= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::UnmarshallAction::unmarshallType"]
      },
      {
        "operations": {"conformsTo": 1},
        "name": "object_type",
        "body": "\n\t\t\tobject.type.conformsTo(unmarshallType)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::UnmarshallAction::object",
          "UML::UnmarshallAction::unmarshallType",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "size": 2,
          "allAttributes": 1,
          "=": 1
        },
        "name": "number_of_result",
        "body": "\n\t\t\tunmarshallType.allAttributes()->size() = result->size()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::UnmarshallAction::result",
          "UML::UnmarshallAction::unmarshallType"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "TemplateParameterSubstitution",
    "expressions": [{
      "operations": {
        "oclAsSet": 1,
        "isCompatibleWith": 1
      },
      "name": "must_be_compatible",
      "body": "\n\t\t\tactual->forAll(a |\n\t\t\t  a.isCompatibleWith(formal.parameteredElement))\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 2,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::TemplateParameterSubstitution::actual",
        "UML::TemplateParameter::parameteredElement",
        "UML::TemplateParameterSubstitution::formal"
      ]
    }],
    "properties": []
  },
  {
    "name": "ActivityGroup",
    "expressions": [
      {
        "operations": {
          "and": 1,
          "=": 2,
          "containingActivity": 2
        },
        "name": "nodes_and_edges",
        "body": "\n\t\t\tcontainedNode->forAll(activity = self.containingActivity()) and\n\t\t\tcontainedEdge->forAll(activity = self.containingActivity())\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 6,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityGroup::containedEdge",
          "UML::ActivityNode::activity",
          "UML::ActivityGroup::containedNode",
          "UML::ActivityEdge::activity"
        ]
      },
      {
        "operations": {
          "and": 3,
          "excludesAll": 4,
          "oclAsSet": 2
        },
        "name": "not_contained",
        "body": "\n\t\t\tsubgroup->closure(subgroup)\n\t\t\t.containedNode->excludesAll(containedNode) and\n\t\t\tsuperGroup->closure(superGroup)\n\t\t\t.containedNode->excludesAll(containedNode) and\n\t\t\tsubgroup->closure(subgroup)\n\t\t\t.containedEdge->excludesAll(containedEdge) and\n\t\t\tsuperGroup->closure(superGroup)\n\t\t\t.containedEdge->excludesAll(containedEdge)\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 8,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 16,
          "PropertyCallExpImpl": 16
        },
        "properties": [
          "UML::ActivityGroup::containedEdge",
          "UML::ActivityGroup::subgroup",
          "UML::ActivityGroup::containedNode",
          "UML::ActivityGroup::superGroup"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ReclassifyObjectAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "input_pin",
        "body": "\n\t\t\tobject.type = null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReclassifyObjectAction::object",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\tobject.is(1, 1)\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReclassifyObjectAction::object"]
      },
      {
        "operations": {"not": 1},
        "name": "classifier_not_abstract",
        "body": "\n\t\t\tnot newClassifier->exists(isAbstract)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReclassifyObjectAction::newClassifier",
          "UML::Classifier::isAbstract"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ExpansionNode",
    "expressions": [{
      "operations": {
        "oclAsSet": 2,
        "xor": 1,
        "notEmpty": 2
      },
      "name": "region_as_input_or_output",
      "body": "\n\t\t\tregionAsInput->notEmpty() xor regionAsOutput->notEmpty()\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 5,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::ExpansionNode::regionAsInput",
        "UML::ExpansionNode::regionAsOutput"
      ]
    }],
    "properties": []
  },
  {
    "name": "TimeExpression",
    "expressions": [{
      "operations": {
        "size": 1,
        "oclIsKindOf": 1,
        "and": 1,
        "implies": 1,
        "=": 2
      },
      "name": "no_expr_requires_observation",
      "body": "\n\t\t\texpr = null implies\n\t\t\tobservation->size() = 1 and\n\t\t\tobservation->forAll(\n\t\t\t  oclIsKindOf(TimeObservation))\n\t\n\t\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 4,
        "NullLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::TimeExpression::observation",
        "UML::TimeExpression::expr"
      ]
    }],
    "properties": []
  },
  {
    "name": "Class",
    "expressions": [{
      "operations": {
        "not": 1,
        "and": 1,
        "isEmpty": 1,
        "implies": 1,
        "=": 1
      },
      "name": "passive_class",
      "body": "\n\t\t\tnot isActive implies ownedReception->isEmpty() and classifierBehavior = null\n\t\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 5,
        "VariableExpImpl": 3,
        "NullLiteralExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::Class::isActive",
        "UML::Class::ownedReception",
        "UML::BehavioredClassifier::classifierBehavior"
      ]
    }],
    "properties": []
  },
  {
    "name": "NamedElement",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "allNamespaces": 2,
          "and": 1,
          "isEmpty": 1,
          "concat": 2,
          "implies": 1,
          "separator": 1,
          "=": 2
        },
        "name": "has_qualified_name",
        "body": "\n\t\t\tname <> null and\n\t\t\tallNamespaces()\n\t\t\t->select(ns | ns.name = null)\n\t\t\t->isEmpty() implies qualifiedName =\n\t\t\tallNamespaces()\n\t\t\t->iterate(ns; agg : String = name |\n\t\t\t  ns.name.concat(self.separator())\n\t\t\t  .concat(agg))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 9,
          "NullLiteralExpImpl": 2,
          "IterateExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::NamedElement::qualifiedName",
          "UML::NamedElement::name"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "and": 1,
          "implies": 1,
          "=": 2
        },
        "name": "visibility_needs_ownership",
        "body": "\n\t\t\tnamespace = null and owner <> null implies visibility = null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "NullLiteralExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::NamedElement::namespace",
          "UML::NamedElement::visibility",
          "UML::Element::owner"
        ]
      },
      {
        "operations": {
          "allNamespaces": 1,
          "or": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 3
        },
        "name": "has_no_qualified_name",
        "body": "\n\t\t\tname = null or\n\t\t\tallNamespaces()\n\t\t\t->select(ns | ns.name = null)\n\t\t\t->notEmpty() implies qualifiedName = null\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::NamedElement::qualifiedName",
          "UML::NamedElement::name"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "StartClassifierBehaviorAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1,
          "oclAsType": 1
        },
        "name": "type_has_classifier",
        "body": "\n\t\t\tobject.type->notEmpty() implies\n\t\t\tobject.type.oclIsKindOf(BehavioredClassifier) and\n\t\t\tobject.type.oclAsType(BehavioredClassifier).classifierBehavior <> null\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::StartClassifierBehaviorAction::object",
          "UML::TypedElement::type",
          "UML::BehavioredClassifier::classifierBehavior"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\tobject.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::StartClassifierBehaviorAction::object"]
      }
    ],
    "properties": []
  },
  {
    "name": "Pin",
    "expressions": [
      {
        "operations": {"not": 1},
        "name": "not_unique",
        "body": "\n\t\t\tnot isUnique\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::MultiplicityElement::isUnique"]
      },
      {
        "operations": {"implies": 1},
        "name": "control_pins",
        "body": "\n\t\t\tisControl implies isControlType\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Pin::isControl",
          "UML::ObjectNode::isControlType"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "VariableAction",
    "expressions": [{
      "operations": {"isAccessibleBy": 1},
      "name": "scope_of_variable",
      "body": "\n\t\t\tvariable.isAccessibleBy(self)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::VariableAction::variable"]
    }],
    "properties": []
  },
  {
    "name": "ReadLinkObjectEndQualifierAction",
    "expressions": [
      {
        "operations": {"<>": 1},
        "name": "qualifier_attribute",
        "body": "\n\t\t\tqualifier.associationEnd <> null\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Property::associationEnd",
          "UML::ReadLinkObjectEndQualifierAction::qualifier"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "type_of_object",
        "body": "\n\t\t\tobject.type = qualifier.associationEnd.association\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ReadLinkObjectEndQualifierAction::object",
          "UML::Property::associationEnd",
          "UML::ReadLinkObjectEndQualifierAction::qualifier",
          "UML::Property::association",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "association_of_association",
        "body": "\n\t\t\tqualifier.associationEnd.association.oclIsKindOf(AssociationClass)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Property::associationEnd",
          "UML::ReadLinkObjectEndQualifierAction::qualifier",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_result",
        "body": "\n\t\t\tresult.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkObjectEndQualifierAction::result"]
      },
      {
        "operations": {"=": 1},
        "name": "same_type",
        "body": "\n\t\t\tresult.type = qualifier.type\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ReadLinkObjectEndQualifierAction::qualifier",
          "UML::ReadLinkObjectEndQualifierAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_object",
        "body": "\n\t\t\tobject.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkObjectEndQualifierAction::object"]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_qualifier",
        "body": "\n\t\t\tqualifier.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkObjectEndQualifierAction::qualifier"]
      },
      {
        "operations": {"not": 1},
        "name": "ends_of_association",
        "body": "\n\t\t\tqualifier.associationEnd.association.memberEnd->forAll(e | not e.isStatic)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Feature::isStatic",
          "UML::Association::memberEnd",
          "UML::Property::associationEnd",
          "UML::ReadLinkObjectEndQualifierAction::qualifier",
          "UML::Property::association"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "UseCase",
    "expressions": [
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "must_have_name",
        "body": "\n\t\t\tname->notEmpty()\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::NamedElement::name"]
      },
      {
        "operations": {
          "not": 1,
          "includes": 1,
          "allIncludedUseCases": 1
        },
        "name": "cannot_include_self",
        "body": "\n\t\t\tnot allIncludedUseCases()->includes(self)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {
          "size": 1,
          "allInstances": 1,
          "includes": 1,
          "implies": 1,
          "=": 1
        },
        "name": "binary_associations",
        "body": "\n\t\t\tAssociation.allInstances()\n\t\t\t->forAll(a |\n\t\t\t  a.memberEnd.type->includes(self) implies\n\t\t\t  a.memberEnd->size() = 2)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "size": 2,
          "oclIsKindOf": 1,
          "allInstances": 1,
          "includes": 1,
          "implies": 2,
          "asSet": 1,
          "oclAsType": 1,
          ">": 2
        },
        "name": "no_association_to_use_case",
        "body": "\n\t\t\tAssociation.allInstances()\n\t\t\t->forAll(a |\n\t\t\t  a.memberEnd.type->includes(self) implies\n\t\t\t  let\n\t\t\t    usecases : Set(UseCase) = a.memberEnd.type->select(\n\t\t\t      oclIsKindOf(UseCase))\n\t\t\t    ->collect(oclAsType(UseCase))\n\t\t\t    ->asSet()\n\t\t\t  in\n\t\t\t    usecases->size() > 1 implies\n\t\t\t    usecases->collect(subject)\n\t\t\t    ->size() > 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "VariableExpImpl": 10,
          "OperationCallExpImpl": 11,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::UseCase::subject",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "LinkEndCreationData",
    "expressions": [{
      "operations": {
        "<>": 1,
        "not": 2,
        "and": 2,
        "oclAsSet": 1,
        "is": 1,
        "toUnlimitedNatural": 1,
        "implies": 1,
        "=": 3
      },
      "name": "insertAt_pin",
      "body": "\n\t\t\tif not end.isOrdered\n\t\t\tthen insertAt = null\n\t\t\telse not isReplaceAll = false implies insertAt <> null and\n\t\t\t  insertAt->forAll(type = UnlimitedNatural and is(1, 1))\n\t\t\tendif\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 7,
        "OperationCallExpImpl": 12,
        "NullLiteralExpImpl": 2,
        "IntegerLiteralExpImpl": 2,
        "TypeExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 7,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "UML::MultiplicityElement::isOrdered",
        "UML::LinkEndData::end",
        "UML::LinkEndCreationData::isReplaceAll",
        "UML::LinkEndCreationData::insertAt",
        "UML::TypedElement::type"
      ]
    }],
    "properties": []
  },
  {
    "name": "ParameterSet",
    "expressions": [
      {
        "operations": {
          "and": 3,
          "isEmpty": 2,
          "implies": 2,
          "=": 4
        },
        "name": "input",
        "body": "\n\t\t\t(\n\t\t\t  parameter->exists(direction = ParameterDirectionKind::_'in') implies\n\t\t\t  behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::_'in' and\n\t\t\t    p.parameterSet->isEmpty())\n\t\t\t  ->forAll(isStream)\n\t\t\t) and\n\t\t\t(\n\t\t\t  parameter->exists(direction = ParameterDirectionKind::out) implies\n\t\t\t  behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::out and\n\t\t\t    p.parameterSet->isEmpty())\n\t\t\t  ->forAll(isStream)\n\t\t\t)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 12,
          "OppositePropertyCallExpImpl": 2,
          "EnumLiteralExpImpl": 4,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "UML::BehavioralFeature::ownedParameter",
          "UML::Parameter::parameterSet",
          "UML::Parameter::direction",
          "UML::ParameterSet::parameter",
          "UML::Parameter::isStream"
        ]
      },
      {
        "operations": {
          "and": 2,
          "=": 3
        },
        "name": "same_parameterized_entity",
        "body": "\n\t\t\tparameter->forAll(p1, p2 | self.owner = p1.owner and self.owner = p2.owner and p1.direction = p2.direction)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 7,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::Parameter::direction",
          "UML::Element::owner",
          "UML::ParameterSet::parameter"
        ]
      },
      {
        "operations": {
          "not": 1,
          "size": 2,
          "oclAsSet": 2,
          "includes": 1,
          "implies": 1,
          "=": 1
        },
        "name": "two_parameter_sets",
        "body": "\n\t\t\tparameter->forAll(\n\t\t\t  parameterSet->forAll(s1, s2 |\n\t\t\t    s1->size() =\n\t\t\t    s2->size() implies\n\t\t\t    s1.parameter->exists(p | not s2.parameter->includes(p))))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 8,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Parameter::parameterSet",
          "UML::ParameterSet::parameter"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "FinalState",
    "expressions": [
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "no_regions",
        "body": "\n\t\t\tregion->size() = 0\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::region"]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "isEmpty": 1
        },
        "name": "no_state_behavior",
        "body": "\n\t\t\tdoActivity->isEmpty()\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::doActivity"]
      },
      {
        "operations": {
          "isEmpty": 1,
          "oclAsSet": 1
        },
        "name": "cannot_reference_submachine",
        "body": "\n\t\t\tsubmachine->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::submachine"]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "isEmpty": 1
        },
        "name": "no_entry_behavior",
        "body": "\n\t\t\tentry->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::entry"]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "isEmpty": 1
        },
        "name": "no_exit_behavior",
        "body": "\n\t\t\texit->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::State::exit"]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "no_outgoing_transitions",
        "body": "\n\t\t\toutgoing->size() = 0\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Vertex::outgoing"]
      }
    ],
    "properties": []
  },
  {
    "name": "InteractionUse",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "allParents": 1,
          "includes": 1,
          "union": 1,
          "asSet": 4,
          "implies": 1,
          "notEmpty": 2,
          "oclAsType": 1
        },
        "name": "returnValueRecipient_coverage",
        "body": "\n\t\t\treturnValueRecipient->asSet()\n\t\t\t->notEmpty() implies\n\t\t\tlet\n\t\t\t  covCE : Set(ConnectableElement) = covered.represents->asSet()\n\t\t\tin\n\t\t\t  covCE->notEmpty() and\n\t\t\t  let\n\t\t\t    classes : Set(Classifier) = covCE.type.oclIsKindOf(Classifier)\n\t\t\t    .oclAsType(Classifier)\n\t\t\t    ->asSet()\n\t\t\t  in\n\t\t\t    let\n\t\t\t      allProps : Set(Property) = classes.attribute->union(\n\t\t\t        classes.allParents().attribute)\n\t\t\t      ->asSet()\n\t\t\t    in allProps->includes(returnValueRecipient)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 7,
          "VariableExpImpl": 15,
          "OperationCallExpImpl": 14,
          "LetExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::InteractionFragment::covered",
          "UML::InteractionUse::returnValueRecipient",
          "UML::Lifeline::represents",
          "UML::Classifier::attribute",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 1,
          "notEmpty": 1,
          "implies": 1,
          "=": 2,
          "matches": 2
        },
        "name": "gates_match",
        "body": "\n\t\t\tactualGate->notEmpty() implies\n\t\t\trefersTo.formalGate->forAll(fg |\n\t\t\t  self.actualGate->select(matches(fg))\n\t\t\t  ->size() = 1) and\n\t\t\tself.actualGate->forAll(ag |\n\t\t\t  refersTo.formalGate->select(matches(ag))\n\t\t\t  ->size() = 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 9,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::InteractionUse::actualGate",
          "UML::Interaction::formalGate",
          "UML::InteractionUse::refersTo"
        ]
      },
      {
        "operations": {
          "size": 1,
          "oclIsKindOf": 4,
          "and": 5,
          "oclAsSet": 2,
          "includes": 1,
          "union": 1,
          "implies": 3,
          "asSet": 3,
          "=": 4,
          "oclAsType": 5
        },
        "name": "all_lifelines",
        "body": "\n\t\t\tlet\n\t\t\t  parentInteraction : Set(Interaction) = enclosingInteraction->asSet()\n\t\t\t  ->union(\n\t\t\t    enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)\n\t\t\t    ->collect(enclosingInteraction)\n\t\t\t    .oclAsType(Interaction)\n\t\t\t    ->asSet())\n\t\t\tin\n\t\t\t  parentInteraction->size() = 1 and\n\t\t\t  let refInteraction : Interaction = refersTo\n\t\t\t  in\n\t\t\t    parentInteraction.covered->forAll(intLifeline |\n\t\t\t      refInteraction.covered->forAll(refLifeline |\n\t\t\t        (refLifeline.represents = intLifeline.represents and\n\t\t\t          (\n\t\t\t            refLifeline.selector.oclIsKindOf(LiteralString) implies\n\t\t\t            intLifeline.selector.oclIsKindOf(LiteralString) and\n\t\t\t            refLifeline.selector.oclAsType(LiteralString).value =\n\t\t\t            intLifeline.selector.oclAsType(LiteralString).value\n\t\t\t          ) and\n\t\t\t          (\n\t\t\t            refLifeline.selector.oclIsKindOf(LiteralInteger) implies\n\t\t\t            intLifeline.selector.oclIsKindOf(LiteralInteger) and\n\t\t\t            refLifeline.selector.oclAsType(LiteralInteger).value =\n\t\t\t            intLifeline.selector.oclAsType(LiteralInteger).value\n\t\t\t          ) implies\n\t\t\t          self.covered->asSet()\n\t\t\t          ->includes(intLifeline)\n\t\t\t        )))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "VariableExpImpl": 22,
          "OperationCallExpImpl": 29,
          "LetExpImpl": 2,
          "OppositePropertyCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 9,
          "PropertyCallExpImpl": 22
        },
        "properties": [
          "UML::LiteralString::value",
          "UML::InteractionFragment::covered",
          "UML::LiteralInteger::value",
          "UML::InteractionFragment::enclosingOperand",
          "UML::Lifeline::represents",
          "UML::Lifeline::selector",
          "UML::InteractionUse::refersTo",
          "UML::InteractionFragment::enclosingInteraction"
        ]
      },
      {
        "operations": {
          "oclAsSet": 3,
          "notEmpty": 1,
          "implies": 1,
          "=": 1,
          "first": 2,
          "asSequence": 3
        },
        "name": "returnValue_type_recipient_correspondence",
        "body": "\n\t\t\treturnValue.type->asSequence()\n\t\t\t->notEmpty() implies\n\t\t\treturnValue.type->asSequence()\n\t\t\t->first() =\n\t\t\treturnValueRecipient.type->asSequence()\n\t\t\t->first()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::InteractionUse::returnValueRecipient",
          "UML::InteractionUse::returnValue",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {},
        "name": "arguments_correspond_to_parameters",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "arguments_are_constants",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "ConnectionPointReference",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "exit_pseudostates",
        "body": "\n\t\t\texit->forAll(kind = PseudostateKind::exitPoint)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::ConnectionPointReference::exit"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "entry_pseudostates",
        "body": "\n\t\t\tentry->forAll(kind = PseudostateKind::entryPoint)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ConnectionPointReference::entry",
          "UML::Pseudostate::kind"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Extend",
    "expressions": [{
      "operations": {"includes": 1},
      "name": "extension_points",
      "body": "\n\t\t\textensionLocation->forAll(xp | extendedCase.extensionPoint->includes(xp))\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::Extend::extendedCase",
        "UML::Extend::extensionLocation",
        "UML::UseCase::extensionPoint"
      ]
    }],
    "properties": []
  },
  {
    "name": "Trigger",
    "expressions": [{
      "operations": {
        "oclIsKindOf": 1,
        "notEmpty": 1,
        "implies": 1
      },
      "name": "trigger_with_ports",
      "body": "\n\t\t\tport->notEmpty() implies\n\t\t\tevent.oclIsKindOf(MessageEvent)\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 3,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::Trigger::port",
        "UML::Trigger::event"
      ]
    }],
    "properties": []
  },
  {
    "name": "RedefinableTemplateSignature",
    "expressions": [{
      "operations": {
        "allParents": 1,
        "oclAsSet": 2,
        "includes": 1,
        "implies": 1,
        "notEmpty": 1
      },
      "name": "redefines_parents",
      "body": "\n\t\t\tclassifier.allParents()\n\t\t\t->forAll(c |\n\t\t\t  c.ownedTemplateSignature->notEmpty() implies\n\t\t\t  self->closure(extendedSignature)\n\t\t\t  ->includes(c.ownedTemplateSignature))\n\t\n\t\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 5,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "UML::Classifier::ownedTemplateSignature",
        "UML::RedefinableTemplateSignature::extendedSignature",
        "UML::RedefinableTemplateSignature::classifier"
      ]
    }],
    "properties": []
  },
  {
    "name": "TestIdentityAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "result_is_boolean",
        "body": "\n\t\t\tresult.type = Boolean\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TestIdentityAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "and": 1,
          "=": 2
        },
        "name": "no_type",
        "body": "\n\t\t\tfirst.type = null and second.type = null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TestIdentityAction::second",
          "UML::TestIdentityAction::first",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "and": 1,
          "toUnlimitedNatural": 2,
          "is": 2
        },
        "name": "multiplicity",
        "body": "\n\t\t\tfirst.is(1, 1) and second.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 4,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TestIdentityAction::second",
          "UML::TestIdentityAction::first"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ReadStructuralFeatureAction",
    "expressions": [
      {
        "operations": {
          "and": 1,
          "=": 2
        },
        "name": "type_and_ordering",
        "body": "\n\t\t\tresult.type = structuralFeature.type and result.isOrdered = structuralFeature.isOrdered\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::ReadStructuralFeatureAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"compatibleWith": 1},
        "name": "multiplicity",
        "body": "\n\t\t\tstructuralFeature.compatibleWith(result)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::ReadStructuralFeatureAction::result"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "WriteVariableAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "toUnlimitedNatural": 1,
          "is": 1,
          "implies": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\tvalue <> null implies value.is(1, 1)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::WriteVariableAction::value"]
      },
      {
        "operations": {
          "<>": 1,
          "conformsTo": 1,
          "implies": 1
        },
        "name": "value_type",
        "body": "\n\t\t\tvalue <> null implies value.type.conformsTo(variable.type)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::WriteVariableAction::value",
          "UML::VariableAction::variable",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Classifier",
    "expressions": [
      {
        "operations": {
          "maySpecializeType": 1,
          "parents": 1
        },
        "name": "specialize_type",
        "body": "\n\t\t\tparents()->forAll(c | self.maySpecializeType(c))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3
        },
        "properties": []
      },
      {
        "operations": {
          "not": 1,
          "allParents": 1,
          "includes": 1
        },
        "name": "no_cycles_in_generalization",
        "body": "\n\t\t\tnot allParents()->includes(self)\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3
        },
        "properties": []
      },
      {
        "operations": {
          "not": 4,
          "and": 3,
          "allParents": 2,
          "includes": 2,
          "=": 2
        },
        "name": "maps_to_generalization_set",
        "body": "\n\t\t\tpowertypeExtent->forAll(gs |\n\t\t\t  gs.generalization->forAll(gen |\n\t\t\t    not (gen.general = self\n\t\t\t    ) and\n\t\t\t    not gen.general.allParents()\n\t\t\t    ->includes(self) and\n\t\t\t    not (gen.specific = self\n\t\t\t    ) and\n\t\t\t    not self.allParents()\n\t\t\t    ->includes(gen.specific)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 10,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Generalization::specific",
          "UML::Classifier::powertypeExtent",
          "UML::Generalization::general",
          "UML::GeneralizationSet::generalization"
        ]
      },
      {
        "operations": {
          "not": 1,
          "parents": 1
        },
        "name": "non_final_parents",
        "body": "\n\t\t\tparents()->forAll(not isFinalSpecialization)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Classifier::isFinalSpecialization"]
      }
    ],
    "properties": []
  },
  {
    "name": "InputPin",
    "expressions": [{
      "operations": {
        "includesAll": 1,
        "<>": 1,
        "oclIsKindOf": 1,
        "and": 2,
        "allOwnedNodes": 1,
        "notEmpty": 1,
        "implies": 1,
        "oclAsType": 1
      },
      "name": "outgoing_edges_structured_only",
      "body": "\n\t\t\toutgoing->notEmpty() implies action <> null and\n\t\t\taction.oclIsKindOf(StructuredActivityNode) and\n\t\t\taction.oclAsType(StructuredActivityNode)\n\t\t\t.allOwnedNodes()\n\t\t\t->includesAll(outgoing.target)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 6,
        "OperationCallExpImpl": 9,
        "OppositePropertyCallExpImpl": 3,
        "NullLiteralExpImpl": 1,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::ActivityNode::outgoing",
        "UML::ActivityEdge::target"
      ]
    }],
    "properties": []
  },
  {
    "name": "ActivityParameterNode",
    "expressions": [
      {
        "operations": {"includes": 1},
        "name": "has_parameters",
        "body": "\n\t\t\tactivity.ownedParameter->includes(parameter)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Behavior::ownedParameter",
          "UML::ActivityNode::activity",
          "UML::ActivityParameterNode::parameter"
        ]
      },
      {
        "operations": {
          "or": 1,
          "and": 1,
          "isEmpty": 1,
          "notEmpty": 1,
          "implies": 1,
          "=": 2
        },
        "name": "no_incoming_edges",
        "body": "\n\t\t\toutgoing->notEmpty() and\n\t\t\tincoming->isEmpty() implies parameter.direction = ParameterDirectionKind::_'in' or parameter.direction = ParameterDirectionKind::inout\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming",
          "UML::Parameter::direction",
          "UML::ActivityParameterNode::parameter"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "same_type",
        "body": "\n\t\t\ttype = parameter.type\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ActivityParameterNode::parameter"
        ]
      },
      {
        "operations": {
          "or": 2,
          "and": 1,
          "isEmpty": 1,
          "notEmpty": 1,
          "implies": 1,
          "=": 3
        },
        "name": "no_outgoing_edges",
        "body": "\n\t\t\tincoming->notEmpty() and\n\t\t\toutgoing->isEmpty() implies parameter.direction = ParameterDirectionKind::out or parameter.direction = ParameterDirectionKind::inout or parameter.direction = ParameterDirectionKind::return\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 9,
          "EnumLiteralExpImpl": 3,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming",
          "UML::Parameter::direction",
          "UML::ActivityParameterNode::parameter"
        ]
      },
      {
        "operations": {
          "or": 1,
          "isEmpty": 2
        },
        "name": "no_edges",
        "body": "\n\t\t\tincoming->isEmpty() or outgoing->isEmpty()\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ActivityPartition",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 3,
          "and": 3,
          "oclAsSet": 1,
          "notEmpty": 1,
          "implies": 1,
          "oclAsType": 1,
          "=": 2
        },
        "name": "represents_property_and_is_contained",
        "body": "\n\t\t\trepresents.oclIsKindOf(Property) and\n\t\t\tsuperPartition->notEmpty() implies\n\t\t\tsuperPartition.represents.oclIsKindOf(Classifier) and represents.owner = superPartition.represents or\n\t\t\tsuperPartition.represents.oclIsKindOf(Property) and represents.owner =\n\t\t\tsuperPartition.represents.oclAsType(Property).type\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 8,
          "OperationCallExpImpl": 13,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 15
        },
        "properties": [
          "UML::ActivityPartition::superPartition",
          "UML::ActivityPartition::represents",
          "UML::Element::owner",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "not": 1,
          "or": 2,
          "oclIsKindOf": 5,
          "and": 9,
          "oclAsSet": 1,
          "allInstances": 1,
          "includes": 2,
          "notEmpty": 1,
          "implies": 1,
          "oclAsType": 5,
          "=": 2
        },
        "name": "represents_classifier",
        "body": "\n\t\t\tnot isExternal and\n\t\t\trepresents.oclIsKindOf(Classifier) and\n\t\t\tsuperPartition->notEmpty() implies\n\t\t\tlet\n\t\t\t  representedClassifier : Classifier = represents.oclAsType(Classifier)\n\t\t\tin\n\t\t\t  superPartition.represents.oclIsKindOf(Classifier) and\n\t\t\t  let\n\t\t\t    representedSuperClassifier : Classifier = superPartition.represents.oclAsType(Classifier)\n\t\t\t  in\n\t\t\t    (\n\t\t\t      representedSuperClassifier.oclIsKindOf(BehavioredClassifier) and\n\t\t\t      representedClassifier.oclIsKindOf(Behavior) and\n\t\t\t      representedSuperClassifier.oclAsType(BehavioredClassifier)\n\t\t\t      .ownedBehavior->includes(\n\t\t\t        representedClassifier.oclAsType(Behavior)) or\n\t\t\t      representedSuperClassifier.oclIsKindOf(Class) and\n\t\t\t      representedSuperClassifier.oclAsType(Class)\n\t\t\t      .nestedClassifier->includes(representedClassifier) or\n\t\t\t      Association.allInstances()\n\t\t\t      ->exists(a |\n\t\t\t        a.memberEnd->exists(end1 | end1.isComposite and end1.type = representedClassifier and\n\t\t\t          a.memberEnd->exists(end2 | end1 <> end2 and end2.type = representedSuperClassifier)))\n\t\t\t    )\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 22,
          "OperationCallExpImpl": 31,
          "LetExpImpl": 2,
          "TypeExpImpl": 11,
          "PropertyCallExpImpl": 15
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::ActivityPartition::isExternal",
          "UML::Class::nestedClassifier",
          "UML::ActivityPartition::represents",
          "UML::ActivityPartition::superPartition",
          "UML::TypedElement::type",
          "UML::Property::isComposite",
          "UML::BehavioredClassifier::ownedBehavior"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 3,
          "and": 3,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "represents_property",
        "body": "\n\t\t\trepresents.oclIsKindOf(Property) and\n\t\t\tsuperPartition->notEmpty() and\n\t\t\tsuperPartition.represents.oclIsKindOf(Classifier) implies\n\t\t\tlet\n\t\t\t  representedClassifier : Classifier = superPartition.represents.oclAsType(Classifier)\n\t\t\tin\n\t\t\t  superPartition.subpartition->reject(isExternal)\n\t\t\t  ->forAll(p |\n\t\t\t    p.represents.oclIsKindOf(Property) and p.owner = representedClassifier)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 9,
          "LetExpImpl": 1,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 11
        },
        "properties": [
          "UML::ActivityPartition::isExternal",
          "UML::ActivityPartition::superPartition",
          "UML::ActivityPartition::represents",
          "UML::Element::owner",
          "UML::ActivityPartition::subpartition"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "isEmpty": 1,
          "implies": 1
        },
        "name": "dimension_not_contained",
        "body": "\n\t\t\tisDimension implies superPartition->isEmpty()\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityPartition::isDimension",
          "UML::ActivityPartition::superPartition"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ExceptionHandler",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "conformsTo": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "exception_input_type",
        "body": "\n\t\t\texceptionInput.type = null or\n\t\t\texceptionType->forAll(\n\t\t\t  conformsTo(\n\t\t\t    exceptionInput.type.oclAsType(Classifier)))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ExceptionHandler::exceptionInput",
          "UML::TypedElement::type",
          "UML::ExceptionHandler::exceptionType"
        ]
      },
      {
        "operations": {
          "and": 1,
          "includes": 2,
          "allOwnedNodes": 1,
          "oclAsType": 1
        },
        "name": "edge_source_target",
        "body": "\n\t\t\tlet\n\t\t\t  nodes : Set(ActivityNode) = handlerBody.oclAsType(Action)\n\t\t\t  .allOwnedNodes()\n\t\t\tin\n\t\t\t  nodes.outgoing->forAll(nodes->includes(target)) and\n\t\t\t  nodes.incoming->forAll(nodes->includes(source))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 9,
          "LetExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ActivityEdge::source",
          "UML::ActivityNode::outgoing",
          "UML::ExceptionHandler::handlerBody",
          "UML::ActivityNode::incoming",
          "UML::ActivityEdge::target"
        ]
      },
      {
        "operations": {
          "at": 6,
          "size": 3,
          "compatibleWith": 1,
          "oclIsKindOf": 2,
          "and": 5,
          "conformsTo": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 2,
          "oclAsType": 3
        },
        "name": "output_pins",
        "body": "\n\t\t\tprotectedNode.oclIsKindOf(Action) and\n\t\t\tprotectedNode.oclAsType(Action)\n\t\t\t.output->notEmpty() implies\n\t\t\thandlerBody.oclIsKindOf(Action) and\n\t\t\tlet\n\t\t\t  protectedNodeOutput : OrderedSet(OutputPin) = protectedNode.oclAsType(Action).output\n\t\t\tin\n\t\t\t  let\n\t\t\t    handlerBodyOutput : OrderedSet(OutputPin) = handlerBody.oclAsType(Action).output\n\t\t\t  in\n\t\t\t    protectedNodeOutput->size() =\n\t\t\t    handlerBodyOutput->size() and\n\t\t\t    Sequence{1..protectedNodeOutput->size()\n\t\t\t    }\n\t\t\t    ->forAll(i |\n\t\t\t      handlerBodyOutput->at(i)\n\t\t\t      .type.conformsTo(protectedNodeOutput->at(i).type) and\n\t\t\t      handlerBodyOutput->at(i).isOrdered =\n\t\t\t      protectedNodeOutput->at(i).isOrdered and\n\t\t\t      handlerBodyOutput->at(i)\n\t\t\t      .compatibleWith(protectedNodeOutput->at(i)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 20,
          "OperationCallExpImpl": 25,
          "LetExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 5,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::ExceptionHandler::handlerBody",
          "UML::ExceptionHandler::protectedNode",
          "UML::Action::output",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "and": 2,
          "isEmpty": 3
        },
        "name": "handler_body_edges",
        "body": "\n\t\t\thandlerBody.incoming->isEmpty() and\n\t\t\thandlerBody.outgoing->isEmpty() and\n\t\t\texceptionInput.incoming->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ExceptionHandler::handlerBody",
          "UML::ActivityNode::incoming",
          "UML::ExceptionHandler::exceptionInput"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "handler_body_owner",
        "body": "\n\t\t\thandlerBody.owner = protectedNode.owner\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ExceptionHandler::handlerBody",
          "UML::ExceptionHandler::protectedNode",
          "UML::Element::owner"
        ]
      },
      {
        "operations": {
          "size": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "=": 2,
          "oclAsType": 1,
          "first": 1
        },
        "name": "one_input",
        "body": "\n\t\t\thandlerBody.oclIsKindOf(Action) and\n\t\t\tlet\n\t\t\t  inputs : OrderedSet(InputPin) = handlerBody.oclAsType(Action).input\n\t\t\tin inputs->size() = 1 and inputs->first() = exceptionInput\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 5,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Action::input",
          "UML::ExceptionHandler::handlerBody",
          "UML::ExceptionHandler::exceptionInput"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Port",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "port_aggregation",
        "body": "\n\t\t\taggregation = AggregationKind::composite\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Property::aggregation"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "oclAsSet": 1,
          "isEmpty": 1,
          "implies": 1
        },
        "name": "default_value",
        "body": "\n\t\t\ttype.oclIsKindOf(Interface) implies\n\t\t\tdefaultValue->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Property::defaultValue",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "encapsulated_owner",
        "body": "\n\t\t\towner = encapsulatedClassifier\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "OppositePropertyCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Element::owner"]
      }
    ],
    "properties": []
  },
  {
    "name": "ReadLinkAction",
    "expressions": [
      {
        "operations": {
          "compatibleWith": 1,
          "openEnd": 1,
          "first": 1
        },
        "name": "compatible_multiplicity",
        "body": "\n\t\t\tself.openEnd()->first().compatibleWith(result)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkAction::result"]
      },
      {
        "operations": {
          "openEnd": 1,
          "and": 1,
          "=": 2
        },
        "name": "type_and_ordering",
        "body": "\n\t\t\tself.openEnd()\n\t\t\t->forAll(type = result.type and isOrdered = result.isOrdered)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 5,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::ReadLinkAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "or": 2,
          "openEnd": 1,
          "and": 2,
          "conformsTo": 1,
          "=": 3,
          "oclAsType": 1,
          "first": 1
        },
        "name": "visibility",
        "body": "\n\t\t\tlet openEnd : Property = self.openEnd()->first()\n\t\t\tin openEnd.visibility = VisibilityKind::public or\n\t\t\t  endData->exists(oed | oed.end <> openEnd and\n\t\t\t    (_'context' = oed.end.type or openEnd.visibility = VisibilityKind::protected and\n\t\t\t      _'context'.conformsTo(\n\t\t\t        oed.end.type.oclAsType(Classifier))\n\t\t\t    ))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 10,
          "LetExpImpl": 1,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::Action::context",
          "UML::LinkAction::endData",
          "UML::NamedElement::visibility",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "openEnd": 1,
          "isNavigable": 1,
          "first": 1
        },
        "name": "navigable_open_end",
        "body": "\n\t\t\tself.openEnd()->first().isNavigable()\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "size": 1,
          "openEnd": 1,
          "=": 1
        },
        "name": "one_open_end",
        "body": "\n\t\t\tself.openEnd()->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 3,
          "IntegerLiteralExpImpl": 1
        },
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "PackageableElement",
    "expressions": [{
      "operations": {
        "implies": 1,
        "=": 2
      },
      "name": "namespace_needs_visibility",
      "body": "\n\t\t\tvisibility = null implies namespace = null\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 3,
        "VariableExpImpl": 2,
        "NullLiteralExpImpl": 2,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::PackageableElement::visibility",
        "UML::NamedElement::namespace"
      ]
    }],
    "properties": []
  },
  {
    "name": "Parameter",
    "expressions": [
      {
        "operations": {
          "notEmpty": 2,
          "implies": 1
        },
        "name": "connector_end",
        "body": "\n\t\t\tend->notEmpty() implies collaboration->notEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "OppositePropertyCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ConnectableElement::end"]
      },
      {
        "operations": {
          "<>": 2,
          "and": 1,
          "implies": 1
        },
        "name": "not_exception",
        "body": "\n\t\t\tisException implies direction <> ParameterDirectionKind::_'in' and direction <> ParameterDirectionKind::inout\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Parameter::isException",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "not": 1,
          "and": 1
        },
        "name": "stream_and_exception",
        "body": "\n\t\t\tnot (isException and isStream)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Parameter::isException",
          "UML::Parameter::isStream"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "not": 1,
          "and": 1,
          "implies": 1
        },
        "name": "reentrant_behaviors",
        "body": "\n\t\t\tisStream and behavior <> null implies not behavior.isReentrant\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "OppositePropertyCallExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Behavior::isReentrant",
          "UML::Parameter::isStream"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "implies": 1,
          "=": 1
        },
        "name": "object_effect",
        "body": "\n\t\t\ttype.oclIsKindOf(DataType) implies effect = null\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Parameter::effect",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "or": 3,
          "and": 1,
          "implies": 2,
          "=": 7
        },
        "name": "in_and_out",
        "body": "\n\t\t\t(effect = ParameterEffectKind::delete implies direction = ParameterDirectionKind::_'in' or direction = ParameterDirectionKind::inout\n\t\t\t) and\n\t\t\t(effect = ParameterEffectKind::create implies direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::return\n\t\t\t)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 13,
          "EnumLiteralExpImpl": 7,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::Parameter::effect",
          "UML::Parameter::direction"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Gate",
    "expressions": [
      {
        "operations": {
          "size": 1,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 1,
          "matches": 1
        },
        "name": "actual_gate_matched",
        "body": "\n\t\t\tinteractionUse->notEmpty() implies\n\t\t\tinteractionUse.refersTo.formalGate->select(matches(self))\n\t\t\t->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 6,
          "OppositePropertyCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Interaction::formalGate",
          "UML::InteractionUse::refersTo"
        ]
      },
      {
        "operations": {
          "getName": 2,
          "size": 1,
          "and": 1,
          "getOperand": 2,
          "implies": 1,
          "isInsideCF": 2,
          "=": 3
        },
        "name": "inside_cf_gate_distinguishable",
        "body": "\n\t\t\tisInsideCF() implies\n\t\t\tlet selfOperand : InteractionOperand = self.getOperand()\n\t\t\tin\n\t\t\t  combinedFragment.cfragmentGate->select(\n\t\t\t    (isInsideCF() and getName() = self.getName()\n\t\t\t    ))\n\t\t\t  ->select(getOperand() = selfOperand)\n\t\t\t  ->size() = 1\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 8,
          "LetExpImpl": 1,
          "OppositePropertyCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CombinedFragment::cfragmentGate"]
      },
      {
        "operations": {
          "getName": 2,
          "size": 1,
          "isOutsideCF": 1,
          "implies": 1,
          "=": 2
        },
        "name": "outside_cf_gate_distinguishable",
        "body": "\n\t\t\tisOutsideCF() implies\n\t\t\tcombinedFragment.cfragmentGate->select(getName() = self.getName())\n\t\t\t->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 7,
          "OppositePropertyCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CombinedFragment::cfragmentGate"]
      },
      {
        "operations": {
          "getName": 2,
          "size": 1,
          "isFormal": 1,
          "implies": 1,
          "=": 2
        },
        "name": "formal_gate_distinguishable",
        "body": "\n\t\t\tisFormal() implies\n\t\t\tinteraction.formalGate->select(getName() = self.getName())\n\t\t\t->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 7,
          "OppositePropertyCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Interaction::formalGate"]
      },
      {
        "operations": {
          "getName": 2,
          "isActual": 1,
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "actual_gate_distinguishable",
        "body": "\n\t\t\tisActual() implies\n\t\t\tinteractionUse.actualGate->select(getName() = self.getName())\n\t\t\t->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 7,
          "OppositePropertyCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InteractionUse::actualGate"]
      },
      {
        "operations": {
          "enclosingFragment": 1,
          "asOrderedSet": 1,
          "isOutsideCF": 1,
          "includes": 1,
          "matches": 2,
          "size": 2,
          "and": 3,
          "oclAsSet": 1,
          "implies": 1,
          "=": 3,
          "isInsideCF": 2,
          "oppositeEnd": 1,
          "first": 1
        },
        "name": "outside_cf_matched",
        "body": "\n\t\t\tisOutsideCF() implies\n\t\t\tif\n\t\t\t  self.combinedFragment.interactionOperator->asOrderedSet()\n\t\t\t  ->first() = InteractionOperatorKind::alt\n\t\t\tthen\n\t\t\t  self.combinedFragment.operand->forAll(op |\n\t\t\t    self.combinedFragment.cfragmentGate->select(\n\t\t\t      (\n\t\t\t        isInsideCF() and\n\t\t\t        oppositeEnd()\n\t\t\t        .enclosingFragment()\n\t\t\t        ->includes(self.combinedFragment) and\n\t\t\t        matches(self)\n\t\t\t      ))\n\t\t\t    ->size() = 1)\n\t\t\telse\n\t\t\t  self.combinedFragment.cfragmentGate->select(\n\t\t\t    (isInsideCF() and matches(self)\n\t\t\t    ))\n\t\t\t  ->size() = 1\n\t\t\tendif\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 14,
          "OperationCallExpImpl": 20,
          "OppositePropertyCallExpImpl": 5,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::CombinedFragment::cfragmentGate",
          "UML::CombinedFragment::operand",
          "UML::CombinedFragment::interactionOperator"
        ]
      },
      {
        "operations": {
          "size": 1,
          "and": 1,
          "isOutsideCF": 1,
          "implies": 1,
          "matches": 1,
          "=": 1,
          "isInsideCF": 1
        },
        "name": "inside_cf_matched",
        "body": "\n\t\t\tisInsideCF() implies\n\t\t\tcombinedFragment.cfragmentGate->select(\n\t\t\t  (isOutsideCF() and matches(self)\n\t\t\t  ))\n\t\t\t->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 7,
          "OppositePropertyCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CombinedFragment::cfragmentGate"]
      }
    ],
    "properties": []
  },
  {
    "name": "BroadcastSignalAction",
    "expressions": [
      {
        "operations": {
          "at": 6,
          "size": 1,
          "compatibleWith": 1,
          "and": 2,
          "allAttributes": 1,
          "conformsTo": 1,
          "=": 1
        },
        "name": "type_ordering_multiplicity",
        "body": "\n\t\t\tlet attribute : OrderedSet(Property) = signal.allAttributes()\n\t\t\tin\n\t\t\t  Sequence{1..argument->size()\n\t\t\t  }\n\t\t\t  ->forAll(i |\n\t\t\t    argument->at(i)\n\t\t\t    .type.conformsTo(attribute->at(i).type) and\n\t\t\t    argument->at(i).isOrdered =\n\t\t\t    attribute->at(i).isOrdered and\n\t\t\t    argument->at(i)\n\t\t\t    .compatibleWith(attribute->at(i)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 14,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::BroadcastSignalAction::signal",
          "UML::InvocationAction::argument",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "no_onport",
        "body": "\n\t\t\tonPort = null\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InvocationAction::onPort"]
      },
      {
        "operations": {
          "size": 2,
          "allAttributes": 1,
          "=": 1
        },
        "name": "number_of_arguments",
        "body": "\n\t\t\targument->size() = signal.allAttributes()->size()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::BroadcastSignalAction::signal",
          "UML::InvocationAction::argument"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Constraint",
    "expressions": [
      {
        "operations": {},
        "name": "boolean_value",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "no_side_effects",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "not": 1,
          "includes": 1
        },
        "name": "not_apply_to_self",
        "body": "\n\t\t\tnot constrainedElement->includes(self)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Constraint::constrainedElement"]
      }
    ],
    "properties": []
  },
  {
    "name": "InteractionOperand",
    "expressions": [
      {
        "operations": {},
        "name": "guard_contain_references",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "guard_directly_prior",
        "body": "\n\t\t\tnull\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "Lifeline",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2,
          "oclAsSet": 1,
          "notEmpty": 1,
          "implies": 1
        },
        "name": "selector_int_or_string",
        "body": "\n\t\t\tself.selector->notEmpty() implies\n\t\t\tself.selector.oclIsKindOf(LiteralInteger) or\n\t\t\tself.selector.oclIsKindOf(LiteralString)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": ["UML::Lifeline::selector"]
      },
      {
        "operations": {
          "oclIsKindOf": 12,
          "and": 8,
          "excluding": 1,
          "oclAsSet": 2,
          "union": 2,
          "asSet": 6,
          "implies": 5,
          "=": 6,
          "oclAsType": 12
        },
        "name": "interaction_uses_share_lifeline",
        "body": "\n\t\t\tlet intUses : Set(InteractionUse) = interaction.interactionUse\n\t\t\tin\n\t\t\t  intUses->forAll(iuse |\n\t\t\t    let\n\t\t\t      usingInteraction : Set(Interaction) = iuse.enclosingInteraction->asSet()\n\t\t\t      ->union(\n\t\t\t        iuse.enclosingOperand.combinedFragment->asSet()\n\t\t\t        ->closure(enclosingOperand.combinedFragment)\n\t\t\t        .enclosingInteraction->asSet())\n\t\t\t    in\n\t\t\t      let\n\t\t\t        peerUses : Set(InteractionUse) = usingInteraction.fragment->select(\n\t\t\t          oclIsKindOf(InteractionUse))\n\t\t\t        .oclAsType(InteractionUse)\n\t\t\t        ->asSet()\n\t\t\t        ->union(\n\t\t\t          usingInteraction.fragment->select(\n\t\t\t            oclIsKindOf(CombinedFragment))\n\t\t\t          .oclAsType(CombinedFragment)\n\t\t\t          ->asSet()\n\t\t\t          ->closure(\n\t\t\t            operand.fragment->select(\n\t\t\t              oclIsKindOf(CombinedFragment))\n\t\t\t            .oclAsType(CombinedFragment))\n\t\t\t          .operand.fragment->select(\n\t\t\t            oclIsKindOf(InteractionUse))\n\t\t\t          .oclAsType(InteractionUse)\n\t\t\t          ->asSet())\n\t\t\t        ->excluding(iuse)\n\t\t\t      in\n\t\t\t        peerUses->forAll(peerUse |\n\t\t\t          peerUse.refersTo.lifeline->forAll(l | l.represents = self.represents and\n\t\t\t            (\n\t\t\t              self.selector.oclIsKindOf(LiteralString) implies\n\t\t\t              l.selector.oclIsKindOf(LiteralString) and\n\t\t\t              self.selector.oclAsType(LiteralString).value =\n\t\t\t              l.selector.oclAsType(LiteralString).value\n\t\t\t            ) and\n\t\t\t            (\n\t\t\t              self.selector.oclIsKindOf(LiteralInteger) implies\n\t\t\t              l.selector.oclIsKindOf(LiteralInteger) and\n\t\t\t              self.selector.oclAsType(LiteralInteger).value =\n\t\t\t              l.selector.oclAsType(LiteralInteger).value\n\t\t\t            ) implies\n\t\t\t            usingInteraction.lifeline->exists(represents = self.represents and\n\t\t\t              (\n\t\t\t                self.selector.oclIsKindOf(LiteralString) implies\n\t\t\t                l.selector.oclIsKindOf(LiteralString) and\n\t\t\t                self.selector.oclAsType(LiteralString).value =\n\t\t\t                l.selector.oclAsType(LiteralString).value\n\t\t\t              ) and\n\t\t\t              (\n\t\t\t                self.selector.oclIsKindOf(LiteralInteger) implies\n\t\t\t                l.selector.oclIsKindOf(LiteralInteger) and\n\t\t\t                self.selector.oclAsType(LiteralInteger).value =\n\t\t\t                l.selector.oclAsType(LiteralInteger).value\n\t\t\t              )))))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 21,
          "OperationCallExpImpl": 54,
          "VariableExpImpl": 47,
          "LetExpImpl": 3,
          "OppositePropertyCallExpImpl": 3,
          "TypeExpImpl": 24,
          "PropertyCallExpImpl": 42
        },
        "properties": [
          "UML::LiteralString::value",
          "UML::CombinedFragment::operand",
          "UML::LiteralInteger::value",
          "UML::Interaction::lifeline",
          "UML::InteractionFragment::enclosingOperand",
          "UML::InteractionOperand::fragment",
          "UML::Interaction::fragment",
          "UML::Lifeline::represents",
          "UML::Lifeline::selector",
          "UML::InteractionUse::refersTo",
          "UML::Lifeline::interaction",
          "UML::InteractionFragment::enclosingInteraction"
        ]
      },
      {
        "operations": {
          "isMultivalued": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "notEmpty": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "selector_specified",
        "body": "\n\t\t\tself.selector->notEmpty() =\n\t\t\t(\n\t\t\t  self.represents.oclIsKindOf(MultiplicityElement) and\n\t\t\t  self.represents.oclAsType(MultiplicityElement)\n\t\t\t  .isMultivalued()\n\t\t\t)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Lifeline::represents",
          "UML::Lifeline::selector"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "includes": 1
        },
        "name": "same_classifier",
        "body": "\n\t\t\trepresents.namespace->closure(namespace)\n\t\t\t->includes(interaction._'context')\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Behavior::context",
          "UML::NamedElement::namespace",
          "UML::Lifeline::represents",
          "UML::Lifeline::interaction"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Continuation",
    "expressions": [
      {
        "operations": {
          "and": 2,
          "oclAsSet": 1,
          "includes": 1,
          "notEmpty": 2
        },
        "name": "global",
        "body": "\n\t\t\tenclosingOperand->notEmpty() and\n\t\t\tlet operandLifelines : Set(Lifeline) = enclosingOperand.covered\n\t\t\tin\n\t\t\t  operandLifelines->notEmpty() and\n\t\t\t  operandLifelines->forAll(ol | self.covered->includes(ol))\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 6,
          "LetExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::InteractionFragment::covered",
          "UML::InteractionFragment::enclosingOperand"
        ]
      },
      {
        "operations": {
          "size": 3,
          "oclIsKindOf": 4,
          "and": 7,
          "oclAsSet": 2,
          "union": 1,
          "notEmpty": 3,
          "asSet": 12,
          "implies": 1,
          "=": 8,
          "oclAsType": 5
        },
        "name": "same_name",
        "body": "\n\t\t\tenclosingOperand.combinedFragment->notEmpty() and\n\t\t\tlet\n\t\t\t  parentInteraction : Set(Interaction) = enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)\n\t\t\t  ->collect(enclosingInteraction)\n\t\t\t  .oclAsType(Interaction)\n\t\t\t  ->asSet()\n\t\t\tin\n\t\t\t  parentInteraction->size() = 1 and\n\t\t\t  let\n\t\t\t    peerInteractions : Set(Interaction) = parentInteraction->union(\n\t\t\t      parentInteraction->collect(_'context')\n\t\t\t      ->collect(behavior)\n\t\t\t      ->select(oclIsKindOf(Interaction))\n\t\t\t      .oclAsType(Interaction)\n\t\t\t      ->asSet())\n\t\t\t    ->asSet()\n\t\t\t  in\n\t\t\t    peerInteractions->notEmpty() and\n\t\t\t    let\n\t\t\t      combinedFragments1 : Set(CombinedFragment) = peerInteractions.fragment->select(\n\t\t\t        oclIsKindOf(CombinedFragment))\n\t\t\t      .oclAsType(CombinedFragment)\n\t\t\t      ->asSet()\n\t\t\t    in\n\t\t\t      combinedFragments1->notEmpty() and\n\t\t\t      combinedFragments1->closure(\n\t\t\t        operand.fragment->select(\n\t\t\t          oclIsKindOf(CombinedFragment))\n\t\t\t        .oclAsType(CombinedFragment))\n\t\t\t      ->asSet()\n\t\t\t      .operand.fragment->select(\n\t\t\t        oclIsKindOf(Continuation))\n\t\t\t      .oclAsType(Continuation)\n\t\t\t      ->asSet()\n\t\t\t      ->forAll(c |\n\t\t\t        (c.name = self.name implies\n\t\t\t          c.covered->asSet()\n\t\t\t          ->forAll(cl |\n\t\t\t            self.covered->asSet()\n\t\t\t            ->select(\n\t\t\t              (represents = cl.represents and selector = cl.selector\n\t\t\t              ))\n\t\t\t            ->asSet()\n\t\t\t            ->size() = 1) and\n\t\t\t          self.covered->asSet()\n\t\t\t          ->forAll(cl |\n\t\t\t            c.covered->asSet()\n\t\t\t            ->select(\n\t\t\t              (represents = cl.represents and selector = cl.selector\n\t\t\t              ))\n\t\t\t            ->asSet()\n\t\t\t            ->size() = 1)\n\t\t\t        ))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 23,
          "VariableExpImpl": 41,
          "OperationCallExpImpl": 46,
          "LetExpImpl": 3,
          "OppositePropertyCallExpImpl": 4,
          "IntegerLiteralExpImpl": 3,
          "TypeExpImpl": 9,
          "PropertyCallExpImpl": 24
        },
        "properties": [
          "UML::CombinedFragment::operand",
          "UML::InteractionFragment::covered",
          "UML::Behavior::context",
          "UML::InteractionFragment::enclosingOperand",
          "UML::Lifeline::represents",
          "UML::Interaction::fragment",
          "UML::InteractionOperand::fragment",
          "UML::Lifeline::selector",
          "UML::InteractionFragment::enclosingInteraction",
          "UML::NamedElement::name"
        ]
      },
      {
        "operations": {
          "or": 1,
          "last": 1,
          "and": 2,
          "oclAsSet": 1,
          "notEmpty": 2,
          "=": 2,
          "first": 1
        },
        "name": "first_or_last_interaction_fragment",
        "body": "\n\t\t\tenclosingOperand->notEmpty() and\n\t\t\tlet peerFragments : OrderedSet(InteractionFragment) = enclosingOperand.fragment\n\t\t\tin\n\t\t\t  peerFragments->notEmpty() and\n\t\t\t  (peerFragments->first() = self or peerFragments->last() = self\n\t\t\t  )\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 7,
          "LetExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::InteractionFragment::enclosingOperand",
          "UML::InteractionOperand::fragment"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Element",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "allOwnedElements": 1,
          "includes": 1
        },
        "name": "not_own_self",
        "body": "\n\t\t\tnot allOwnedElements()->includes(self)\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3
        },
        "properties": []
      },
      {
        "operations": {
          "mustBeOwned": 1,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1
        },
        "name": "has_owner",
        "body": "\n\t\t\tmustBeOwned() implies owner->notEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Element::owner"]
      }
    ],
    "properties": []
  },
  {
    "name": "AcceptCallAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "unmarshall",
        "body": "\n\t\t\tisUnmarshall = true\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "BooleanLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::AcceptEventAction::isUnmarshall"]
      },
      {
        "operations": {
          "size": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "=": 1,
          "first": 1,
          "asSequence": 1
        },
        "name": "trigger_call_event",
        "body": "\n\t\t\ttrigger->size() = 1 and\n\t\t\ttrigger->asSequence()\n\t\t\t->first()\n\t\t\t.event.oclIsKindOf(CallEvent)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 6,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::AcceptEventAction::trigger",
          "UML::Trigger::event"
        ]
      },
      {
        "operations": {
          "at": 6,
          "size": 3,
          "compatibleWith": 1,
          "and": 3,
          "conformsTo": 1,
          "=": 2,
          "oclAsType": 1,
          "inputParameters": 1,
          "first": 1,
          "asSequence": 1
        },
        "name": "result_pins",
        "body": "\n\t\t\tlet\n\t\t\t  parameter : OrderedSet(Parameter) = trigger.event->asSequence()\n\t\t\t  ->first()\n\t\t\t  .oclAsType(CallEvent)\n\t\t\t  .operation.inputParameters()\n\t\t\tin\n\t\t\t  result->size() =\n\t\t\t  parameter->size() and\n\t\t\t  Sequence{1..result->size()\n\t\t\t  }\n\t\t\t  ->forAll(i |\n\t\t\t    parameter->at(i)\n\t\t\t    .type.conformsTo(result->at(i).type) and\n\t\t\t    parameter->at(i).isOrdered =\n\t\t\t    result->at(i).isOrdered and\n\t\t\t    parameter->at(i)\n\t\t\t    .compatibleWith(result->at(i)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 20,
          "VariableExpImpl": 17,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::CallEvent::operation",
          "UML::AcceptEventAction::result",
          "UML::Trigger::event",
          "UML::AcceptEventAction::trigger",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "OpaqueAction",
    "expressions": [{
      "operations": {
        "size": 2,
        "implies": 1,
        "notEmpty": 1,
        "=": 1
      },
      "name": "language_body_size",
      "body": "\n\t\t\tlanguage->notEmpty() implies _'body'->size() = language->size()\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 5,
        "VariableExpImpl": 3,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::OpaqueAction::body",
        "UML::OpaqueAction::language"
      ]
    }],
    "properties": []
  },
  {
    "name": "QualifierValue",
    "expressions": [
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity_of_qualifier",
        "body": "\n\t\t\tvalue.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::QualifierValue::value"]
      },
      {
        "operations": {"conformsTo": 1},
        "name": "type_of_qualifier",
        "body": "\n\t\t\tvalue.type.conformsTo(qualifier.type)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::QualifierValue::qualifier",
          "UML::QualifierValue::value",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"includes": 1},
        "name": "qualifier_attribute",
        "body": "\n\t\t\tlinkEndData.end.qualifier->includes(qualifier)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "OppositePropertyCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::QualifierValue::qualifier",
          "UML::Property::qualifier"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Pseudostate",
    "expressions": [
      {
        "operations": {
          "size": 2,
          "and": 1,
          "implies": 1,
          "=": 1,
          ">=": 2
        },
        "name": "choice_vertex",
        "body": "\n\t\t\tkind = PseudostateKind::choice implies\n\t\t\tincoming->size() >= 1 and\n\t\t\toutgoing->size() >= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 7,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Vertex::incoming",
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing"
        ]
      },
      {
        "operations": {
          "and": 1,
          "isEmpty": 1,
          "implies": 1,
          "=": 2
        },
        "name": "outgoing_from_initial",
        "body": "\n\t\t\tkind = PseudostateKind::initial implies outgoing.guard = null and\n\t\t\toutgoing.trigger->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Transition::trigger",
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing",
          "UML::Transition::guard"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "or": 1,
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "history_vertices",
        "body": "\n\t\t\tkind = PseudostateKind::deepHistory or kind = PseudostateKind::shallowHistory implies\n\t\t\toutgoing->size() <= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 6,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 1,
          "implies": 1,
          "=": 2,
          ">=": 1
        },
        "name": "fork_vertex",
        "body": "\n\t\t\tkind = PseudostateKind::fork implies\n\t\t\tincoming->size() = 1 and\n\t\t\toutgoing->size() >= 2\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 7,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Vertex::incoming",
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing"
        ]
      },
      {
        "operations": {
          "isContainedInRegion": 2,
          "<>": 2,
          "and": 3,
          "LCAState": 1,
          "implies": 1,
          "=": 1,
          "containingStateMachine": 1
        },
        "name": "transitions_outgoing",
        "body": "\n\t\t\tkind = PseudostateKind::fork implies\n\t\t\toutgoing->forAll(t1, t2 |\n\t\t\t  let\n\t\t\t    contState : State = containingStateMachine()\n\t\t\t    .LCAState(t1.target, t2.target)\n\t\t\t  in contState <> null and\n\t\t\t    contState.region->exists(r1, r2 | r1 <> r2 and\n\t\t\t      t1.target.isContainedInRegion(r1) and\n\t\t\t      t2.target.isContainedInRegion(r2)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 13,
          "OperationCallExpImpl": 11,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::Transition::target",
          "UML::State::region",
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "implies": 1,
          "=": 1
        },
        "name": "initial_vertex",
        "body": "\n\t\t\tkind = PseudostateKind::initial implies outgoing->size() <= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 1,
          "implies": 1,
          "=": 2,
          ">=": 1
        },
        "name": "join_vertex",
        "body": "\n\t\t\tkind = PseudostateKind::join implies\n\t\t\toutgoing->size() = 1 and\n\t\t\tincoming->size() >= 2\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Vertex::incoming",
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing"
        ]
      },
      {
        "operations": {
          "isContainedInRegion": 2,
          "<>": 2,
          "and": 3,
          "LCAState": 1,
          "implies": 1,
          "=": 1,
          "containingStateMachine": 1
        },
        "name": "transitions_incoming",
        "body": "\n\t\t\tkind = PseudostateKind::join implies\n\t\t\tincoming->forAll(t1, t2 |\n\t\t\t  let\n\t\t\t    contState : State = containingStateMachine()\n\t\t\t    .LCAState(t1.source, t2.source)\n\t\t\t  in contState <> null and\n\t\t\t    contState.region->exists(r1, r2 | r1 <> r2 and\n\t\t\t      t1.source.isContainedInRegion(r1) and\n\t\t\t      t2.source.isContainedInRegion(r2)))\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 13,
          "OperationCallExpImpl": 11,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::State::region",
          "UML::Vertex::incoming",
          "UML::Transition::source",
          "UML::Pseudostate::kind"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 1,
          "implies": 1,
          "=": 1,
          ">=": 2
        },
        "name": "junction_vertex",
        "body": "\n\t\t\tkind = PseudostateKind::junction implies\n\t\t\tincoming->size() >= 1 and\n\t\t\toutgoing->size() >= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Vertex::incoming",
          "UML::Pseudostate::kind",
          "UML::Vertex::outgoing"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ReduceAction",
    "expressions": [
      {
        "operations": {},
        "name": "input_type_is_collection",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "conformsTo": 1,
          "outputParameters": 1
        },
        "name": "output_types_are_compatible",
        "body": "\n\t\t\treducer.outputParameters()\n\t\t\t.type->forAll(conformsTo(result.type))\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ReduceAction::result",
          "UML::ReduceAction::reducer",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "size": 2,
          "upperBound": 1,
          "and": 3,
          "conformsTo": 2,
          "implies": 1,
          "=": 2,
          "inputParameters": 1,
          ">": 1,
          "outputParameters": 1
        },
        "name": "reducer_inputs_output",
        "body": "\n\t\t\tlet inputs : OrderedSet(Parameter) = reducer.inputParameters()\n\t\t\tin\n\t\t\t  let\n\t\t\t    outputs : OrderedSet(Parameter) = reducer.outputParameters()\n\t\t\t  in\n\t\t\t    inputs->size() = 2 and\n\t\t\t    outputs->size() = 1 and\n\t\t\t    inputs.type->forAll(t |\n\t\t\t      (\n\t\t\t        outputs.type->forAll(conformsTo(t)) and\n\t\t\t        collection.upperBound() > 1 implies\n\t\t\t        collection.type.conformsTo(t)\n\t\t\t      ))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 14,
          "VariableExpImpl": 13,
          "LetExpImpl": 2,
          "IntegerLiteralExpImpl": 3,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::ReduceAction::collection",
          "UML::TypedElement::type",
          "UML::ReduceAction::reducer"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "CreateObjectAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "same_type",
        "body": "\n\t\t\tresult.type = classifier\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::CreateObjectAction::classifier",
          "UML::CreateObjectAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"not": 1},
        "name": "classifier_not_abstract",
        "body": "\n\t\t\tnot classifier.isAbstract\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::CreateObjectAction::classifier",
          "UML::Classifier::isAbstract"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsKindOf": 1
        },
        "name": "classifier_not_association_class",
        "body": "\n\t\t\tnot classifier.oclIsKindOf(AssociationClass)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CreateObjectAction::classifier"]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\tresult.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CreateObjectAction::result"]
      }
    ],
    "properties": []
  },
  {
    "name": "JoinNode",
    "expressions": [
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "one_outgoing_edge",
        "body": "\n\t\t\toutgoing->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::outgoing"]
      },
      {
        "operations": {"oclIsKindOf": 3},
        "name": "incoming_object_flow",
        "body": "\n\t\t\tif\n\t\t\t  incoming->exists(oclIsKindOf(ObjectFlow))\n\t\t\tthen\n\t\t\t  outgoing->forAll(oclIsKindOf(ObjectFlow))\n\t\t\telse\n\t\t\t  outgoing->forAll(oclIsKindOf(ControlFlow))\n\t\t\tendif\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 3,
          "TypeExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Interaction",
    "expressions": [{
      "operations": {
        "isEmpty": 1,
        "oclAsSet": 1
      },
      "name": "not_contained",
      "body": "\n\t\t\tenclosingInteraction->isEmpty()\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::InteractionFragment::enclosingInteraction"]
    }],
    "properties": []
  },
  {
    "name": "LoopNode",
    "expressions": [
      {
        "operations": {
          "includesAll": 1,
          "allActions": 1,
          "oclAsType": 1
        },
        "name": "body_output_pins",
        "body": "\n\t\t\tbodyPart.oclAsType(Action)\n\t\t\t.allActions()\n\t\t\t.output->includesAll(bodyOutput)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LoopNode::bodyPart",
          "UML::Action::output",
          "UML::LoopNode::bodyOutput"
        ]
      },
      {
        "operations": {
          "includesAll": 1,
          "allOwnedNodes": 1
        },
        "name": "loop_variable_outgoing",
        "body": "\n\t\t\tallOwnedNodes()\n\t\t\t->includesAll(loopVariable.outgoing.target)\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LoopNode::loopVariable",
          "UML::ActivityNode::outgoing",
          "UML::ActivityEdge::target"
        ]
      },
      {
        "operations": {"isEmpty": 1},
        "name": "input_edges",
        "body": "\n\t\t\tloopVariableInput.outgoing->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::LoopNode::loopVariableInput",
          "UML::ActivityNode::outgoing"
        ]
      },
      {
        "operations": {"isEmpty": 1},
        "name": "result_no_incoming",
        "body": "\n\t\t\tresult.incoming->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::LoopNode::result",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "and": 2,
          "intersection": 3,
          "isEmpty": 3
        },
        "name": "setup_test_and_body",
        "body": "\n\t\t\tsetupPart->intersection(test)\n\t\t\t->isEmpty() and\n\t\t\tsetupPart->intersection(bodyPart)\n\t\t\t->isEmpty() and\n\t\t\ttest->intersection(bodyPart)\n\t\t\t->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 8,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::LoopNode::bodyPart",
          "UML::LoopNode::test",
          "UML::LoopNode::setupPart"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 4,
          "=": 5
        },
        "name": "matching_result_pins",
        "body": "\n\t\t\tresult->size() =\n\t\t\tloopVariable->size() and result.type = loopVariable.type and result.isUnique = loopVariable.isUnique and result.lower = loopVariable.lower and result.upper = loopVariable.upper\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 8,
          "VariableExpImpl": 18,
          "OperationCallExpImpl": 11,
          "PropertyCallExpImpl": 18
        },
        "properties": [
          "UML::LoopNode::result",
          "UML::LoopNode::loopVariable",
          "UML::MultiplicityElement::isUnique",
          "UML::MultiplicityElement::lower",
          "UML::TypedElement::type",
          "UML::MultiplicityElement::upper"
        ]
      },
      {
        "operations": {
          "size": 2,
          "and": 4,
          "=": 5
        },
        "name": "matching_loop_variables",
        "body": "\n\t\t\tloopVariableInput->size() =\n\t\t\tloopVariable->size() and loopVariableInput.type = loopVariable.type and loopVariableInput.isUnique = loopVariable.isUnique and loopVariableInput.lower = loopVariable.lower and loopVariableInput.upper = loopVariable.upper\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 8,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 18,
          "PropertyCallExpImpl": 18
        },
        "properties": [
          "UML::LoopNode::loopVariableInput",
          "UML::LoopNode::loopVariable",
          "UML::MultiplicityElement::lower",
          "UML::MultiplicityElement::isUnique",
          "UML::TypedElement::type",
          "UML::MultiplicityElement::upper"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "union": 2,
          "asSet": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "executable_nodes",
        "body": "\n\t\t\tsetupPart->union(test)\n\t\t\t->union(bodyPart) =\n\t\t\tnode->select(oclIsKindOf(ExecutableNode))\n\t\t\t.oclAsType(ExecutableNode)\n\t\t\t->asSet()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 6,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::LoopNode::bodyPart",
          "UML::LoopNode::test",
          "UML::LoopNode::setupPart",
          "UML::StructuredActivityNode::node"
        ]
      },
      {
        "operations": {
          "at": 8,
          "size": 3,
          "and": 4,
          "includesMultiplicity": 1,
          "conformsTo": 1,
          "=": 3
        },
        "name": "matching_output_pins",
        "body": "\n\t\t\tbodyOutput->size() =\n\t\t\tloopVariable->size() and\n\t\t\tSequence{1..loopVariable->size()\n\t\t\t}\n\t\t\t->forAll(i |\n\t\t\t  bodyOutput->at(i)\n\t\t\t  .type.conformsTo(loopVariable->at(i).type) and\n\t\t\t  bodyOutput->at(i).isOrdered =\n\t\t\t  loopVariable->at(i).isOrdered and\n\t\t\t  bodyOutput->at(i).isUnique =\n\t\t\t  loopVariable->at(i).isUnique and\n\t\t\t  loopVariable->at(i)\n\t\t\t  .includesMultiplicity(bodyOutput->at(i)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 19,
          "OperationCallExpImpl": 20,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 17
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::LoopNode::loopVariable",
          "UML::MultiplicityElement::isUnique",
          "UML::LoopNode::bodyOutput",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "AddStructuralFeatureValueAction",
    "expressions": [
      {
        "operations": {"<>": 1},
        "name": "required_value",
        "body": "\n\t\t\tvalue <> null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::WriteStructuralFeatureAction::value"]
      },
      {
        "operations": {
          "<>": 1,
          "not": 2,
          "and": 2,
          "oclAsSet": 1,
          "is": 1,
          "implies": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "insertAt_pin",
        "body": "\n\t\t\tif not structuralFeature.isOrdered\n\t\t\tthen insertAt = null\n\t\t\telse not isReplaceAll implies insertAt <> null and\n\t\t\t  insertAt->forAll(type = UnlimitedNatural and\n\t\t\t    is(1, 1.oclAsType(UnlimitedNatural)))\n\t\t\tendif\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 7,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::AddStructuralFeatureValueAction::insertAt",
          "UML::AddStructuralFeatureValueAction::isReplaceAll",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Actor",
    "expressions": [
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "must_have_name",
        "body": "\n\t\t\tname->notEmpty()\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::NamedElement::name"]
      },
      {
        "operations": {
          "not": 1,
          "or": 1,
          "size": 1,
          "oclIsKindOf": 3,
          "and": 2,
          "allInstances": 1,
          "includes": 1,
          "implies": 1,
          "=": 2
        },
        "name": "associations",
        "body": "\n\t\t\tAssociation.allInstances()\n\t\t\t->forAll(a |\n\t\t\t  a.memberEnd->collect(type)\n\t\t\t  ->includes(self) implies\n\t\t\t  a.memberEnd->size() = 2 and\n\t\t\t  let actorEnd : Property = a.memberEnd->any(type = self)\n\t\t\t  in\n\t\t\t    (\n\t\t\t      actorEnd.opposite.class.oclIsKindOf(UseCase) or\n\t\t\t      actorEnd.opposite.class.oclIsKindOf(Class) and\n\t\t\t      not actorEnd.opposite.class.oclIsKindOf(Behavior)\n\t\t\t    ))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 10,
          "OperationCallExpImpl": 13,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 11
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::Property::class",
          "UML::Property::opposite",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "CallAction",
    "expressions": [
      {
        "operations": {
          "at": 6,
          "compatibleWith": 1,
          "size": 3,
          "and": 3,
          "conformsTo": 1,
          "=": 2,
          "outputParameters": 1
        },
        "name": "result_pins",
        "body": "\n\t\t\tlet\n\t\t\t  parameter : OrderedSet(Parameter) = self.outputParameters()\n\t\t\tin\n\t\t\t  result->size() =\n\t\t\t  parameter->size() and\n\t\t\t  Sequence{1..result->size()\n\t\t\t  }\n\t\t\t  ->forAll(i |\n\t\t\t    parameter->at(i)\n\t\t\t    .type.conformsTo(result->at(i).type) and\n\t\t\t    parameter->at(i).isOrdered =\n\t\t\t    result->at(i).isOrdered and\n\t\t\t    parameter->at(i)\n\t\t\t    .compatibleWith(result->at(i)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 17,
          "VariableExpImpl": 16,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::CallAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "notEmpty": 1
        },
        "name": "synchronous_call",
        "body": "\n\t\t\tresult->notEmpty() implies isSynchronous\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::CallAction::result",
          "UML::CallAction::isSynchronous"
        ]
      },
      {
        "operations": {
          "at": 6,
          "size": 3,
          "compatibleWith": 1,
          "and": 3,
          "conformsTo": 1,
          "=": 2,
          "inputParameters": 1
        },
        "name": "argument_pins",
        "body": "\n\t\t\tlet parameter : OrderedSet(Parameter) = self.inputParameters()\n\t\t\tin\n\t\t\t  argument->size() =\n\t\t\t  parameter->size() and\n\t\t\t  Sequence{1..argument->size()\n\t\t\t  }\n\t\t\t  ->forAll(i |\n\t\t\t    argument->at(i)\n\t\t\t    .type.conformsTo(parameter->at(i).type) and\n\t\t\t    argument->at(i).isOrdered =\n\t\t\t    parameter->at(i).isOrdered and\n\t\t\t    argument->at(i)\n\t\t\t    .compatibleWith(parameter->at(i)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 16,
          "OperationCallExpImpl": 17,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::InvocationAction::argument",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "InterruptibleActivityRegion",
    "expressions": [{
      "operations": {
        "excludes": 1,
        "and": 2,
        "includes": 1,
        "oclBadOperation": 1,
        "=": 1
      },
      "name": "interrupting_edges",
      "body": "\n\t\t\tinterruptingEdge->forAll(edge |\n\t\t\t  node->includes(edge.source) and\n\t\t\t  node->excludes(edge.target) and\n\t\t\t  edge.target.containingActivity() = inActivity)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 7,
        "OperationCallExpImpl": 6,
        "PropertyCallExpImpl": 7
      },
      "properties": [
        "UML::ActivityEdge::source",
        "UML::ActivityGroup::inActivity",
        "UML::InterruptibleActivityRegion::node",
        "UML::InterruptibleActivityRegion::interruptingEdge",
        "UML::ActivityEdge::target"
      ]
    }],
    "properties": []
  },
  {
    "name": "WriteLinkAction",
    "expressions": [{
      "operations": {
        "<>": 1,
        "or": 2,
        "and": 2,
        "conformsTo": 1,
        "=": 3,
        "oclAsType": 1
      },
      "name": "allow_access",
      "body": "\n\t\t\tendData.end->exists(end | end.type = _'context' or end.visibility = VisibilityKind::public or end.visibility = VisibilityKind::protected and\n\t\t\t  endData.end->exists(other | other <> end and\n\t\t\t    _'context'.conformsTo(\n\t\t\t      other.type.oclAsType(Classifier))))\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 4,
        "OperationCallExpImpl": 10,
        "VariableExpImpl": 12,
        "EnumLiteralExpImpl": 2,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 10
      },
      "properties": [
        "UML::LinkEndData::end",
        "UML::Action::context",
        "UML::LinkAction::endData",
        "UML::NamedElement::visibility",
        "UML::TypedElement::type"
      ]
    }],
    "properties": []
  },
  {
    "name": "StringExpression",
    "expressions": [
      {
        "operations": {
          "isEmpty": 1,
          "notEmpty": 2
        },
        "name": "subexpressions",
        "body": "\n\t\t\tif subExpression->notEmpty()\n\t\t\tthen operand->isEmpty()\n\t\t\telse operand->notEmpty()\n\t\t\tendif\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Expression::operand",
          "UML::StringExpression::subExpression"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "operands",
        "body": "\n\t\t\toperand->forAll(oclIsKindOf(LiteralString))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Expression::operand"]
      }
    ],
    "properties": []
  },
  {
    "name": "TimeEvent",
    "expressions": [{
      "operations": {
        "integerValue": 1,
        ">=": 1
      },
      "name": "when_non_negative",
      "body": "\n\t\t\twhen.integerValue() >= 0\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::TimeEvent::when"]
    }],
    "properties": []
  },
  {
    "name": "ReadVariableAction",
    "expressions": [
      {
        "operations": {"compatibleWith": 1},
        "name": "compatible_multiplicity",
        "body": "\n\t\t\tvariable.compatibleWith(result)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::VariableAction::variable",
          "UML::ReadVariableAction::result"
        ]
      },
      {
        "operations": {
          "and": 1,
          "=": 2
        },
        "name": "type_and_ordering",
        "body": "\n\t\t\tresult.type = variable.type and result.isOrdered = variable.isOrdered\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::VariableAction::variable",
          "UML::ReadVariableAction::result",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "GeneralizationSet",
    "expressions": [
      {
        "operations": {
          "not": 4,
          "<>": 1,
          "and": 3,
          "allParents": 2,
          "includes": 2,
          "implies": 1,
          "=": 2
        },
        "name": "maps_to_generalization_set",
        "body": "\n\t\t\tpowertype <> null implies\n\t\t\tgeneralization->forAll(gen |\n\t\t\t  not (gen.general = powertype\n\t\t\t  ) and\n\t\t\t  not gen.general.allParents()\n\t\t\t  ->includes(powertype) and\n\t\t\t  not (gen.specific = powertype\n\t\t\t  ) and\n\t\t\t  not powertype.allParents()\n\t\t\t  ->includes(gen.specific))\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 15,
          "VariableExpImpl": 10,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::GeneralizationSet::powertype",
          "UML::Generalization::specific",
          "UML::Generalization::general",
          "UML::GeneralizationSet::generalization"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "asSet": 1
        },
        "name": "generalization_same_classifier",
        "body": "\n\t\t\tgeneralization->collect(general)->asSet()->size() <= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Generalization::general",
          "UML::GeneralizationSet::generalization"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "CombinedFragment",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 1,
          "implies": 1,
          "=": 2
        },
        "name": "consider_and_ignore",
        "body": "\n\t\t\tinteractionOperator = InteractionOperatorKind::consider or interactionOperator = InteractionOperatorKind::ignore implies\n\t\t\toclIsKindOf(ConsiderIgnoreFragment)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::CombinedFragment::interactionOperator"]
      },
      {
        "operations": {
          "or": 4,
          "size": 1,
          "implies": 1,
          "=": 6
        },
        "name": "opt_loop_break_neg",
        "body": "\n\t\t\tinteractionOperator = InteractionOperatorKind::opt or interactionOperator = InteractionOperatorKind::loop or interactionOperator = InteractionOperatorKind::break or interactionOperator = InteractionOperatorKind::assert or interactionOperator = InteractionOperatorKind::neg implies\n\t\t\toperand->size() = 1\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 6,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 5,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::CombinedFragment::operand",
          "UML::CombinedFragment::interactionOperator"
        ]
      },
      {
        "operations": {
          "oclAsSet": 2,
          "union": 1,
          "asSet": 4,
          "implies": 1,
          "oclAsType": 2,
          "=": 2
        },
        "name": "break",
        "body": "\n\t\t\tinteractionOperator = InteractionOperatorKind::break implies\n\t\t\tenclosingInteraction.oclAsType(InteractionFragment)\n\t\t\t->asSet()\n\t\t\t->union(\n\t\t\t  enclosingOperand.oclAsType(InteractionFragment)\n\t\t\t  ->asSet())\n\t\t\t.covered->asSet() =\n\t\t\tself.covered->asSet()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 5,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::InteractionFragment::covered",
          "UML::CombinedFragment::interactionOperator",
          "UML::InteractionFragment::enclosingOperand",
          "UML::InteractionFragment::enclosingInteraction"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Behavior",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "most_one_behavior",
        "body": "\n\t\t\tspecification <> null implies\n\t\t\t_'context'.ownedBehavior->select(specification = self.specification)\n\t\t\t->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Behavior::context",
          "UML::Behavior::specification",
          "UML::BehavioredClassifier::ownedBehavior"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "size": 2,
          "implies": 1,
          "=": 1
        },
        "name": "parameters_match",
        "body": "\n\t\t\tspecification <> null implies\n\t\t\townedParameter->size() =\n\t\t\tspecification.ownedParameter->size()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::BehavioralFeature::ownedParameter",
          "UML::Behavior::ownedParameter",
          "UML::Behavior::specification"
        ]
      },
      {
        "operations": {"includes": 1},
        "name": "feature_of_context_classifier",
        "body": "\n\t\t\t_'context'.feature->includes(specification)\n\t\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Behavior::context",
          "UML::Classifier::feature",
          "UML::Behavior::specification"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "RemoveStructuralFeatureValueAction",
    "expressions": [{
      "operations": {
        "not": 2,
        "<>": 2,
        "and": 6,
        "is": 1,
        "toUnlimitedNatural": 1,
        "=": 3
      },
      "name": "removeAt_and_value",
      "body": "\n\t\t\tif structuralFeature.isOrdered and not structuralFeature.isUnique and not isRemoveDuplicates\n\t\t\tthen value = null and removeAt <> null and removeAt.type = UnlimitedNatural and\n\t\t\t  removeAt.is(1, 1)\n\t\t\telse removeAt = null and value <> null\n\t\t\tendif\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 15,
        "VariableExpImpl": 9,
        "NullLiteralExpImpl": 4,
        "IntegerLiteralExpImpl": 2,
        "TypeExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 12
      },
      "properties": [
        "UML::MultiplicityElement::isOrdered",
        "UML::WriteStructuralFeatureAction::value",
        "UML::RemoveStructuralFeatureValueAction::isRemoveDuplicates",
        "UML::MultiplicityElement::isUnique",
        "UML::StructuralFeatureAction::structuralFeature",
        "UML::RemoveStructuralFeatureValueAction::removeAt",
        "UML::TypedElement::type"
      ]
    }],
    "properties": []
  },
  {
    "name": "Region",
    "expressions": [
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "oclIsKindOf": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "deep_history_vertex",
        "body": "\n\t\t\tself.subvertex->select(\n\t\t\t  oclIsKindOf(Pseudostate))\n\t\t\t->collect(oclAsType(Pseudostate))\n\t\t\t->select((kind = PseudostateKind::deepHistory))\n\t\t\t->size() <= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Region::subvertex",
          "UML::Pseudostate::kind"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "oclIsKindOf": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "initial_vertex",
        "body": "\n\t\t\tself.subvertex->select(\n\t\t\t  oclIsKindOf(Pseudostate))\n\t\t\t->collect(oclAsType(Pseudostate))\n\t\t\t->select((kind = PseudostateKind::initial))\n\t\t\t->size() <= 1\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Region::subvertex",
          "UML::Pseudostate::kind"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "oclIsKindOf": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "shallow_history_vertex",
        "body": "\n\t\t\tsubvertex->select(\n\t\t\t  oclIsKindOf(Pseudostate))\n\t\t\t->collect(oclAsType(Pseudostate))\n\t\t\t->select((kind = PseudostateKind::shallowHistory))\n\t\t\t->size() <= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Region::subvertex",
          "UML::Pseudostate::kind"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "and": 1,
          "implies": 2,
          "=": 2
        },
        "name": "owned",
        "body": "\n\t\t\t(stateMachine <> null implies state = null\n\t\t\t) and\n\t\t\t(state <> null implies stateMachine = null\n\t\t\t)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 4,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Region::state",
          "UML::Region::stateMachine"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "TimeConstraint",
    "expressions": [{
      "operations": {
        "size": 1,
        "=": 1
      },
      "name": "has_one_constrainedElement",
      "body": "\n\t\t\tconstrainedElement->size() = 1\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::Constraint::constrainedElement"]
    }],
    "properties": []
  },
  {
    "name": "LinkEndDestructionData",
    "expressions": [{
      "operations": {
        "not": 1,
        "<>": 1,
        "or": 2,
        "and": 2,
        "oclAsSet": 1,
        "is": 1,
        "toUnlimitedNatural": 1,
        "=": 2
      },
      "name": "destroyAt_pin",
      "body": "\n\t\t\tif not end.isOrdered or end.isUnique or isDestroyDuplicates\n\t\t\tthen destroyAt = null\n\t\t\telse destroyAt <> null and\n\t\t\t  destroyAt->forAll(type = UnlimitedNatural and is(1, 1))\n\t\t\tendif\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 11,
        "VariableExpImpl": 8,
        "NullLiteralExpImpl": 2,
        "IntegerLiteralExpImpl": 2,
        "TypeExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 9
      },
      "properties": [
        "UML::MultiplicityElement::isOrdered",
        "UML::LinkEndData::end",
        "UML::MultiplicityElement::isUnique",
        "UML::LinkEndDestructionData::isDestroyDuplicates",
        "UML::LinkEndDestructionData::destroyAt",
        "UML::TypedElement::type"
      ]
    }],
    "properties": []
  },
  {
    "name": "Operation",
    "expressions": [
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "=": 1
        },
        "name": "at_most_one_return",
        "body": "\n\t\t\tself.ownedParameter->select(\n\t\t\t  (direction = ParameterDirectionKind::return\n\t\t\t  ))\n\t\t\t->size() <= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Parameter::direction",
          "UML::Operation::ownedParameter"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "implies": 1
        },
        "name": "only_body_for_query",
        "body": "\n\t\t\tbodyCondition <> null implies isQuery\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Operation::bodyCondition",
          "UML::Operation::isQuery"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "MergeNode",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2,
          "union": 1
        },
        "name": "edges",
        "body": "\n\t\t\tlet\n\t\t\t  allEdges : Set(ActivityEdge) = incoming->union(outgoing)\n\t\t\tin\n\t\t\t  allEdges->forAll(oclIsKindOf(ControlFlow)) or\n\t\t\t  allEdges->forAll(oclIsKindOf(ObjectFlow))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 4,
          "LetExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "one_outgoing_edge",
        "body": "\n\t\t\toutgoing->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::outgoing"]
      }
    ],
    "properties": []
  },
  {
    "name": "TemplateParameter",
    "expressions": [{
      "operations": {
        "<>": 1,
        "implies": 1,
        "isCompatibleWith": 1
      },
      "name": "must_be_compatible",
      "body": "\n\t\t\tdefault <> null implies\n\t\t\tdefault.isCompatibleWith(parameteredElement)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 3,
        "NullLiteralExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::TemplateParameter::default",
        "UML::TemplateParameter::parameteredElement"
      ]
    }],
    "properties": []
  },
  {
    "name": "Enumeration",
    "expressions": [{
      "operations": {},
      "name": "immutable",
      "body": "\n\t\t\townedAttribute->forAll(isReadOnly)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 2,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::StructuralFeature::isReadOnly",
        "UML::DataType::ownedAttribute"
      ]
    }],
    "properties": []
  },
  {
    "name": "Reception",
    "expressions": [
      {
        "operations": {
          "at": 9,
          "size": 3,
          "upperBound": 2,
          "and": 5,
          "lowerBound": 2,
          "=": 6
        },
        "name": "same_structure_as_signal",
        "body": "\n\t\t\tsignal.ownedAttribute->size() =\n\t\t\townedParameter->size() and\n\t\t\tSequence{1..signal.ownedAttribute->size()\n\t\t\t}\n\t\t\t->forAll(i |\n\t\t\t  ownedParameter->at(i).direction = ParameterDirectionKind::_'in' and\n\t\t\t  ownedParameter->at(i).name =\n\t\t\t  signal.ownedAttribute->at(i).name and\n\t\t\t  ownedParameter->at(i).type =\n\t\t\t  signal.ownedAttribute->at(i).type and\n\t\t\t  ownedParameter->at(i)\n\t\t\t  .lowerBound() =\n\t\t\t  signal.ownedAttribute->at(i)\n\t\t\t  .lowerBound() and\n\t\t\t  ownedParameter->at(i)\n\t\t\t  .upperBound() =\n\t\t\t  signal.ownedAttribute->at(i)\n\t\t\t  .upperBound())\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 21,
          "OperationCallExpImpl": 27,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 23
        },
        "properties": [
          "UML::BehavioralFeature::ownedParameter",
          "UML::Signal::ownedAttribute",
          "UML::Reception::signal",
          "UML::Parameter::direction",
          "UML::NamedElement::name",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "same_name_as_signal",
        "body": "\n\t\t\tname = signal.name\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Reception::signal",
          "UML::NamedElement::name"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "CreateLinkAction",
    "expressions": [{
      "operations": {
        "not": 1,
        "association": 1
      },
      "name": "association_not_abstract",
      "body": "\n\t\t\tnot self.association().isAbstract\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::Classifier::isAbstract"]
    }],
    "properties": []
  },
  {
    "name": "ReadExtentAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "type_is_classifier",
        "body": "\n\t\t\tresult.type = classifier\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ReadExtentAction::classifier",
          "UML::ReadExtentAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"is": 1},
        "name": "multiplicity_of_result",
        "body": "\n\t\t\tresult.is(0, *)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "UnlimitedNaturalLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadExtentAction::result"]
      }
    ],
    "properties": []
  },
  {
    "name": "ReadIsClassifiedObjectAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "no_type",
        "body": "\n\t\t\tobject.type = null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReadIsClassifiedObjectAction::object",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_input",
        "body": "\n\t\t\tobject.is(1, 1)\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadIsClassifiedObjectAction::object"]
      },
      {
        "operations": {"=": 1},
        "name": "boolean_result",
        "body": "\n\t\t\tresult.type = Boolean\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::TypedElement::type",
          "UML::ReadIsClassifiedObjectAction::result"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_output",
        "body": "\n\t\t\tresult.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadIsClassifiedObjectAction::result"]
      }
    ],
    "properties": []
  },
  {
    "name": "CallBehaviorAction",
    "expressions": [{
      "operations": {"=": 1},
      "name": "no_onport",
      "body": "\n\t\t\tonPort = null\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 1,
        "NullLiteralExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::InvocationAction::onPort"]
    }],
    "properties": []
  },
  {
    "name": "ForkNode",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2,
          "union": 1
        },
        "name": "edges",
        "body": "\n\t\t\tlet\n\t\t\t  allEdges : Set(ActivityEdge) = incoming->union(outgoing)\n\t\t\tin\n\t\t\t  allEdges->forAll(oclIsKindOf(ControlFlow)) or\n\t\t\t  allEdges->forAll(oclIsKindOf(ObjectFlow))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 6,
          "LetExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "one_incoming_edge",
        "body": "\n\t\t\tincoming->size() = 1\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::incoming"]
      }
    ],
    "properties": []
  },
  {
    "name": "InformationItem",
    "expressions": [
      {
        "operations": {},
        "name": "not_instantiable",
        "body": "\n\t\t\tisAbstract\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Classifier::isAbstract"]
      },
      {
        "operations": {
          "or": 4,
          "oclIsKindOf": 6,
          "and": 2,
          "includes": 2
        },
        "name": "sources_and_targets",
        "body": "\n\t\t\tself.represented->select(\n\t\t\t  oclIsKindOf(InformationItem))\n\t\t\t->forAll(p |\n\t\t\t  p.conveyingFlow.source->forAll(q | self.conveyingFlow.source->includes(q)) and\n\t\t\t  p.conveyingFlow.target->forAll(q | self.conveyingFlow.target->includes(q))) and\n\t\t\tself.represented->forAll(\n\t\t\t  (\n\t\t\t    oclIsKindOf(Class) or\n\t\t\t    oclIsKindOf(Interface) or\n\t\t\t    oclIsKindOf(InformationItem) or\n\t\t\t    oclIsKindOf(Signal) or\n\t\t\t    oclIsKindOf(Component)\n\t\t\t  ))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 9,
          "VariableExpImpl": 18,
          "OperationCallExpImpl": 14,
          "OppositePropertyCallExpImpl": 4,
          "TypeExpImpl": 6,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::DirectedRelationship::target",
          "UML::InformationItem::represented",
          "UML::DirectedRelationship::source"
        ]
      },
      {
        "operations": {
          "and": 1,
          "isEmpty": 2
        },
        "name": "has_no",
        "body": "\n\t\t\tself.generalization->isEmpty() and self.feature->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Classifier::generalization",
          "UML::Classifier::feature"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ActivityEdge",
    "expressions": [{
      "operations": {
        "<>": 1,
        "and": 1,
        "oclBadOperation": 2,
        "implies": 1,
        "=": 2
      },
      "name": "source_and_target",
      "body": "\n\t\t\tactivity <> null implies\n\t\t\tsource.containingActivity() = activity and\n\t\t\ttarget.containingActivity() = activity\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 7,
        "VariableExpImpl": 5,
        "NullLiteralExpImpl": 1,
        "PropertyCallExpImpl": 5
      },
      "properties": [
        "UML::ActivityEdge::source",
        "UML::ActivityEdge::activity",
        "UML::ActivityEdge::target"
      ]
    }],
    "properties": []
  },
  {
    "name": "WriteStructuralFeatureAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "implies": 1,
          "=": 1
        },
        "name": "type_of_result",
        "body": "\n\t\t\tresult <> null implies result.type = object.type\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::WriteStructuralFeatureAction::result",
          "UML::StructuralFeatureAction::object",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "conformsTo": 1,
          "implies": 1
        },
        "name": "type_of_value",
        "body": "\n\t\t\tvalue <> null implies\n\t\t\tvalue.type.conformsTo(structuralFeature.type)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::WriteStructuralFeatureAction::value",
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "is": 1,
          "toUnlimitedNatural": 1,
          "implies": 1
        },
        "name": "multiplicity_of_result",
        "body": "\n\t\t\tresult <> null implies result.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::WriteStructuralFeatureAction::result"]
      },
      {
        "operations": {
          "<>": 1,
          "is": 1,
          "toUnlimitedNatural": 1,
          "implies": 1
        },
        "name": "multiplicity_of_value",
        "body": "\n\t\t\tvalue <> null implies value.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::WriteStructuralFeatureAction::value"]
      }
    ],
    "properties": []
  },
  {
    "name": "ConditionalNode",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "union": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "executable_nodes",
        "body": "\n\t\t\tclause.test->union(clause._'body') =\n\t\t\tnode->select(oclIsKindOf(ExecutableNode))\n\t\t\t.oclAsType(ExecutableNode)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 7,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Clause::test",
          "UML::Clause::body",
          "UML::ConditionalNode::clause",
          "UML::StructuredActivityNode::node"
        ]
      },
      {
        "operations": {
          "intersection": 1,
          "isEmpty": 1
        },
        "name": "clause_no_predecessor",
        "body": "\n\t\t\tclause->closure(predecessorClause)\n\t\t\t->intersection(clause)\n\t\t\t->isEmpty()\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ConditionalNode::clause",
          "UML::Clause::predecessorClause"
        ]
      },
      {
        "operations": {"isEmpty": 1},
        "name": "no_input_pins",
        "body": "\n\t\t\tinput->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Action::input"]
      },
      {
        "operations": {
          "at": 8,
          "size": 3,
          "compatibleWith": 1,
          "and": 4,
          "conformsTo": 1,
          "=": 3
        },
        "name": "matching_output_pins",
        "body": "\n\t\t\tclause->forAll(\n\t\t\t  bodyOutput->size() =\n\t\t\t  self.result->size() and\n\t\t\t  Sequence{1..self.result->size()\n\t\t\t  }\n\t\t\t  ->forAll(i |\n\t\t\t    bodyOutput->at(i)\n\t\t\t    .type.conformsTo(result->at(i).type) and\n\t\t\t    bodyOutput->at(i).isOrdered =\n\t\t\t    result->at(i).isOrdered and\n\t\t\t    bodyOutput->at(i).isUnique =\n\t\t\t    result->at(i).isUnique and\n\t\t\t    bodyOutput->at(i)\n\t\t\t    .compatibleWith(result->at(i))))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 20,
          "OperationCallExpImpl": 20,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 18
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::MultiplicityElement::isUnique",
          "UML::ConditionalNode::result",
          "UML::ConditionalNode::clause",
          "UML::TypedElement::type",
          "UML::Clause::bodyOutput"
        ]
      },
      {
        "operations": {"isEmpty": 1},
        "name": "result_no_incoming",
        "body": "\n\t\t\tresult.incoming->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ConditionalNode::result",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "size": 1,
          "oclIsKindOf": 1,
          "includes": 1,
          "union": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "one_clause_with_executable_node",
        "body": "\n\t\t\tnode->select(oclIsKindOf(ExecutableNode))\n\t\t\t.oclAsType(ExecutableNode)\n\t\t\t->forAll(n |\n\t\t\t  self.clause->select(test->union(_'body')->includes(n))\n\t\t\t  ->size() = 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 7,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Clause::body",
          "UML::Clause::test",
          "UML::ConditionalNode::clause",
          "UML::StructuredActivityNode::node"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "DestroyObjectAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "no_type",
        "body": "\n\t\t\ttarget.type = null\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::DestroyObjectAction::target",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\ttarget.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::DestroyObjectAction::target"]
      }
    ],
    "properties": []
  },
  {
    "name": "CallOperationAction",
    "expressions": [{
      "operations": {
        "and": 1,
        "allFeatures": 3,
        "includes": 3,
        "union": 1,
        "oclAsType": 2,
        "=": 1
      },
      "name": "type_target_pin",
      "body": "\n\t\t\tif onPort = null\n\t\t\tthen\n\t\t\t  target.type.oclAsType(Classifier)\n\t\t\t  .allFeatures()\n\t\t\t  ->includes(operation)\n\t\t\telse\n\t\t\t  target.type.oclAsType(Classifier)\n\t\t\t  .allFeatures()\n\t\t\t  ->includes(onPort) and\n\t\t\t  onPort.provided->union(onPort.required)\n\t\t\t  .allFeatures()\n\t\t\t  ->includes(operation)\n\t\t\tendif\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 9,
        "OperationCallExpImpl": 11,
        "NullLiteralExpImpl": 1,
        "TypeExpImpl": 2,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 12
      },
      "properties": [
        "UML::Port::provided",
        "UML::InvocationAction::onPort",
        "UML::Port::required",
        "UML::CallOperationAction::operation",
        "UML::TypedElement::type",
        "UML::CallOperationAction::target"
      ]
    }],
    "properties": []
  },
  {
    "name": "OutputPin",
    "expressions": [{
      "operations": {
        "<>": 1,
        "includesAll": 1,
        "oclIsKindOf": 1,
        "and": 2,
        "allOwnedNodes": 1,
        "implies": 1,
        "notEmpty": 1,
        "oclAsType": 1
      },
      "name": "incoming_edges_structured_only",
      "body": "\n\t\t\tincoming->notEmpty() implies action <> null and\n\t\t\taction.oclIsKindOf(StructuredActivityNode) and\n\t\t\taction.oclAsType(StructuredActivityNode)\n\t\t\t.allOwnedNodes()\n\t\t\t->includesAll(incoming.source)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 6,
        "OperationCallExpImpl": 9,
        "OppositePropertyCallExpImpl": 3,
        "NullLiteralExpImpl": 1,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::ActivityEdge::source",
        "UML::ActivityNode::incoming"
      ]
    }],
    "properties": []
  },
  {
    "name": "PackageImport",
    "expressions": [{
      "operations": {
        "or": 1,
        "=": 2
      },
      "name": "public_or_private",
      "body": "\n\t\t\tvisibility = VisibilityKind::public or visibility = VisibilityKind::private\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 3,
        "VariableExpImpl": 2,
        "EnumLiteralExpImpl": 2,
        "PropertyCallExpImpl": 2
      },
      "properties": ["UML::PackageImport::visibility"]
    }],
    "properties": []
  },
  {
    "name": "Transition",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "implies": 1,
          "=": 2
        },
        "name": "state_is_internal",
        "body": "\n\t\t\tkind = TransitionKind::internal implies\n\t\t\tsource.oclIsKindOf(State) and source = target\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Transition::target",
          "UML::Transition::source",
          "UML::Transition::kind"
        ]
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2,
          "and": 2,
          "implies": 1,
          "oclAsType": 2,
          "=": 2
        },
        "name": "state_is_local",
        "body": "\n\t\t\tkind = TransitionKind::local implies\n\t\t\tsource.oclIsKindOf(State) and\n\t\t\tsource.oclAsType(State).isComposite or\n\t\t\tsource.oclIsKindOf(Pseudostate) and\n\t\t\tsource.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 5,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::Transition::source",
          "UML::Pseudostate::kind",
          "UML::State::isComposite",
          "UML::Transition::kind"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "isEmpty": 1,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "outgoing_pseudostates",
        "body": "\n\t\t\tsource.oclIsKindOf(Pseudostate) and\n\t\t\tsource.oclAsType(Pseudostate).kind <> PseudostateKind::initial implies\n\t\t\ttrigger->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Transition::trigger",
          "UML::Transition::source",
          "UML::Pseudostate::kind"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "and": 1,
          "implies": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "fork_segment_state",
        "body": "\n\t\t\tsource.oclIsKindOf(Pseudostate) and\n\t\t\tsource.oclAsType(Pseudostate).kind = PseudostateKind::fork implies\n\t\t\ttarget.oclIsKindOf(State)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Transition::target",
          "UML::Transition::source",
          "UML::Pseudostate::kind"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "implies": 1,
          "oclAsType": 1,
          "=": 2
        },
        "name": "state_is_external",
        "body": "\n\t\t\tkind = TransitionKind::external implies\n\t\t\tnot (\n\t\t\t  source.oclIsKindOf(Pseudostate) and\n\t\t\t  source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint\n\t\t\t)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Transition::source",
          "UML::Pseudostate::kind",
          "UML::Transition::kind"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 2,
          "isEmpty": 1,
          "implies": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "join_segment_guards",
        "body": "\n\t\t\ttarget.oclIsKindOf(Pseudostate) and\n\t\t\ttarget.oclAsType(Pseudostate).kind = PseudostateKind::join implies guard = null and\n\t\t\ttrigger->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Transition::target",
          "UML::Transition::trigger",
          "UML::Pseudostate::kind",
          "UML::Transition::guard"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "isEmpty": 1,
          "notEmpty": 1,
          "implies": 1
        },
        "name": "initial_transition",
        "body": "\n\t\t\tsource.oclIsKindOf(Pseudostate) and\n\t\t\tcontainer.stateMachine->notEmpty() implies\n\t\t\ttrigger->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Transition::trigger",
          "UML::Transition::container",
          "UML::Transition::source",
          "UML::Region::stateMachine"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 2,
          "isEmpty": 1,
          "implies": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "fork_segment_guards",
        "body": "\n\t\t\tsource.oclIsKindOf(Pseudostate) and\n\t\t\tsource.oclAsType(Pseudostate).kind = PseudostateKind::fork implies guard = null and\n\t\t\ttrigger->isEmpty()\n\t\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Transition::trigger",
          "UML::Transition::source",
          "UML::Pseudostate::kind",
          "UML::Transition::guard"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "and": 1,
          "implies": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "join_segment_state",
        "body": "\n\t\t\ttarget.oclIsKindOf(Pseudostate) and\n\t\t\ttarget.oclAsType(Pseudostate).kind = PseudostateKind::join implies\n\t\t\tsource.oclIsKindOf(State)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Transition::target",
          "UML::Transition::source",
          "UML::Pseudostate::kind"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "MultiplicityElement",
    "expressions": [
      {
        "operations": {
          "lowerBound": 1,
          ">=": 1
        },
        "name": "lower_ge_0",
        "body": "\n\t\t\tlowerBound() >= 0\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "<>": 2,
          "integerValue": 1,
          "implies": 1
        },
        "name": "lower_is_integer",
        "body": "\n\t\t\tlowerValue <> null implies lowerValue.integerValue() <> null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "NullLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::MultiplicityElement::lowerValue"]
      },
      {
        "operations": {},
        "name": "value_specification_no_side_effects",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "<>": 2,
          "unlimitedValue": 1,
          "implies": 1
        },
        "name": "upper_is_unlimitedNatural",
        "body": "\n\t\t\tupperValue <> null implies upperValue.unlimitedValue() <> null\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::MultiplicityElement::upperValue"]
      },
      {
        "operations": {
          "upperBound": 1,
          "lowerBound": 1,
          ">=": 1
        },
        "name": "upper_ge_lower",
        "body": "\n\t\t\tupperBound() >= lowerBound()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2
        },
        "properties": []
      },
      {
        "operations": {},
        "name": "value_specification_constant",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "CreateLinkObjectAction",
    "expressions": [
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\tresult.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::CreateLinkObjectAction::result"]
      },
      {
        "operations": {
          "association": 1,
          "=": 1
        },
        "name": "type_of_result",
        "body": "\n\t\t\tresult.type = association()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::CreateLinkObjectAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "association": 1
        },
        "name": "association_class",
        "body": "\n\t\t\tself.association()\n\t\t\t.oclIsKindOf(AssociationClass)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1
        },
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "InformationFlow",
    "expressions": [
      {
        "operations": {
          "or": 4,
          "oclIsKindOf": 5
        },
        "name": "convey_classifiers",
        "body": "\n\t\t\tself.conveyed->forAll(\n\t\t\t  oclIsKindOf(Class) or\n\t\t\t  oclIsKindOf(Interface) or\n\t\t\t  oclIsKindOf(InformationItem) or\n\t\t\t  oclIsKindOf(Signal) or\n\t\t\t  oclIsKindOf(Component))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 6,
          "TypeExpImpl": 5,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InformationFlow::conveyed"]
      },
      {
        "operations": {
          "not": 2,
          "or": 24,
          "oclIsKindOf": 28,
          "and": 3,
          "oclAsType": 2
        },
        "name": "sources_and_targets_kind",
        "body": "\n\t\t\tself.informationSource->forAll(sis |\n\t\t\t  (\n\t\t\t    oclIsKindOf(Actor) or\n\t\t\t    oclIsKindOf(Node) or\n\t\t\t    oclIsKindOf(UseCase) or\n\t\t\t    oclIsKindOf(Artifact) or\n\t\t\t    oclIsKindOf(Class) or\n\t\t\t    oclIsKindOf(Component) or\n\t\t\t    oclIsKindOf(Port) or\n\t\t\t    oclIsKindOf(Property) or\n\t\t\t    oclIsKindOf(Interface) or\n\t\t\t    oclIsKindOf(Package) or\n\t\t\t    oclIsKindOf(ActivityNode) or\n\t\t\t    oclIsKindOf(ActivityPartition) or\n\t\t\t    oclIsKindOf(InstanceSpecification) and\n\t\t\t    not sis.oclAsType(InstanceSpecification)\n\t\t\t    .classifier->exists(\n\t\t\t      oclIsKindOf(Relationship))\n\t\t\t  )) and\n\t\t\tself.informationTarget->forAll(sit |\n\t\t\t  (\n\t\t\t    oclIsKindOf(Actor) or\n\t\t\t    oclIsKindOf(Node) or\n\t\t\t    oclIsKindOf(UseCase) or\n\t\t\t    oclIsKindOf(Artifact) or\n\t\t\t    oclIsKindOf(Class) or\n\t\t\t    oclIsKindOf(Component) or\n\t\t\t    oclIsKindOf(Port) or\n\t\t\t    oclIsKindOf(Property) or\n\t\t\t    oclIsKindOf(Interface) or\n\t\t\t    oclIsKindOf(Package) or\n\t\t\t    oclIsKindOf(ActivityNode) or\n\t\t\t    oclIsKindOf(ActivityPartition) or\n\t\t\t    oclIsKindOf(InstanceSpecification) and\n\t\t\t    not sit.oclAsType(InstanceSpecification)\n\t\t\t    .classifier->exists(\n\t\t\t      oclIsKindOf(Relationship))\n\t\t\t  ))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 59,
          "VariableExpImpl": 32,
          "TypeExpImpl": 30,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::InformationFlow::informationSource",
          "UML::InstanceSpecification::classifier",
          "UML::InformationFlow::informationTarget"
        ]
      },
      {
        "operations": {},
        "name": "must_conform",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "ClearAssociationAction",
    "expressions": [
      {
        "operations": {"conformsTo": 1},
        "name": "same_type",
        "body": "\n\t\t\tassociation.memberEnd->exists(self.object.type.conformsTo(type))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::ClearAssociationAction::object",
          "UML::ClearAssociationAction::association",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\tobject.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ClearAssociationAction::object"]
      }
    ],
    "properties": []
  },
  {
    "name": "Clause",
    "expressions": [
      {
        "operations": {
          "intersection": 1,
          "isEmpty": 1
        },
        "name": "test_and_body",
        "body": "\n\t\t\ttest->intersection(_'body')->isEmpty()\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Clause::test",
          "UML::Clause::body"
        ]
      },
      {
        "operations": {
          "and": 2,
          "allActions": 1,
          "toUnlimitedNatural": 1,
          "is": 1,
          "includes": 1,
          "oclAsType": 1,
          "=": 1
        },
        "name": "decider_output",
        "body": "\n\t\t\ttest.oclAsType(Action)\n\t\t\t.allActions()\n\t\t\t.output->includes(decider) and decider.type = Boolean and\n\t\t\tdecider.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 7,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Clause::decider",
          "UML::Clause::test",
          "UML::Action::output",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "includesAll": 1,
          "allActions": 1,
          "oclAsType": 1
        },
        "name": "body_output_pins",
        "body": "\n\t\t\t_'body'.oclAsType(Action)\n\t\t\t.allActions()\n\t\t\t.output->includesAll(bodyOutput)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Clause::body",
          "UML::Action::output",
          "UML::Clause::bodyOutput"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "CommunicationPath",
    "expressions": [{
      "operations": {"oclIsKindOf": 1},
      "name": "association_ends",
      "body": "\n\t\t\tendType->forAll(\n\t\t\t  oclIsKindOf(DeploymentTarget))\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::Association::endType"]
    }],
    "properties": []
  },
  {
    "name": "ActionInputPin",
    "expressions": [
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "one_output_pin",
        "body": "\n\t\t\tfromAction.output->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Action::output",
          "UML::ActionInputPin::fromAction"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "input_pin",
        "body": "\n\t\t\tfromAction.input->forAll(\n\t\t\t  oclIsKindOf(ActionInputPin))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Action::input",
          "UML::ActionInputPin::fromAction"
        ]
      },
      {
        "operations": {
          "and": 2,
          "isEmpty": 3,
          "union": 1
        },
        "name": "no_control_or_object_flow",
        "body": "\n\t\t\tfromAction.incoming->union(outgoing)\n\t\t\t->isEmpty() and\n\t\t\tfromAction.input.incoming->isEmpty() and\n\t\t\tfromAction.output.outgoing->isEmpty()\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 6,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::Action::input",
          "UML::ActivityNode::incoming",
          "UML::Action::output",
          "UML::ActionInputPin::fromAction"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ActionExecutionSpecification",
    "expressions": [{
      "operations": {
        "or": 1,
        "size": 1,
        "and": 2,
        "oclAsSet": 5,
        "union": 1,
        "asSet": 3,
        "notEmpty": 2,
        "=": 2,
        "oclAsType": 2
      },
      "name": "action_referenced",
      "body": "\n\t\t\t(\n\t\t\t  enclosingInteraction->notEmpty() or\n\t\t\t  enclosingOperand.combinedFragment->notEmpty()\n\t\t\t) and\n\t\t\tlet\n\t\t\t  parentInteraction : Set(Interaction) = enclosingInteraction.oclAsType(Interaction)\n\t\t\t  ->asSet()\n\t\t\t  ->union(\n\t\t\t    enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)\n\t\t\t    ->collect(enclosingInteraction)\n\t\t\t    .oclAsType(Interaction)\n\t\t\t    ->asSet())\n\t\t\tin\n\t\t\t  parentInteraction->size() = 1 and\n\t\t\t  self.action.interaction->asSet() = parentInteraction\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 3,
        "VariableExpImpl": 10,
        "OperationCallExpImpl": 19,
        "LetExpImpl": 1,
        "OppositePropertyCallExpImpl": 4,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 2,
        "PropertyCallExpImpl": 7
      },
      "properties": [
        "UML::ActionExecutionSpecification::action",
        "UML::InteractionFragment::enclosingOperand",
        "UML::InteractionFragment::enclosingInteraction"
      ]
    }],
    "properties": []
  },
  {
    "name": "ControlFlow",
    "expressions": [{
      "operations": {
        "oclIsKindOf": 2,
        "and": 1,
        "implies": 2,
        "oclAsType": 2
      },
      "name": "object_nodes",
      "body": "\n\t\t\t(\n\t\t\t  source.oclIsKindOf(ObjectNode) implies\n\t\t\t  source.oclAsType(ObjectNode).isControlType\n\t\t\t) and\n\t\t\t(\n\t\t\t  target.oclIsKindOf(ObjectNode) implies\n\t\t\t  target.oclAsType(ObjectNode).isControlType\n\t\t\t)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 7,
        "VariableExpImpl": 4,
        "TypeExpImpl": 4,
        "PropertyCallExpImpl": 6
      },
      "properties": [
        "UML::ActivityEdge::source",
        "UML::ObjectNode::isControlType",
        "UML::ActivityEdge::target"
      ]
    }],
    "properties": []
  },
  {
    "name": "ReadLinkObjectEndAction",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "type_of_object",
        "body": "\n\t\t\tobject.type = end.association\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ReadLinkObjectEndAction::end",
          "UML::Property::association",
          "UML::TypedElement::type",
          "UML::ReadLinkObjectEndAction::object"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "property",
        "body": "\n\t\t\tend.association <> null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReadLinkObjectEndAction::end",
          "UML::Property::association"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "association_of_association",
        "body": "\n\t\t\tend.association.oclIsKindOf(AssociationClass)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReadLinkObjectEndAction::end",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_object",
        "body": "\n\t\t\tobject.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkObjectEndAction::object"]
      },
      {
        "operations": {"not": 1},
        "name": "ends_of_association",
        "body": "\n\t\t\tend.association.memberEnd->forAll(e | not e.isStatic)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ReadLinkObjectEndAction::end",
          "UML::Feature::isStatic",
          "UML::Association::memberEnd",
          "UML::Property::association"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "type_of_result",
        "body": "\n\t\t\tresult.type = end.type\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ReadLinkObjectEndAction::end",
          "UML::ReadLinkObjectEndAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity_of_result",
        "body": "\n\t\t\tresult.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadLinkObjectEndAction::result"]
      }
    ],
    "properties": []
  },
  {
    "name": "DestructionOccurrenceSpecification",
    "expressions": [{
      "operations": {
        "last": 1,
        "and": 1,
        "oclAsSet": 1,
        "notEmpty": 1,
        "=": 2
      },
      "name": "no_occurrence_specifications_below",
      "body": "\n\t\t\tlet o : InteractionOperand = enclosingOperand\n\t\t\tin\n\t\t\t  o->notEmpty() and\n\t\t\t  let\n\t\t\t    peerEvents : OrderedSet(OccurrenceSpecification) = covered.events->select(enclosingOperand = o)\n\t\t\t  in peerEvents->last() = self\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 7,
        "OperationCallExpImpl": 6,
        "LetExpImpl": 2,
        "OppositePropertyCallExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::OccurrenceSpecification::covered",
        "UML::InteractionFragment::enclosingOperand"
      ]
    }],
    "properties": []
  },
  {
    "name": "ElementImport",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "=": 2
        },
        "name": "visibility_public_or_private",
        "body": "\n\t\t\tvisibility = VisibilityKind::public or visibility = VisibilityKind::private\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::ElementImport::visibility"]
      },
      {
        "operations": {
          "<>": 1,
          "implies": 1,
          "=": 1
        },
        "name": "imported_element_is_public",
        "body": "\n\t\t\timportedElement.visibility <> null implies importedElement.visibility = VisibilityKind::public\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::PackageableElement::visibility",
          "UML::ElementImport::importedElement"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Activity",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "size": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "implies": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "maximum_one_parameter_node",
        "body": "\n\t\t\townedParameter->forAll(p | p.direction <> ParameterDirectionKind::inout implies\n\t\t\t  node->select(\n\t\t\t    (\n\t\t\t      oclIsKindOf(ActivityParameterNode) and\n\t\t\t      oclAsType(ActivityParameterNode).parameter = p\n\t\t\t    ))\n\t\t\t  ->size() = 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 6,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction",
          "UML::Activity::node",
          "UML::ActivityParameterNode::parameter"
        ]
      },
      {
        "operations": {
          "<=": 2,
          "size": 3,
          "oclIsKindOf": 1,
          "and": 3,
          "notEmpty": 2,
          "implies": 1,
          "=": 3,
          "oclAsType": 1
        },
        "name": "maximum_two_parameter_nodes",
        "body": "\n\t\t\townedParameter->forAll(p | p.direction = ParameterDirectionKind::inout implies\n\t\t\t  let\n\t\t\t    associatedNodes : Set(ActivityNode) = node->select(\n\t\t\t      oclIsKindOf(ActivityParameterNode) and\n\t\t\t      oclAsType(ActivityParameterNode).parameter = p)\n\t\t\t  in\n\t\t\t    associatedNodes->size() = 2 and\n\t\t\t    associatedNodes->select(incoming->notEmpty())\n\t\t\t    ->size() <= 1 and\n\t\t\t    associatedNodes->select(outgoing->notEmpty())\n\t\t\t    ->size() <= 1)\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 16,
          "VariableExpImpl": 11,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 3,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming",
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction",
          "UML::Activity::node",
          "UML::ActivityParameterNode::parameter"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "DurationConstraint",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "size": 2,
          "=": 2
        },
        "name": "has_one_or_two_constrainedElements",
        "body": "\n\t\t\tconstrainedElement->size() = 1 or constrainedElement->size() = 2\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Constraint::constrainedElement"]
      },
      {
        "operations": {
          "size": 3,
          "=": 3
        },
        "name": "first_event_multiplicity",
        "body": "\n\t\t\tif constrainedElement->size() = 2\n\t\t\tthen firstEvent->size() = 2\n\t\t\telse firstEvent->size() = 0\n\t\t\tendif\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Constraint::constrainedElement",
          "UML::DurationConstraint::firstEvent"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Namespace",
    "expressions": [
      {
        "operations": {
          "excludesAll": 1,
          "oclAsType": 1
        },
        "name": "cannot_import_ownedMembers",
        "body": "\n\t\t\telementImport.importedElement.oclAsType(Element)\n\t\t\t->excludesAll(ownedMember)\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 4,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Namespace::ownedMember",
          "UML::ElementImport::importedElement",
          "UML::Namespace::elementImport"
        ]
      },
      {
        "operations": {"membersAreDistinguishable": 1},
        "name": "members_distinguishable",
        "body": "\n\t\t\tmembersAreDistinguishable()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "excludes": 1,
          "oclAsType": 1
        },
        "name": "cannot_import_self",
        "body": "\n\t\t\tpackageImport.importedPackage.oclAsType(Namespace)\n\t\t\t->excludes(self)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Namespace::packageImport",
          "UML::PackageImport::importedPackage"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "SendObjectAction",
    "expressions": [{
      "operations": {
        "<>": 1,
        "allFeatures": 1,
        "includes": 1,
        "implies": 1,
        "oclAsType": 1
      },
      "name": "type_target_pin",
      "body": "\n\t\t\tonPort <> null implies\n\t\t\ttarget.type.oclAsType(Classifier)\n\t\t\t.allFeatures()\n\t\t\t->includes(onPort)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 5,
        "VariableExpImpl": 3,
        "NullLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "UML::InvocationAction::onPort",
        "UML::SendObjectAction::target",
        "UML::TypedElement::type"
      ]
    }],
    "properties": []
  },
  {
    "name": "ClassifierTemplateParameter",
    "expressions": [
      {
        "operations": {
          "or": 2,
          "and": 1,
          "isSubstitutableFor": 1,
          "conformsTo": 1,
          "=": 1,
          "oclAsType": 1
        },
        "name": "constraining_classifiers_constrain_args",
        "body": "\n\t\t\ttemplateParameterSubstitution.actual->forAll(a |\n\t\t\t  let\n\t\t\t    arg : Classifier = a.oclAsType(Classifier)\n\t\t\t  in\n\t\t\t    constrainingClassifier->forAll(cc | arg = cc or\n\t\t\t      arg.conformsTo(cc) or allowSubstitutable and\n\t\t\t      arg.isSubstitutableFor(cc)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 11,
          "LetExpImpl": 1,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::TemplateParameterSubstitution::actual",
          "UML::ClassifierTemplateParameter::allowSubstitutable",
          "UML::ClassifierTemplateParameter::constrainingClassifier"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "notEmpty": 1
        },
        "name": "has_constraining_classifier",
        "body": "\n\t\t\tallowSubstitutable implies constrainingClassifier->notEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ClassifierTemplateParameter::allowSubstitutable",
          "UML::ClassifierTemplateParameter::constrainingClassifier"
        ]
      },
      {
        "operations": {
          "and": 1,
          "isEmpty": 3,
          "allParents": 1,
          "implies": 1
        },
        "name": "parametered_element_no_features",
        "body": "\n\t\t\tparameteredElement.feature->isEmpty() and\n\t\t\t(\n\t\t\t  constrainingClassifier->isEmpty() implies\n\t\t\t  parameteredElement.allParents()\n\t\t\t  ->isEmpty()\n\t\t\t)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 6,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ClassifierTemplateParameter::parameteredElement",
          "UML::Classifier::feature",
          "UML::ClassifierTemplateParameter::constrainingClassifier"
        ]
      },
      {
        "operations": {
          "not": 2,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "matching_abstract",
        "body": "\n\t\t\tnot parameteredElement.isAbstract implies\n\t\t\ttemplateParameterSubstitution.actual->forAll(a |\n\t\t\t  not a.oclAsType(Classifier).isAbstract)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 4,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TemplateParameterSubstitution::actual",
          "UML::ClassifierTemplateParameter::parameteredElement",
          "UML::Classifier::isAbstract"
        ]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "actual_is_classifier",
        "body": "\n\t\t\ttemplateParameterSubstitution.actual->forAll(a |\n\t\t\t  a.oclIsKindOf(Classifier))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 3,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::TemplateParameterSubstitution::actual"]
      },
      {
        "operations": {
          "or": 2,
          "and": 1,
          "isSubstitutableFor": 1,
          "conformsTo": 1,
          "=": 1
        },
        "name": "constraining_classifiers_constrain_parametered_element",
        "body": "\n\t\t\tconstrainingClassifier->forAll(cc | parameteredElement = cc or\n\t\t\t  parameteredElement.conformsTo(cc) or allowSubstitutable and\n\t\t\t  parameteredElement.isSubstitutableFor(cc))\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 8,
          "OperationCallExpImpl": 6,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ClassifierTemplateParameter::parameteredElement",
          "UML::ClassifierTemplateParameter::allowSubstitutable",
          "UML::ClassifierTemplateParameter::constrainingClassifier"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ConsiderIgnoreFragment",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "=": 2
        },
        "name": "consider_or_ignore",
        "body": "\n\t\t\tinteractionOperator = InteractionOperatorKind::consider or interactionOperator = InteractionOperatorKind::ignore\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::CombinedFragment::interactionOperator"]
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2
        },
        "name": "type",
        "body": "\n\t\t\tmessage->forAll(m |\n\t\t\t  m.oclIsKindOf(Operation) or\n\t\t\t  m.oclIsKindOf(Signal))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ConsiderIgnoreFragment::message"]
      }
    ],
    "properties": []
  },
  {
    "name": "DurationObservation",
    "expressions": [{
      "operations": {
        "size": 3,
        "=": 3
      },
      "name": "first_event_multiplicity",
      "body": "\n\t\t\tif event->size() = 2\n\t\t\tthen firstEvent->size() = 2\n\t\t\telse firstEvent->size() = 0\n\t\t\tendif\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 3,
        "IntegerLiteralExpImpl": 3,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::DurationObservation::firstEvent",
        "UML::DurationObservation::event"
      ]
    }],
    "properties": []
  },
  {
    "name": "InstanceSpecification",
    "expressions": [
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "allSlottableFeatures": 1,
          "=": 1
        },
        "name": "structural_feature",
        "body": "\n\t\t\tclassifier->forAll(c |\n\t\t\t  c.allSlottableFeatures()\n\t\t\t  ->forAll(f |\n\t\t\t    slot->select(s | (s.definingFeature = f))\n\t\t\t    ->size() <= 1))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 5,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::InstanceSpecification::classifier",
          "UML::InstanceSpecification::slot",
          "UML::Slot::definingFeature"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "allInstances": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 1
        },
        "name": "deployment_target",
        "body": "\n\t\t\tdeployment->notEmpty() implies\n\t\t\tclassifier->exists(node |\n\t\t\t  node.oclIsKindOf(Node) and\n\t\t\t  Node.allInstances()\n\t\t\t  ->exists(n | n.part->exists(p | p.type = node)))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 6,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::StructuredClassifier::part",
          "UML::InstanceSpecification::classifier",
          "UML::DeploymentTarget::deployment",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "implies": 1,
          "notEmpty": 1
        },
        "name": "deployment_artifact",
        "body": "\n\t\t\tdeploymentForArtifact->notEmpty() implies\n\t\t\tclassifier->exists(oclIsKindOf(Artifact))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InstanceSpecification::classifier"]
      },
      {
        "operations": {
          "allSlottableFeatures": 1,
          "includes": 1
        },
        "name": "defining_feature",
        "body": "\n\t\t\tslot->forAll(s |\n\t\t\t  classifier->exists(c |\n\t\t\t    c.allSlottableFeatures()\n\t\t\t    ->includes(s.definingFeature)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::InstanceSpecification::slot",
          "UML::InstanceSpecification::classifier",
          "UML::Slot::definingFeature"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ValueSpecificationAction",
    "expressions": [
      {
        "operations": {"conformsTo": 1},
        "name": "compatible_type",
        "body": "\n\t\t\tvalue.type.conformsTo(result.type)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ValueSpecificationAction::value",
          "UML::ValueSpecificationAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\tresult.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ValueSpecificationAction::result"]
      }
    ],
    "properties": []
  },
  {
    "name": "OperationTemplateParameter",
    "expressions": [{
      "operations": {
        "at": 2,
        "size": 3,
        "oclIsKindOf": 1,
        "and": 7,
        "oclAsSet": 1,
        "implies": 1,
        "notEmpty": 1,
        "=": 7,
        "oclAsType": 1
      },
      "name": "match_default_signature",
      "body": "\n\t\t\tdefault->notEmpty() implies\n\t\t\tdefault.oclIsKindOf(Operation) and\n\t\t\tlet\n\t\t\t  defaultOp : Operation = default.oclAsType(Operation)\n\t\t\tin\n\t\t\t  defaultOp.ownedParameter->size() =\n\t\t\t  parameteredElement.ownedParameter->size() and\n\t\t\t  Sequence{1..defaultOp.ownedParameter->size()\n\t\t\t  }\n\t\t\t  ->forAll(ix |\n\t\t\t    let p1 : Parameter = defaultOp.ownedParameter->at(ix)\n\t\t\t    in\n\t\t\t      let\n\t\t\t        p2 : Parameter = parameteredElement.ownedParameter->at(ix)\n\t\t\t      in p1.type = p2.type and p1.upper = p2.upper and p1.lower = p2.lower and p1.direction = p2.direction and p1.isOrdered = p2.isOrdered and p1.isUnique = p2.isUnique)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 24,
        "VariableExpImpl": 22,
        "LetExpImpl": 3,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 2,
        "CollectionLiteralExpImpl": 1,
        "PropertyCallExpImpl": 22
      },
      "properties": [
        "UML::MultiplicityElement::isOrdered",
        "UML::MultiplicityElement::isUnique",
        "UML::MultiplicityElement::lower",
        "UML::TemplateParameter::default",
        "UML::Parameter::direction",
        "UML::Operation::ownedParameter",
        "UML::TypedElement::type",
        "UML::OperationTemplateParameter::parameteredElement",
        "UML::MultiplicityElement::upper"
      ]
    }],
    "properties": []
  },
  {
    "name": "FinalNode",
    "expressions": [{
      "operations": {"isEmpty": 1},
      "name": "no_outgoing_edges",
      "body": "\n\t\t\toutgoing->isEmpty()\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::ActivityNode::outgoing"]
    }],
    "properties": []
  },
  {
    "name": "Extension",
    "expressions": [
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "is_binary",
        "body": "\n\t\t\tmemberEnd->size() = 2\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Association::memberEnd"]
      },
      {
        "operations": {
          "metaclassEnd": 2,
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "non_owned_end",
        "body": "\n\t\t\tmetaclassEnd()\n\t\t\t->notEmpty() and\n\t\t\tmetaclassEnd()\n\t\t\t.type.oclIsKindOf(Class)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 6,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::TypedElement::type"]
      }
    ],
    "properties": []
  },
  {
    "name": "AddVariableValueAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "not": 2,
          "and": 2,
          "oclAsSet": 1,
          "is": 1,
          "implies": 1,
          "oclAsType": 1,
          "=": 2
        },
        "name": "insertAt_pin",
        "body": "\n\t\t\tif not variable.isOrdered\n\t\t\tthen insertAt = null\n\t\t\telse not isReplaceAll implies insertAt <> null and\n\t\t\t  insertAt->forAll(type = UnlimitedNatural and\n\t\t\t    is(1, 1.oclAsType(UnlimitedNatural)))\n\t\t\tendif\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 7,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::AddVariableValueAction::insertAt",
          "UML::VariableAction::variable",
          "UML::AddVariableValueAction::isReplaceAll",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "required_value",
        "body": "\n\t\t\tvalue <> null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::WriteVariableAction::value"]
      }
    ],
    "properties": []
  },
  {
    "name": "Property",
    "expressions": [
      {
        "operations": {
          "<=": 1,
          "<>": 1,
          "upperBound": 1,
          "and": 1,
          "implies": 1
        },
        "name": "multiplicity_of_composite",
        "body": "\n\t\t\tisComposite and association <> null implies opposite.upperBound() <= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Property::opposite",
          "UML::Property::association",
          "UML::Property::isComposite"
        ]
      },
      {
        "operations": {"implies": 1},
        "name": "derived_union_is_derived",
        "body": "\n\t\t\tisDerivedUnion implies isDerived\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Property::isDerived",
          "UML::Property::isDerivedUnion"
        ]
      },
      {
        "operations": {"implies": 1},
        "name": "derived_union_is_read_only",
        "body": "\n\t\t\tisDerivedUnion implies isReadOnly\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::StructuralFeature::isReadOnly",
          "UML::Property::isDerivedUnion"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 2,
          "isAttribute": 2,
          "implies": 1,
          "notEmpty": 1,
          "oclAsType": 1
        },
        "name": "binding_to_attribute",
        "body": "\n\t\t\tself.isAttribute() and\n\t\t\ttemplateParameterSubstitution->notEmpty() implies\n\t\t\ttemplateParameterSubstitution->forAll(ts |\n\t\t\t  ts.formal.oclIsKindOf(Property) and\n\t\t\t  ts.formal.oclAsType(Property)\n\t\t\t  .isAttribute())\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 5,
          "OppositePropertyCallExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::TemplateParameterSubstitution::formal"]
      },
      {
        "operations": {
          "and": 1,
          "allFeatures": 1,
          "allParents": 1,
          "includes": 1,
          "notEmpty": 2,
          "implies": 1,
          "asSet": 2
        },
        "name": "redefined_property_inherited",
        "body": "\n\t\t\tredefinedProperty->notEmpty() implies\n\t\t\tredefinitionContext->notEmpty() and\n\t\t\tredefinedProperty->forAll(rp |\n\t\t\t  redefinitionContext->collect(fc | fc.allParents())\n\t\t\t  ->asSet()\n\t\t\t  ->collect(c | c.allFeatures())\n\t\t\t  ->asSet()\n\t\t\t  ->includes(rp))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 7,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Property::redefinedProperty",
          "UML::RedefinableElement::redefinitionContext"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 2,
          "implies": 1
        },
        "name": "qualified_is_association_end",
        "body": "\n\t\t\tqualifier->notEmpty() implies association->notEmpty()\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Property::qualifier",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "upperBound": 4,
          "and": 2,
          "oclAsSet": 2,
          "conformsTo": 1,
          "notEmpty": 2,
          "implies": 1
        },
        "name": "subsetting_rules",
        "body": "\n\t\t\tsubsettedProperty->forAll(sp |\n\t\t\t  self.type.conformsTo(sp.type) and\n\t\t\t  (\n\t\t\t    self.upperBound()\n\t\t\t    ->notEmpty() and\n\t\t\t    sp.upperBound()\n\t\t\t    ->notEmpty() implies\n\t\t\t    self.upperBound() <=\n\t\t\t    sp.upperBound()\n\t\t\t  ))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 13,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Property::subsettedProperty",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "subsetted_property_names",
        "body": "\n\t\t\tsubsettedProperty->forAll(sp | sp.name <> name)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Property::subsettedProperty",
          "UML::NamedElement::name"
        ]
      },
      {
        "operations": {
          "and": 1,
          "isEmpty": 1,
          "oclAsSet": 2,
          "implies": 1,
          "notEmpty": 1,
          "=": 1
        },
        "name": "type_of_opposite_end",
        "body": "\n\t\t\topposite->notEmpty() and owningAssociation->isEmpty() implies classifier = opposite.type\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4,
          "OppositePropertyCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Property::owningAssociation",
          "UML::Property::opposite",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "allInstances": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 1
        },
        "name": "deployment_target",
        "body": "\n\t\t\tdeployment->notEmpty() implies\n\t\t\towner.oclIsKindOf(Node) and\n\t\t\tNode.allInstances()\n\t\t\t->exists(n | n.part->exists(p | p = self))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 6,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::StructuredClassifier::part",
          "UML::DeploymentTarget::deployment",
          "UML::Element::owner"
        ]
      },
      {
        "operations": {
          "subsettingContext": 3,
          "and": 1,
          "conformsTo": 1,
          "notEmpty": 2,
          "implies": 1
        },
        "name": "subsetting_context_conforms",
        "body": "\n\t\t\tsubsettedProperty->notEmpty() implies\n\t\t\tsubsettingContext()\n\t\t\t->notEmpty() and\n\t\t\tsubsettingContext()\n\t\t\t->forAll(sc |\n\t\t\t  subsettedProperty->forAll(sp |\n\t\t\t    sp.subsettingContext()\n\t\t\t    ->exists(c | sc.conformsTo(c))))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 7,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Property::subsettedProperty"]
      }
    ],
    "properties": []
  },
  {
    "name": "Association",
    "expressions": [
      {
        "operations": {
          "at": 2,
          "size": 1,
          "oclIsKindOf": 1,
          "conformsTo": 1,
          "oclAsType": 1
        },
        "name": "specialized_end_types",
        "body": "\n\t\t\tSequence{1..memberEnd->size()\n\t\t\t}\n\t\t\t->forAll(i |\n\t\t\t  general->select(\n\t\t\t    oclIsKindOf(Association))\n\t\t\t  .oclAsType(Association)\n\t\t\t  ->forAll(ga |\n\t\t\t    self.memberEnd->at(i)\n\t\t\t    .type.conformsTo(ga.memberEnd->at(i).type)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 8,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::Classifier::general",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "size": 1,
          "and": 1,
          "implies": 1,
          "=": 2
        },
        "name": "binary_associations",
        "body": "\n\t\t\tmemberEnd->exists(aggregation <> AggregationKind::none) implies\n\t\t\tmemberEnd->size() = 2 and\n\t\t\tmemberEnd->exists(aggregation = AggregationKind::none)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 5,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::Property::aggregation"
        ]
      },
      {
        "operations": {
          "oclAsSet": 1,
          "notEmpty": 1
        },
        "name": "ends_must_be_typed",
        "body": "\n\t\t\tmemberEnd->forAll(type->notEmpty())\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "size": 2,
          "oclIsKindOf": 1,
          "oclAsType": 1,
          "=": 1,
          "parents": 1
        },
        "name": "specialized_end_number",
        "body": "\n\t\t\tparents()\n\t\t\t->select(\n\t\t\t  oclIsKindOf(Association))\n\t\t\t.oclAsType(Association)\n\t\t\t->forAll(p | p.memberEnd->size() = self.memberEnd->size())\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 5,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Association::memberEnd"]
      },
      {
        "operations": {
          "includesAll": 1,
          "size": 1,
          "implies": 1,
          ">": 1
        },
        "name": "association_ends",
        "body": "\n\t\t\tmemberEnd->size() > 2 implies ownedEnd->includesAll(memberEnd)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::Association::ownedEnd"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "LinkAction",
    "expressions": [
      {
        "operations": {
          "association": 1,
          "asBag": 1,
          "=": 1
        },
        "name": "same_association",
        "body": "\n\t\t\tendData.end = self.association().memberEnd->asBag()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::Association::memberEnd",
          "UML::LinkAction::endData"
        ]
      },
      {
        "operations": {
          "allPins": 1,
          "asBag": 1,
          "=": 1
        },
        "name": "same_pins",
        "body": "\n\t\t\tinputValue->asBag() = endData.allPins()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::LinkAction::endData",
          "UML::LinkAction::inputValue"
        ]
      },
      {
        "operations": {"not": 1},
        "name": "not_static",
        "body": "\n\t\t\tendData->forAll(not end.isStatic)\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::Feature::isStatic",
          "UML::LinkAction::endData"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "LinkEndData",
    "expressions": [
      {
        "operations": {
          "excludesAll": 1,
          "oclAsSet": 1
        },
        "name": "end_object_input_pin",
        "body": "\n\t\t\tvalue->excludesAll(qualifier.value)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::QualifierValue::value",
          "UML::LinkEndData::value",
          "UML::LinkEndData::qualifier"
        ]
      },
      {
        "operations": {"<>": 1},
        "name": "property_is_association_end",
        "body": "\n\t\t\tend.association <> null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::Property::association"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "conformsTo": 1,
          "implies": 1
        },
        "name": "same_type",
        "body": "\n\t\t\tvalue <> null implies value.type.conformsTo(end.type)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::LinkEndData::value",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"includesAll": 1},
        "name": "qualifiers",
        "body": "\n\t\t\tend.qualifier->includesAll(qualifier.qualifier)\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::LinkEndData::end",
          "UML::QualifierValue::qualifier",
          "UML::Property::qualifier",
          "UML::LinkEndData::qualifier"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "toUnlimitedNatural": 1,
          "is": 1,
          "implies": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\tvalue <> null implies value.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::LinkEndData::value"]
      }
    ],
    "properties": []
  },
  {
    "name": "ExecutionSpecification",
    "expressions": [{
      "operations": {"=": 1},
      "name": "same_lifeline",
      "body": "\n\t\t\tstart.covered = finish.covered\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "UML::OccurrenceSpecification::covered",
        "UML::ExecutionSpecification::finish",
        "UML::ExecutionSpecification::start"
      ]
    }],
    "properties": []
  },
  {
    "name": "ObjectFlow",
    "expressions": [
      {
        "operations": {},
        "name": "compatible_types",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "not": 1,
          "<>": 1,
          "size": 2,
          "and": 3,
          "is": 1,
          "implies": 1,
          "=": 2,
          "inputParameters": 2,
          "outputParameters": 1
        },
        "name": "input_and_output_parameter",
        "body": "\n\t\t\tselection <> null implies\n\t\t\tselection.inputParameters()\n\t\t\t->size() = 1 and\n\t\t\tselection.inputParameters()\n\t\t\t->forAll(not isUnique and is(0, *)) and\n\t\t\tselection.outputParameters()\n\t\t\t->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 14,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 3,
          "UnlimitedNaturalLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::MultiplicityElement::isUnique",
          "UML::ObjectFlow::selection"
        ]
      },
      {
        "operations": {},
        "name": "same_upper_bounds",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "not": 1,
          "or": 1,
          "oclIsKindOf": 2
        },
        "name": "no_executable_nodes",
        "body": "\n\t\t\tnot (\n\t\t\t  source.oclIsKindOf(ExecutableNode) or\n\t\t\t  target.oclIsKindOf(ExecutableNode)\n\t\t\t)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityEdge::source",
          "UML::ActivityEdge::target"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "size": 2,
          "and": 1,
          "implies": 1,
          "=": 2,
          "inputParameters": 1,
          "outputParameters": 1
        },
        "name": "transformation_behavior",
        "body": "\n\t\t\ttransformation <> null implies\n\t\t\ttransformation.inputParameters()\n\t\t\t->size() = 1 and\n\t\t\ttransformation.outputParameters()\n\t\t\t->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": ["UML::ObjectFlow::transformation"]
      },
      {
        "operations": {},
        "name": "target",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "not": 1,
          "and": 1
        },
        "name": "is_multicast_or_is_multireceive",
        "body": "\n\t\t\tnot (isMulticast and isMultireceive)\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ObjectFlow::isMulticast",
          "UML::ObjectFlow::isMultireceive"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "oclIsKindOf": 1,
          "implies": 1
        },
        "name": "selection_behavior",
        "body": "\n\t\t\tselection <> null implies\n\t\t\tsource.oclIsKindOf(ObjectNode)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityEdge::source",
          "UML::ObjectFlow::selection"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ReadSelfAction",
    "expressions": [
      {
        "operations": {"<>": 1},
        "name": "contained",
        "body": "\n\t\t\t_'context' <> null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Action::context"]
      },
      {
        "operations": {
          "not": 1,
          "<>": 1,
          "containingBehavior": 1,
          "implies": 1
        },
        "name": "not_static",
        "body": "\n\t\t\tlet behavior : Behavior = self.containingBehavior()\n\t\t\tin behavior.specification <> null implies not behavior.specification.isStatic\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 3,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Feature::isStatic",
          "UML::Behavior::specification"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "type",
        "body": "\n\t\t\tresult.type = _'context'\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Action::context",
          "UML::ReadSelfAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "toUnlimitedNatural": 1,
          "is": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\tresult.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ReadSelfAction::result"]
      }
    ],
    "properties": []
  },
  {
    "name": "Duration",
    "expressions": [{
      "operations": {
        "size": 1,
        "oclIsKindOf": 1,
        "and": 1,
        "implies": 1,
        "=": 2
      },
      "name": "no_expr_requires_observation",
      "body": "\n\t\t\texpr = null implies\n\t\t\tobservation->size() = 1 and\n\t\t\tobservation->forAll(\n\t\t\t  oclIsKindOf(DurationObservation))\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 6,
        "VariableExpImpl": 4,
        "NullLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::Duration::observation",
        "UML::Duration::expr"
      ]
    }],
    "properties": []
  },
  {
    "name": "State",
    "expressions": [
      {
        "operations": {
          "and": 1,
          "implies": 1,
          "=": 2
        },
        "name": "destinations_or_sources_of_transitions",
        "body": "\n\t\t\tself.isSubmachineState implies\n\t\t\tself.connection->forAll(cp |\n\t\t\t  cp.entry->forAll(ps | ps.stateMachine = self.submachine) and\n\t\t\t  cp.exit->forAll(ps | ps.stateMachine = self.submachine))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 8,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::ConnectionPointReference::entry",
          "UML::State::isSubmachineState",
          "UML::State::submachine",
          "UML::State::connection",
          "UML::Pseudostate::stateMachine",
          "UML::ConnectionPointReference::exit"
        ]
      },
      {
        "operations": {
          "or": 1,
          "=": 2
        },
        "name": "entry_or_exit",
        "body": "\n\t\t\tconnectionPoint->forAll(kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::State::connectionPoint",
          "UML::Pseudostate::kind"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "notEmpty": 1
        },
        "name": "composite_states",
        "body": "\n\t\t\tconnectionPoint->notEmpty() implies isComposite\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::State::connectionPoint",
          "UML::State::isComposite"
        ]
      },
      {
        "operations": {
          "notEmpty": 1,
          "implies": 1
        },
        "name": "submachine_states",
        "body": "\n\t\t\tisSubmachineState implies connection->notEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::State::isSubmachineState",
          "UML::State::connection"
        ]
      },
      {
        "operations": {
          "not": 1,
          "implies": 1
        },
        "name": "submachine_or_regions",
        "body": "\n\t\t\tisComposite implies not isSubmachineState\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::State::isSubmachineState",
          "UML::State::isComposite"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "AssociationClass",
    "expressions": [
      {
        "operations": {
          "flatten": 1,
          "excludes": 2,
          "and": 1,
          "endType": 2,
          "allParents": 1,
          "oclAsType": 1
        },
        "name": "cannot_be_defined",
        "body": "\n\t\t\tself.endType()\n\t\t\t->excludes(self) and\n\t\t\tself.endType()\n\t\t\t->collect(et |\n\t\t\t  et.oclAsType(Classifier)\n\t\t\t  .allParents())\n\t\t\t->flatten()\n\t\t\t->excludes(self)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 8,
          "TypeExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "intersection": 1,
          "isEmpty": 1
        },
        "name": "disjoint_attributes_ends",
        "body": "\n\t\t\townedAttribute->intersection(ownedEnd)->isEmpty()\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Class::ownedAttribute",
          "UML::Association::ownedEnd"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "AcceptEventAction",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "or": 2,
          "oclIsKindOf": 1,
          "and": 1,
          "isEmpty": 1,
          "conformsTo": 1,
          "implies": 1,
          "oclAsType": 1,
          "=": 1,
          "first": 1
        },
        "name": "conforming_type",
        "body": "\n\t\t\tnot isUnmarshall implies\n\t\t\tresult->isEmpty() or\n\t\t\tlet type : Type = result->first().type\n\t\t\tin type = null or\n\t\t\t  trigger->forAll(\n\t\t\t    event.oclIsKindOf(SignalEvent)) and\n\t\t\t  trigger.event.oclAsType(SignalEvent)\n\t\t\t  .signal->forAll(s | s.conformsTo(type))\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 5,
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 12,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::AcceptEventAction::result",
          "UML::AcceptEventAction::trigger",
          "UML::Trigger::event",
          "UML::SignalEvent::signal",
          "UML::AcceptEventAction::isUnmarshall",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "allAttributes": 1,
          "oclAsType": 1,
          "asSequence": 2,
          "at": 6,
          "size": 5,
          "oclIsTypeOf": 1,
          "and": 7,
          "includesMultiplicity": 1,
          "implies": 1,
          "=": 4,
          "first": 2,
          ">": 1
        },
        "name": "unmarshall_signal_events",
        "body": "\n\t\t\tisUnmarshall and\n\t\t\tself.oclIsTypeOf(AcceptEventAction) implies\n\t\t\ttrigger->size() = 1 and\n\t\t\ttrigger->asSequence()\n\t\t\t->first()\n\t\t\t.event.oclIsKindOf(SignalEvent) and\n\t\t\tlet\n\t\t\t  attribute : OrderedSet(Property) = trigger->asSequence()\n\t\t\t  ->first()\n\t\t\t  .event.oclAsType(SignalEvent)\n\t\t\t  .signal.allAttributes()\n\t\t\tin\n\t\t\t  attribute->size() > 0 and\n\t\t\t  result->size() =\n\t\t\t  attribute->size() and\n\t\t\t  Sequence{1..result->size()\n\t\t\t  }\n\t\t\t  ->forAll(i |\n\t\t\t    result->at(i).type =\n\t\t\t    attribute->at(i).type and\n\t\t\t    result->at(i).isOrdered =\n\t\t\t    attribute->at(i).isOrdered and\n\t\t\t    result->at(i)\n\t\t\t    .includesMultiplicity(attribute->at(i)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 21,
          "OperationCallExpImpl": 33,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 3,
          "TypeExpImpl": 3,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 16
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::AcceptEventAction::result",
          "UML::Trigger::event",
          "UML::AcceptEventAction::trigger",
          "UML::SignalEvent::signal",
          "UML::AcceptEventAction::isUnmarshall",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "not": 1,
          "or": 1,
          "size": 1,
          "oclIsKindOf": 2,
          "and": 2,
          "toUnlimitedNatural": 1,
          "is": 1,
          "implies": 1,
          "=": 1,
          "first": 1
        },
        "name": "one_output_pin",
        "body": "\n\t\t\tnot isUnmarshall and\n\t\t\ttrigger->exists(\n\t\t\t  (\n\t\t\t    event.oclIsKindOf(SignalEvent) or\n\t\t\t    event.oclIsKindOf(TimeEvent)\n\t\t\t  )) implies\n\t\t\toutput->size() = 1 and\n\t\t\toutput->first()\n\t\t\t.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 12,
          "VariableExpImpl": 6,
          "IntegerLiteralExpImpl": 3,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Action::output",
          "UML::Trigger::event",
          "UML::AcceptEventAction::trigger",
          "UML::AcceptEventAction::isUnmarshall"
        ]
      },
      {
        "operations": {
          "or": 1,
          "size": 1,
          "oclIsTypeOf": 1,
          "oclIsKindOf": 2,
          "and": 1,
          "implies": 1,
          "=": 1
        },
        "name": "no_output_pins",
        "body": "\n\t\t\tself.oclIsTypeOf(AcceptEventAction) and\n\t\t\ttrigger->forAll(\n\t\t\t  (\n\t\t\t    event.oclIsKindOf(ChangeEvent) or\n\t\t\t    event.oclIsKindOf(CallEvent)\n\t\t\t  )) implies\n\t\t\toutput->size() = 0\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 8,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Action::output",
          "UML::Trigger::event",
          "UML::AcceptEventAction::trigger"
        ]
      },
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "no_input_pins",
        "body": "\n\t\t\tinput->size() = 0\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Action::input"]
      }
    ],
    "properties": []
  },
  {
    "name": "TemplateSignature",
    "expressions": [
      {
        "operations": {
          "includesAll": 1,
          "asSet": 2,
          "-": 1
        },
        "name": "own_elements",
        "body": "\n\t\t\ttemplate.ownedElement->includesAll(\n\t\t\t  parameter.parameteredElement->asSet() -\n\t\t\t  parameter.ownedParameteredElement->asSet())\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 5,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::TemplateSignature::template",
          "UML::TemplateParameter::parameteredElement",
          "UML::TemplateParameter::ownedParameteredElement",
          "UML::Element::ownedElement",
          "UML::TemplateSignature::parameter"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "oclIsKindOf": 2,
          "and": 2,
          "implies": 1,
          "oclAsType": 2
        },
        "name": "unique_parameters",
        "body": "\n\t\t\tparameter->forAll(p1, p2 | p1 <> p2 and\n\t\t\t  p1.parameteredElement.oclIsKindOf(NamedElement) and\n\t\t\t  p2.parameteredElement.oclIsKindOf(NamedElement) implies\n\t\t\t  p1.parameteredElement.oclAsType(NamedElement).name <>\n\t\t\t  p2.parameteredElement.oclAsType(NamedElement).name)\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 7,
          "OperationCallExpImpl": 9,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::TemplateParameter::parameteredElement",
          "UML::NamedElement::name",
          "UML::TemplateSignature::parameter"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Component",
    "expressions": [
      {
        "operations": {"isEmpty": 1},
        "name": "no_nested_classifiers",
        "body": "\n\t\t\tnestedClassifier->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Class::nestedClassifier"]
      },
      {
        "operations": {
          "<>": 1,
          "isEmpty": 1,
          "implies": 1
        },
        "name": "no_packaged_elements",
        "body": "\n\t\t\tnestingClass <> null implies packagedElement->isEmpty()\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "OppositePropertyCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Component::packagedElement"]
      }
    ],
    "properties": []
  },
  {
    "name": "Profile",
    "expressions": [
      {
        "operations": {
          "union": 1,
          "allOwningPackages": 2,
          "notEmpty": 1
        },
        "name": "references_same_metamodel",
        "body": "\n\t\t\tmetamodelReference.importedPackage.elementImport.importedElement.allOwningPackages()\n\t\t\t->union(metaclassReference.importedElement.allOwningPackages())\n\t\t\t->notEmpty()\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 6,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 8,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::PackageImport::importedPackage",
          "UML::Profile::metaclassReference",
          "UML::ElementImport::importedElement",
          "UML::Namespace::elementImport",
          "UML::Profile::metamodelReference"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 3,
          "and": 2,
          "intersection": 1,
          "allParents": 2,
          "isEmpty": 2,
          "includes": 1,
          "oclAsType": 3
        },
        "name": "metaclass_reference_not_specialized",
        "body": "\n\t\t\tmetaclassReference.importedElement->select(c |\n\t\t\t  c.oclIsKindOf(Classifier) and\n\t\t\t  c.oclAsType(Classifier)\n\t\t\t  .allParents()\n\t\t\t  ->collect(namespace)\n\t\t\t  ->includes(self))\n\t\t\t->isEmpty() and\n\t\t\tpackagedElement->select(\n\t\t\t  oclIsKindOf(Classifier))\n\t\t\t->collect(\n\t\t\t  oclAsType(Classifier)\n\t\t\t  .allParents())\n\t\t\t->intersection(\n\t\t\t  metaclassReference.importedElement->select(\n\t\t\t    oclIsKindOf(Classifier))\n\t\t\t  ->collect(oclAsType(Classifier)))\n\t\t\t->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 8,
          "VariableExpImpl": 13,
          "OperationCallExpImpl": 14,
          "TypeExpImpl": 6,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Profile::metaclassReference",
          "UML::Package::packagedElement",
          "UML::NamedElement::namespace",
          "UML::ElementImport::importedElement"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ExtensionPoint",
    "expressions": [{
      "operations": {
        "oclAsSet": 1,
        "notEmpty": 1
      },
      "name": "must_have_name",
      "body": "\n\t\t\tname->notEmpty()\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 2,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::NamedElement::name"]
    }],
    "properties": []
  },
  {
    "name": "StructuralFeatureAction",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "allFeatures": 1,
          "includes": 1,
          "conformsTo": 1,
          "oclAsType": 2
        },
        "name": "object_type",
        "body": "\n\t\t\tobject.type.oclAsType(Classifier)\n\t\t\t.allFeatures()\n\t\t\t->includes(structuralFeature) or\n\t\t\tobject.type.conformsTo(\n\t\t\t  structuralFeature.oclAsType(Property).opposite.type)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 4,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::StructuralFeatureAction::object",
          "UML::Property::opposite",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity",
        "body": "\n\t\t\tobject.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::StructuralFeatureAction::object"]
      },
      {
        "operations": {
          "size": 1,
          "oclAsSet": 1,
          "=": 1
        },
        "name": "one_featuring_classifier",
        "body": "\n\t\t\tstructuralFeature.featuringClassifier->size() = 1\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Feature::featuringClassifier",
          "UML::StructuralFeatureAction::structuralFeature"
        ]
      },
      {
        "operations": {
          "or": 2,
          "and": 1,
          "allFeatures": 1,
          "includes": 1,
          "conformsTo": 1,
          "=": 2,
          "oclAsType": 2
        },
        "name": "visibility",
        "body": "\n\t\t\tstructuralFeature.visibility = VisibilityKind::public or\n\t\t\t_'context'.allFeatures()\n\t\t\t->includes(structuralFeature) or structuralFeature.visibility = VisibilityKind::protected and\n\t\t\t_'context'.conformsTo(\n\t\t\t  structuralFeature.oclAsType(Property)\n\t\t\t  .opposite.type.oclAsType(Classifier))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 6,
          "OperationCallExpImpl": 10,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::Action::context",
          "UML::StructuralFeatureAction::structuralFeature",
          "UML::Property::opposite",
          "UML::NamedElement::visibility",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {"not": 1},
        "name": "not_static",
        "body": "\n\t\t\tnot structuralFeature.isStatic\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Feature::isStatic",
          "UML::StructuralFeatureAction::structuralFeature"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ConnectorEnd",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "oclIsKindOf": 1,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1
        },
        "name": "self_part_with_port",
        "body": "\n\t\t\tpartWithPort->notEmpty() implies\n\t\t\tnot partWithPort.oclIsKindOf(Port)\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::ConnectorEnd::partWithPort"]
      },
      {
        "operations": {"compatibleWith": 1},
        "name": "multiplicity",
        "body": "\n\t\t\tself.compatibleWith(definingEnd)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ConnectorEnd::definingEnd"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "isEmpty": 1,
          "oclAsSet": 1,
          "implies": 1,
          "=": 1
        },
        "name": "part_with_port_empty",
        "body": "\n\t\t\trole.oclIsKindOf(Port) and role.owner = connector.owner implies\n\t\t\tpartWithPort->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 4,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ConnectorEnd::partWithPort",
          "UML::ConnectorEnd::role",
          "UML::Element::owner"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "oclAsSet": 1,
          "includes": 1,
          "notEmpty": 1,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "role_and_part_with_port",
        "body": "\n\t\t\tpartWithPort->notEmpty() implies\n\t\t\trole.oclIsKindOf(Port) and\n\t\t\tpartWithPort.type.oclAsType(Namespace)\n\t\t\t.member->includes(role)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 7,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "UML::Namespace::member",
          "UML::ConnectorEnd::partWithPort",
          "UML::ConnectorEnd::role",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "InteractionConstraint",
    "expressions": [
      {
        "operations": {
          "and": 1,
          "oclAsSet": 4,
          "integerValue": 2,
          "notEmpty": 2,
          "implies": 1,
          "first": 2,
          "asSequence": 2,
          ">=": 1
        },
        "name": "maxint_greater_equal_minint",
        "body": "\n\t\t\tmaxint->notEmpty() implies\n\t\t\tminint->notEmpty() and\n\t\t\tmaxint->asSequence()\n\t\t\t->first()\n\t\t\t.integerValue() >=\n\t\t\tminint->asSequence()\n\t\t\t->first()\n\t\t\t.integerValue()\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 15,
          "VariableExpImpl": 4,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::InteractionConstraint::minint",
          "UML::InteractionConstraint::maxint"
        ]
      },
      {
        "operations": {},
        "name": "dynamic_variables",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "oclAsSet": 2,
          "integerValue": 1,
          "notEmpty": 1,
          "implies": 1,
          "first": 1,
          "asSequence": 1,
          ">=": 1
        },
        "name": "minint_non_negative",
        "body": "\n\t\t\tminint->notEmpty() implies minint->asSequence()->first().integerValue() >= 0\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::InteractionConstraint::minint"]
      },
      {
        "operations": {},
        "name": "global_data",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "oclAsSet": 2,
          "integerValue": 1,
          "implies": 1,
          "notEmpty": 1,
          ">": 1,
          "first": 1,
          "asSequence": 1
        },
        "name": "maxint_positive",
        "body": "\n\t\t\tmaxint->notEmpty() implies maxint->asSequence()->first().integerValue() > 0\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::InteractionConstraint::maxint"]
      },
      {
        "operations": {
          "or": 1,
          "oclAsSet": 2,
          "notEmpty": 2,
          "implies": 1,
          "=": 1
        },
        "name": "minint_maxint",
        "body": "\n\t\t\tmaxint->notEmpty() or\n\t\t\tminint->notEmpty() implies interactionOperand.combinedFragment.interactionOperator = InteractionOperatorKind::loop\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 7,
          "OppositePropertyCallExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::InteractionConstraint::minint",
          "UML::CombinedFragment::interactionOperator",
          "UML::InteractionConstraint::maxint"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ProtocolTransition",
    "expressions": [
      {
        "operations": {"belongsToPSM": 1},
        "name": "belongs_to_psm",
        "body": "\n\t\t\tcontainer.belongsToPSM()\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Transition::container"]
      },
      {
        "operations": {
          "includesAll": 1,
          "and": 1,
          "allFeatures": 1,
          "oclAsSet": 1,
          "notEmpty": 2,
          "oclAsType": 1,
          "containingStateMachine": 2,
          "referred": 2
        },
        "name": "refers_to_operation",
        "body": "\n\t\t\tif referred()->notEmpty() and containingStateMachine()._'context'->notEmpty()\n\t\t\tthen\n\t\t\t  containingStateMachine()\n\t\t\t  ._'context'.oclAsType(BehavioredClassifier)\n\t\t\t  .allFeatures()\n\t\t\t  ->includesAll(referred())\n\t\t\telse true\n\t\t\tendif\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 11,
          "VariableExpImpl": 4,
          "TypeExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 2,
          "BooleanLiteralExpImpl": 1
        },
        "properties": ["UML::Behavior::context"]
      },
      {
        "operations": {"=": 1},
        "name": "associated_actions",
        "body": "\n\t\t\teffect = null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Transition::effect"]
      }
    ],
    "properties": []
  },
  {
    "name": "RedefinableElement",
    "expressions": [
      {
        "operations": {"isRedefinitionContextValid": 1},
        "name": "redefinition_context_valid",
        "body": "\n\t\t\tredefinedElement->forAll(re | self.isRedefinitionContextValid(re))\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::RedefinableElement::redefinedElement"]
      },
      {
        "operations": {"isConsistentWith": 1},
        "name": "redefinition_consistent",
        "body": "\n\t\t\tredefinedElement->forAll(re | re.isConsistentWith(self))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::RedefinableElement::redefinedElement"]
      },
      {
        "operations": {"not": 1},
        "name": "non_leaf_redefinition",
        "body": "\n\t\t\tredefinedElement->forAll(re | not re.isLeaf)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::RedefinableElement::redefinedElement",
          "UML::RedefinableElement::isLeaf"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "BehavioredClassifier",
    "expressions": [{
      "operations": {
        "isEmpty": 1,
        "oclAsSet": 2,
        "notEmpty": 1,
        "implies": 1
      },
      "name": "class_behavior",
      "body": "\n\t\t\tclassifierBehavior->notEmpty() implies\n\t\t\tclassifierBehavior.specification->isEmpty()\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 5,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "UML::Behavior::specification",
        "UML::BehavioredClassifier::classifierBehavior"
      ]
    }],
    "properties": []
  },
  {
    "name": "InitialNode",
    "expressions": [
      {
        "operations": {"isEmpty": 1},
        "name": "no_incoming_edges",
        "body": "\n\t\t\tincoming->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::incoming"]
      },
      {
        "operations": {"oclIsKindOf": 1},
        "name": "control_edges",
        "body": "\n\t\t\toutgoing->forAll(oclIsKindOf(ControlFlow))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::outgoing"]
      }
    ],
    "properties": []
  },
  {
    "name": "StartObjectBehaviorAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "behavior": 1
        },
        "name": "type_of_object",
        "body": "\n\t\t\tself.behavior() <> null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "NullLiteralExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {
          "oclAsSet": 1,
          "isEmpty": 1
        },
        "name": "no_onport",
        "body": "\n\t\t\tonPort->isEmpty()\n\t\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::InvocationAction::onPort"]
      },
      {
        "operations": {
          "is": 1,
          "toUnlimitedNatural": 1
        },
        "name": "multiplicity_of_object",
        "body": "\n\t\t\tobject.is(1, 1)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::StartObjectBehaviorAction::object"]
      }
    ],
    "properties": []
  },
  {
    "name": "Node",
    "expressions": [{
      "operations": {"oclIsKindOf": 1},
      "name": "internal_structure",
      "body": "\n\t\t\tpart->forAll(oclIsKindOf(Node))\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 2,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["UML::StructuredClassifier::part"]
    }],
    "properties": []
  },
  {
    "name": "DecisionNode",
    "expressions": [
      {
        "operations": {
          "<>": 2,
          "size": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "implies": 1,
          "=": 1,
          "inputParameters": 1
        },
        "name": "two_input_parameters",
        "body": "\n\t\t\tdecisionInput <> null and decisionInputFlow <> null and\n\t\t\tincoming->forAll(oclIsKindOf(ObjectFlow)) implies\n\t\t\tdecisionInput.inputParameters()\n\t\t\t->size() = 2\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::DecisionNode::decisionInput",
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {
          "<>": 4,
          "and": 2,
          "implies": 1
        },
        "name": "parameters",
        "body": "\n\t\t\tdecisionInput <> null implies\n\t\t\tdecisionInput.ownedParameter->forAll(par | par.direction <> ParameterDirectionKind::out and par.direction <> ParameterDirectionKind::inout) and\n\t\t\tdecisionInput.ownedParameter->one(par | par.direction <> ParameterDirectionKind::return)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 6,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 3,
          "PropertyCallExpImpl": 8
        },
        "properties": [
          "UML::DecisionNode::decisionInput",
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "isEmpty": 1,
          "implies": 1,
          "=": 1,
          "inputParameters": 1
        },
        "name": "zero_input_parameters",
        "body": "\n\t\t\tdecisionInput <> null and decisionInputFlow = null and\n\t\t\tincoming->exists(oclIsKindOf(ControlFlow)) implies\n\t\t\tdecisionInput.inputParameters()\n\t\t\t->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::DecisionNode::decisionInput",
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 2,
          "excluding": 1,
          "oclAsSet": 1,
          "union": 1,
          "notEmpty": 1
        },
        "name": "edges",
        "body": "\n\t\t\tlet\n\t\t\t  allEdges : Set(ActivityEdge) = incoming->union(outgoing)\n\t\t\tin\n\t\t\t  let\n\t\t\t    allRelevantEdges : Set(ActivityEdge) = if\n\t\t\t      decisionInputFlow->notEmpty()\n\t\t\t    then allEdges->excluding(decisionInputFlow)\n\t\t\t    else allEdges\n\t\t\t    endif\n\t\t\t  in\n\t\t\t    allRelevantEdges->forAll(\n\t\t\t      oclIsKindOf(ControlFlow)) or\n\t\t\t    allRelevantEdges->forAll(\n\t\t\t      oclIsKindOf(ObjectFlow))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 10,
          "LetExpImpl": 2,
          "TypeExpImpl": 2,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {"includes": 1},
        "name": "decision_input_flow_incoming",
        "body": "\n\t\t\tincoming->includes(decisionInputFlow)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {
          "or": 1,
          "size": 3,
          "and": 1,
          "=": 2,
          ">": 1
        },
        "name": "incoming_outgoing_edges",
        "body": "\n\t\t\t(incoming->size() = 1 or incoming->size() = 2\n\t\t\t) and\n\t\t\toutgoing->size() > 0\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "size": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "implies": 1,
          "inputParameters": 1,
          "=": 1
        },
        "name": "incoming_control_one_input_parameter",
        "body": "\n\t\t\tdecisionInput <> null and decisionInputFlow <> null and\n\t\t\tincoming->exists(oclIsKindOf(ControlFlow)) implies\n\t\t\tdecisionInput.inputParameters()\n\t\t\t->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::DecisionNode::decisionInput",
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInputFlow"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "size": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "implies": 1,
          "inputParameters": 1,
          "=": 2
        },
        "name": "incoming_object_one_input_parameter",
        "body": "\n\t\t\tdecisionInput <> null and decisionInputFlow = null and\n\t\t\tincoming->forAll(oclIsKindOf(ObjectFlow)) implies\n\t\t\tdecisionInput.inputParameters()\n\t\t\t->size() = 1\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 9,
          "NullLiteralExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::DecisionNode::decisionInput",
          "UML::ActivityNode::incoming",
          "UML::DecisionNode::decisionInputFlow"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ClearStructuralFeatureAction",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "implies": 1,
          "=": 1
        },
        "name": "type_of_result",
        "body": "\n\t\t\tresult <> null implies result.type = object.type\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::StructuralFeatureAction::object",
          "UML::ClearStructuralFeatureAction::result",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "is": 1,
          "toUnlimitedNatural": 1,
          "implies": 1
        },
        "name": "multiplicity_of_result",
        "body": "\n\t\t\tresult <> null implies result.is(1, 1)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::ClearStructuralFeatureAction::result"]
      }
    ],
    "properties": []
  },
  {
    "name": "Connector",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "at": 2,
          "size": 2,
          "and": 1,
          "conformsTo": 1,
          "implies": 1,
          "=": 1
        },
        "name": "types",
        "body": "\n\t\t\ttype <> null implies\n\t\t\tlet noOfEnds : Integer = end->size()\n\t\t\tin\n\t\t\t  type.memberEnd->size() = noOfEnds and\n\t\t\t  Sequence{1..noOfEnds\n\t\t\t  }\n\t\t\t  ->forAll(i |\n\t\t\t    end->at(i)\n\t\t\t    .role.type.conformsTo(type.memberEnd->at(i).type))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 9,
          "LetExpImpl": 1,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::Connector::type",
          "UML::Connector::end",
          "UML::Association::memberEnd",
          "UML::ConnectorEnd::role",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "or": 1,
          "oclIsKindOf": 1,
          "and": 2,
          "allRoles": 2,
          "includes": 2
        },
        "name": "roles",
        "body": "\n\t\t\tstructuredClassifier <> null and\n\t\t\tend->forAll(e |\n\t\t\t  (\n\t\t\t    structuredClassifier.allRoles()\n\t\t\t    ->includes(e.role) or\n\t\t\t    e.role.oclIsKindOf(Port) and\n\t\t\t    structuredClassifier.allRoles()\n\t\t\t    ->includes(e.partWithPort)\n\t\t\t  ))\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 7,
          "NullLiteralExpImpl": 1,
          "OppositePropertyCallExpImpl": 3,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Connector::end",
          "UML::ConnectorEnd::partWithPort",
          "UML::ConnectorEnd::role"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ProtocolStateMachine",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 2,
          "oclAsSet": 3,
          "isEmpty": 3,
          "implies": 1,
          "oclAsType": 3
        },
        "name": "entry_exit_do",
        "body": "\n\t\t\tregion->forAll(r |\n\t\t\t  r.subvertex->forAll(v |\n\t\t\t    v.oclIsKindOf(State) implies\n\t\t\t    v.oclAsType(State)\n\t\t\t    .entry->isEmpty() and\n\t\t\t    v.oclAsType(State)\n\t\t\t    .exit->isEmpty() and\n\t\t\t    v.oclAsType(State)\n\t\t\t    .doActivity->isEmpty()))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 6,
          "TypeExpImpl": 4,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::State::doActivity",
          "UML::Region::subvertex",
          "UML::State::exit",
          "UML::StateMachine::region",
          "UML::State::entry"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "oclIsKindOf": 1,
          "and": 1,
          "implies": 1,
          "oclAsType": 2
        },
        "name": "deep_or_shallow_history",
        "body": "\n\t\t\tregion->forAll(r |\n\t\t\t  r.subvertex->forAll(v |\n\t\t\t    v.oclIsKindOf(Pseudostate) implies\n\t\t\t    v.oclAsType(Pseudostate).kind <> PseudostateKind::deepHistory and\n\t\t\t    v.oclAsType(Pseudostate).kind <> PseudostateKind::shallowHistory))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 7,
          "EnumLiteralExpImpl": 2,
          "TypeExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Region::subvertex",
          "UML::StateMachine::region",
          "UML::Pseudostate::kind"
        ]
      },
      {
        "operations": {"oclIsTypeOf": 1},
        "name": "protocol_transitions",
        "body": "\n\t\t\tregion->forAll(r |\n\t\t\t  r.transition->forAll(t |\n\t\t\t    t.oclIsTypeOf(ProtocolTransition)))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::StateMachine::region",
          "UML::Region::transition"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "and": 1,
          "=": 1
        },
        "name": "classifier_context",
        "body": "\n\t\t\t_'context' <> null and specification = null\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::Behavior::context",
          "UML::Behavior::specification"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "GeneralOrdering",
    "expressions": [{
      "operations": {
        "excludes": 1,
        "oclAsSet": 1
      },
      "name": "irreflexive_transitive_closure",
      "body": "\n\t\t\tafter->closure(toAfter.after)->excludes(before)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "VariableExpImpl": 4,
        "OperationCallExpImpl": 2,
        "PropertyCallExpImpl": 4
      },
      "properties": [
        "UML::OccurrenceSpecification::toAfter",
        "UML::GeneralOrdering::before",
        "UML::GeneralOrdering::after"
      ]
    }],
    "properties": []
  },
  {
    "name": "ExtensionEnd",
    "expressions": [
      {
        "operations": {"=": 1},
        "name": "aggregation",
        "body": "\n\t\t\tself.aggregation = AggregationKind::composite\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::Property::aggregation"]
      },
      {
        "operations": {
          "or": 1,
          "upperBound": 1,
          "and": 1,
          "lowerBound": 2,
          "=": 3
        },
        "name": "multiplicity",
        "body": "\n\t\t\t(lowerBound() = 0 or lowerBound() = 1\n\t\t\t) and\n\t\t\tupperBound() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 3
        },
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "RemoveVariableValueAction",
    "expressions": [{
      "operations": {
        "not": 2,
        "<>": 2,
        "and": 6,
        "toUnlimitedNatural": 1,
        "is": 1,
        "=": 3
      },
      "name": "removeAt_and_value",
      "body": "\n\t\t\tif variable.isOrdered and not variable.isUnique and not isRemoveDuplicates\n\t\t\tthen value = null and removeAt <> null and removeAt.type = UnlimitedNatural and\n\t\t\t  removeAt.is(1, 1)\n\t\t\telse removeAt = null and value <> null\n\t\t\tendif\n\t\n\t\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 15,
        "VariableExpImpl": 9,
        "NullLiteralExpImpl": 4,
        "IntegerLiteralExpImpl": 2,
        "TypeExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 12
      },
      "properties": [
        "UML::MultiplicityElement::isOrdered",
        "UML::MultiplicityElement::isUnique",
        "UML::WriteVariableAction::value",
        "UML::RemoveVariableValueAction::removeAt",
        "UML::VariableAction::variable",
        "UML::RemoveVariableValueAction::isRemoveDuplicates",
        "UML::TypedElement::type"
      ]
    }],
    "properties": []
  },
  {
    "name": "SendSignalAction",
    "expressions": [
      {
        "operations": {
          "size": 2,
          "allAttributes": 1,
          "=": 1
        },
        "name": "number_order",
        "body": "\n\t\t\targument->size() = signal.allAttributes()->size()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::InvocationAction::argument",
          "UML::SendSignalAction::signal"
        ]
      },
      {
        "operations": {
          "at": 6,
          "compatibleWith": 1,
          "size": 1,
          "and": 2,
          "allAttributes": 1,
          "conformsTo": 1,
          "=": 1
        },
        "name": "type_ordering_multiplicity",
        "body": "\n\t\t\tlet attribute : OrderedSet(Property) = signal.allAttributes()\n\t\t\tin\n\t\t\t  Sequence{1..argument->size()\n\t\t\t  }\n\t\t\t  ->forAll(i |\n\t\t\t    argument->at(i)\n\t\t\t    .type.conformsTo(attribute->at(i).type) and\n\t\t\t    argument->at(i).isOrdered =\n\t\t\t    attribute->at(i).isOrdered and\n\t\t\t    argument->at(i)\n\t\t\t    .compatibleWith(attribute->at(i)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 14,
          "OperationCallExpImpl": 13,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 9
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::InvocationAction::argument",
          "UML::SendSignalAction::signal",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "not": 1,
          "allFeatures": 1,
          "isEmpty": 1,
          "oclAsSet": 1,
          "includes": 1,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "type_target_pin",
        "body": "\n\t\t\tnot onPort->isEmpty() implies\n\t\t\ttarget.type.oclAsType(Classifier)\n\t\t\t.allFeatures()\n\t\t\t->includes(onPort)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 3,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::SendSignalAction::target",
          "UML::InvocationAction::onPort",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "OpaqueExpression",
    "expressions": [
      {
        "operations": {
          "<>": 2,
          "isEmpty": 1,
          "implies": 1
        },
        "name": "only_return_result_parameters",
        "body": "\n\t\t\tbehavior <> null implies\n\t\t\tbehavior.ownedParameter->select(direction <> ParameterDirectionKind::return)\n\t\t\t->isEmpty()\n\t\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::OpaqueExpression::behavior",
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "one_return_result_parameter",
        "body": "\n\t\t\tbehavior <> null implies\n\t\t\tbehavior.ownedParameter->select(direction = ParameterDirectionKind::return)\n\t\t\t->size() = 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "NullLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::OpaqueExpression::behavior",
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "size": 2,
          "notEmpty": 1,
          "implies": 1,
          "=": 1
        },
        "name": "language_body_size",
        "body": "\n\t\t\tlanguage->notEmpty() implies _'body'->size() = language->size()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::OpaqueExpression::body",
          "UML::OpaqueExpression::language"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Stereotype",
    "expressions": [
      {
        "operations": {
          "size": 1,
          "=": 1
        },
        "name": "binaryAssociationsOnly",
        "body": "\n\t\t\townedAttribute.association->forAll(memberEnd->size() = 2)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Association::memberEnd",
          "UML::Property::association",
          "UML::Class::ownedAttribute"
        ]
      },
      {
        "operations": {},
        "name": "name_not_clash",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "not": 2,
          "oclIsKindOf": 2,
          "and": 2,
          "oclAsSet": 1,
          "notEmpty": 1,
          "=": 1
        },
        "name": "associationEndOwnership",
        "body": "\n\t\t\townedAttribute->select(\n\t\t\t  association->notEmpty() and\n\t\t\t  not association.oclIsKindOf(Extension) and\n\t\t\t  not type.oclIsKindOf(Stereotype))\n\t\t\t->forAll(opposite.owner = association)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 9,
          "VariableExpImpl": 6,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::Property::opposite",
          "UML::Property::association",
          "UML::Element::owner",
          "UML::Class::ownedAttribute",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {},
        "name": "base_property_upper_bound",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "base_property_multiplicity_single_extension",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "base_property_multiplicity_multiple_extension",
        "body": "\n\t\t\tnull\n\t\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "oclIsKindOf": 3,
          "and": 1,
          "allParents": 2,
          "allInstances": 1,
          "implies": 1
        },
        "name": "generalize",
        "body": "\n\t\t\tallParents()\n\t\t\t->forAll(oclIsKindOf(Stereotype)) and\n\t\t\tClassifier.allInstances()\n\t\t\t->forAll(c |\n\t\t\t  (\n\t\t\t    c.allParents()\n\t\t\t    ->exists(oclIsKindOf(Stereotype)) implies\n\t\t\t    c.oclIsKindOf(Stereotype)\n\t\t\t  ))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 8,
          "VariableExpImpl": 5,
          "TypeExpImpl": 4
        },
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "CollaborationUse",
    "expressions": [
      {
        "operations": {
          "oclIsKindOf": 4,
          "and": 5,
          "oclAsType": 4,
          "=": 2
        },
        "name": "client_elements",
        "body": "\n\t\t\troleBinding->collect(client)\n\t\t\t->forAll(ne1, ne2 |\n\t\t\t  ne1.oclIsKindOf(ConnectableElement) and\n\t\t\t  ne2.oclIsKindOf(ConnectableElement) and\n\t\t\t  let\n\t\t\t    ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement)\n\t\t\t  in\n\t\t\t    let\n\t\t\t      ce2 : ConnectableElement = ne2.oclAsType(ConnectableElement)\n\t\t\t    in ce1.structuredClassifier = ce2.structuredClassifier) and\n\t\t\troleBinding->collect(supplier)\n\t\t\t->forAll(ne1, ne2 |\n\t\t\t  ne1.oclIsKindOf(ConnectableElement) and\n\t\t\t  ne2.oclIsKindOf(ConnectableElement) and\n\t\t\t  let\n\t\t\t    ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement)\n\t\t\t  in\n\t\t\t    let\n\t\t\t      ce2 : ConnectableElement = ne2.oclAsType(ConnectableElement)\n\t\t\t    in ce1.collaboration = ce2.collaboration)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 16,
          "OperationCallExpImpl": 15,
          "LetExpImpl": 4,
          "OppositePropertyCallExpImpl": 4,
          "TypeExpImpl": 8,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::CollaborationUse::roleBinding",
          "UML::Dependency::supplier",
          "UML::Dependency::client"
        ]
      },
      {
        "operations": {
          "and": 2,
          "intersection": 1,
          "oclAsSet": 3,
          "includes": 1,
          "conformsTo": 1,
          "asSet": 2,
          "notEmpty": 3,
          "implies": 1,
          "oclAsType": 1
        },
        "name": "connectors",
        "body": "\n\t\t\ttype.ownedConnector->forAll(connector |\n\t\t\t  let\n\t\t\t    rolesConnectedInCollab : Set(ConnectableElement) = connector.end.role->asSet()\n\t\t\t  in\n\t\t\t    let\n\t\t\t      relevantBindings : Set(Dependency) = roleBinding->select(rb |\n\t\t\t        rb.supplier->intersection(rolesConnectedInCollab)\n\t\t\t        ->notEmpty())\n\t\t\t    in\n\t\t\t      let\n\t\t\t        boundRoles : Set(ConnectableElement) = relevantBindings->collect(\n\t\t\t          client.oclAsType(ConnectableElement))\n\t\t\t        ->asSet()\n\t\t\t      in\n\t\t\t        let\n\t\t\t          contextClassifier : StructuredClassifier = boundRoles->any(true)\n\t\t\t          .structuredClassifier->any(true)\n\t\t\t        in\n\t\t\t          contextClassifier.ownedConnector->exists(correspondingConnector |\n\t\t\t            correspondingConnector.end.role->forAll(role |\n\t\t\t              boundRoles->includes(role)) and\n\t\t\t            connector.type->notEmpty() and\n\t\t\t            correspondingConnector.type->notEmpty() implies\n\t\t\t            connector.type->forAll(\n\t\t\t              conformsTo(correspondingConnector.type))))\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 11,
          "VariableExpImpl": 20,
          "OperationCallExpImpl": 15,
          "LetExpImpl": 4,
          "OppositePropertyCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 14,
          "BooleanLiteralExpImpl": 2
        },
        "properties": [
          "UML::Connector::end",
          "UML::Connector::type",
          "UML::CollaborationUse::roleBinding",
          "UML::ConnectorEnd::role",
          "UML::Dependency::supplier",
          "UML::StructuredClassifier::ownedConnector",
          "UML::CollaborationUse::type",
          "UML::Dependency::client"
        ]
      },
      {
        "operations": {"includes": 1},
        "name": "every_role",
        "body": "\n\t\t\ttype.collaborationRole->forAll(role |\n\t\t\t  roleBinding->exists(rb | rb.supplier->includes(role)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Collaboration::collaborationRole",
          "UML::CollaborationUse::roleBinding",
          "UML::Dependency::supplier",
          "UML::CollaborationUse::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "TemplateBinding",
    "expressions": [
      {
        "operations": {"includes": 1},
        "name": "parameter_substitution_formal",
        "body": "\n\t\t\tparameterSubstitution->forAll(b |\n\t\t\t  signature.parameter->includes(b.formal))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TemplateBinding::signature",
          "UML::TemplateParameterSubstitution::formal",
          "UML::TemplateBinding::parameterSubstitution",
          "UML::TemplateSignature::parameter"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "size": 1,
          "=": 1
        },
        "name": "one_parameter_substitution",
        "body": "\n\t\t\tsignature.parameter->forAll(p |\n\t\t\t  parameterSubstitution->select(b | (b.formal = p))\n\t\t\t  ->size() <= 1)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::TemplateBinding::signature",
          "UML::TemplateParameterSubstitution::formal",
          "UML::TemplateBinding::parameterSubstitution",
          "UML::TemplateSignature::parameter"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "ReplyAction",
    "expressions": [
      {
        "operations": {"oclIsKindOf": 1},
        "name": "event_on_reply_to_call_trigger",
        "body": "\n\t\t\treplyToCall.event.oclIsKindOf(CallEvent)\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::ReplyAction::replyToCall",
          "UML::Trigger::event"
        ]
      },
      {
        "operations": {
          "at": 6,
          "size": 3,
          "compatibleWith": 1,
          "and": 3,
          "conformsTo": 1,
          "=": 2,
          "oclAsType": 1,
          "outputParameters": 1
        },
        "name": "pins_match_parameter",
        "body": "\n\t\t\tlet\n\t\t\t  parameter : OrderedSet(Parameter) = replyToCall.event.oclAsType(CallEvent)\n\t\t\t  .operation.outputParameters()\n\t\t\tin\n\t\t\t  replyValue->size() =\n\t\t\t  parameter->size() and\n\t\t\t  Sequence{1..replyValue->size()\n\t\t\t  }\n\t\t\t  ->forAll(i |\n\t\t\t    replyValue->at(i)\n\t\t\t    .type.conformsTo(parameter->at(i).type) and\n\t\t\t    replyValue->at(i).isOrdered =\n\t\t\t    parameter->at(i).isOrdered and\n\t\t\t    replyValue->at(i)\n\t\t\t    .compatibleWith(parameter->at(i)))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 16,
          "OperationCallExpImpl": 18,
          "LetExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "UML::MultiplicityElement::isOrdered",
          "UML::CallEvent::operation",
          "UML::ReplyAction::replyToCall",
          "UML::ReplyAction::replyValue",
          "UML::Trigger::event",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "FunctionBehavior",
    "expressions": [
      {
        "operations": {
          "or": 2,
          "size": 1,
          "=": 3,
          ">=": 1
        },
        "name": "one_output_parameter",
        "body": "\n\t\t\tself.ownedParameter->select(p |\n\t\t\t  (p.direction = ParameterDirectionKind::out or p.direction = ParameterDirectionKind::inout or p.direction = ParameterDirectionKind::return\n\t\t\t  ))\n\t\t\t->size() >= 1\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 7,
          "VariableExpImpl": 4,
          "EnumLiteralExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Behavior::ownedParameter",
          "UML::Parameter::direction"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "oclIsTypeOf": 1,
          "and": 2,
          "oclAsType": 1,
          "hasAllDataTypeAttributes": 1
        },
        "name": "types_of_parameters",
        "body": "\n\t\t\townedParameter->forAll(p | p.type <> null and\n\t\t\t  p.type.oclIsTypeOf(DataType) and\n\t\t\t  hasAllDataTypeAttributes(\n\t\t\t    p.type.oclAsType(DataType)))\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Behavior::ownedParameter",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "StateMachine",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "isEmpty": 1,
          "implies": 1
        },
        "name": "method",
        "body": "\n\t\t\tspecification <> null implies connectionPoint->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "UML::StateMachine::connectionPoint",
          "UML::Behavior::specification"
        ]
      },
      {
        "operations": {
          "or": 1,
          "=": 2
        },
        "name": "connection_points",
        "body": "\n\t\t\tconnectionPoint->forAll(kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "EnumLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::Pseudostate::kind",
          "UML::StateMachine::connectionPoint"
        ]
      },
      {
        "operations": {
          "<>": 2,
          "and": 1,
          "oclAsSet": 1,
          "implies": 1,
          "=": 1
        },
        "name": "context_classifier",
        "body": "\n\t\t\tspecification <> null implies _'context' <> null and\n\t\t\tspecification.featuringClassifier->exists(c | c = _'context')\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 5,
          "NullLiteralExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::Behavior::context",
          "UML::Feature::featuringClassifier",
          "UML::Behavior::specification"
        ]
      },
      {
        "operations": {
          "not": 1,
          "<>": 1,
          "oclIsKindOf": 1,
          "implies": 1
        },
        "name": "classifier_context",
        "body": "\n\t\t\t_'context' <> null implies\n\t\t\tnot _'context'.oclIsKindOf(Interface)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": ["UML::Behavior::context"]
      }
    ],
    "properties": []
  },
  {
    "name": "ValuePin",
    "expressions": [
      {
        "operations": {"isEmpty": 1},
        "name": "no_incoming_edges",
        "body": "\n\t\t\tincoming->isEmpty()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["UML::ActivityNode::incoming"]
      },
      {
        "operations": {"conformsTo": 1},
        "name": "compatible_type",
        "body": "\n\t\t\tvalue.type.conformsTo(type)\n\n\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "UML::ValuePin::value",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "StructuredActivityNode",
    "expressions": [
      {
        "operations": {
          "excludesAll": 1,
          "allOwnedNodes": 1,
          "-": 1
        },
        "name": "input_pin_edges",
        "body": "\n\t\t\tinput.incoming.source->excludesAll(allOwnedNodes() - output)\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::ActivityEdge::source",
          "UML::Action::input",
          "UML::ActivityNode::incoming",
          "UML::Action::output"
        ]
      },
      {
        "operations": {
          "sourceNodes": 1,
          "intersection": 2,
          "union": 1,
          "allOwnedNodes": 2,
          "asSet": 1,
          "=": 1,
          "targetNodes": 1
        },
        "name": "edges",
        "body": "\n\t\t\tedge =\n\t\t\tself.sourceNodes()\n\t\t\t.outgoing->intersection(self.allOwnedNodes().incoming)\n\t\t\t->union(\n\t\t\t  self.targetNodes()\n\t\t\t  .incoming->intersection(self.allOwnedNodes().outgoing))\n\t\t\t->asSet()\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 9,
          "OperationCallExpImpl": 9,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "UML::ActivityNode::outgoing",
          "UML::ActivityNode::incoming",
          "UML::StructuredActivityNode::edge"
        ]
      },
      {
        "operations": {
          "excludesAll": 1,
          "allOwnedNodes": 1,
          "-": 1
        },
        "name": "output_pin_edges",
        "body": "\n\t\t\toutput.outgoing.target->excludesAll(allOwnedNodes() - input)\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 3,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Action::input",
          "UML::ActivityNode::outgoing",
          "UML::Action::output",
          "UML::ActivityEdge::target"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Interface",
    "expressions": [{
      "operations": {"=": 1},
      "name": "visibility",
      "body": "\n\t\t\tfeature->forAll(visibility = VisibilityKind::public)\n\t\n\t",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 1,
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "EnumLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "UML::Classifier::feature",
        "UML::NamedElement::visibility"
      ]
    }],
    "properties": []
  },
  {
    "name": "Message",
    "expressions": [
      {
        "operations": {
          "or": 2,
          "oclIsKindOf": 2,
          "isEmpty": 1,
          "oclAsType": 5,
          "not": 1,
          "at": 1,
          "size": 3,
          "and": 4,
          "oclAsSet": 1,
          "conformsTo": 1,
          "implies": 2,
          "=": 6,
          "indexOf": 1
        },
        "name": "signature_is_operation_request",
        "body": "\n\t\t\t(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall\n\t\t\t) and\n\t\t\tsignature.oclIsKindOf(Operation) implies\n\t\t\tlet\n\t\t\t  requestParms : OrderedSet(Parameter) = signature.oclAsType(Operation)\n\t\t\t  .ownedParameter->select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::_'in')\n\t\t\tin\n\t\t\t  requestParms->size() =\n\t\t\t  self.argument->size() and\n\t\t\t  self.argument->forAll(o |\n\t\t\t    (\n\t\t\t      not (\n\t\t\t        o.oclIsKindOf(Expression) and\n\t\t\t        o.oclAsType(Expression)\n\t\t\t        .symbol->size() = 0 and\n\t\t\t        o.oclAsType(Expression)\n\t\t\t        .operand->isEmpty()\n\t\t\t      ) implies\n\t\t\t      let\n\t\t\t        p : Parameter = requestParms->at(\n\t\t\t          self.argument->indexOf(o))\n\t\t\t      in\n\t\t\t        o.type.oclAsType(Classifier)\n\t\t\t        .conformsTo(\n\t\t\t          p.type.oclAsType(Classifier))\n\t\t\t    ))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 30,
          "VariableExpImpl": 17,
          "LetExpImpl": 2,
          "EnumLiteralExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 7,
          "PropertyCallExpImpl": 14
        },
        "properties": [
          "UML::Expression::operand",
          "UML::Expression::symbol",
          "UML::Message::signature",
          "UML::Message::argument",
          "UML::Message::messageSort",
          "UML::Parameter::direction",
          "UML::Operation::ownedParameter",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "enclosingFragment": 2,
          "and": 1,
          "asOrderedSet": 2,
          "oclAsSet": 4,
          "notEmpty": 2,
          "implies": 1,
          "=": 1,
          "first": 2
        },
        "name": "cannot_cross_boundaries",
        "body": "\n\t\t\tsendEvent->notEmpty() and\n\t\t\treceiveEvent->notEmpty() implies\n\t\t\tlet\n\t\t\t  sendEnclosingFrag : Set(InteractionFragment) = sendEvent->asOrderedSet()\n\t\t\t  ->first()\n\t\t\t  .enclosingFragment()\n\t\t\tin\n\t\t\t  let\n\t\t\t    receiveEnclosingFrag : Set(InteractionFragment) = receiveEvent->asOrderedSet()\n\t\t\t    ->first()\n\t\t\t    .enclosingFragment()\n\t\t\t  in sendEnclosingFrag = receiveEnclosingFrag\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 15,
          "VariableExpImpl": 6,
          "LetExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "UML::Message::sendEvent",
          "UML::Message::receiveEvent"
        ]
      },
      {
        "operations": {},
        "name": "occurrence_specifications",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "oclIsKindOf": 3,
          "asOrderedSet": 4,
          "oclAsSet": 4,
          "implies": 2,
          "<": 1,
          "oclAsType": 4,
          "indexOf": 2,
          "=": 1,
          "first": 4
        },
        "name": "sending_receiving_message_event",
        "body": "\n\t\t\treceiveEvent.oclIsKindOf(MessageOccurrenceSpecification) implies\n\t\t\tlet\n\t\t\t  f : Lifeline = sendEvent->select(\n\t\t\t    oclIsKindOf(MessageOccurrenceSpecification))\n\t\t\t  .oclAsType(MessageOccurrenceSpecification)\n\t\t\t  ->asOrderedSet()\n\t\t\t  ->first().covered\n\t\t\tin f =\n\t\t\t  receiveEvent->select(\n\t\t\t    oclIsKindOf(MessageOccurrenceSpecification))\n\t\t\t  .oclAsType(MessageOccurrenceSpecification)\n\t\t\t  ->asOrderedSet()\n\t\t\t  ->first().covered implies\n\t\t\t  f.events->indexOf(\n\t\t\t    sendEvent.oclAsType(MessageOccurrenceSpecification)\n\t\t\t    ->asOrderedSet()\n\t\t\t    ->first()) <\n\t\t\t  f.events->indexOf(\n\t\t\t    receiveEvent.oclAsType(MessageOccurrenceSpecification)\n\t\t\t    ->asOrderedSet()\n\t\t\t    ->first())\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 4,
          "VariableExpImpl": 12,
          "OperationCallExpImpl": 25,
          "LetExpImpl": 1,
          "OppositePropertyCallExpImpl": 2,
          "TypeExpImpl": 7,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "UML::OccurrenceSpecification::covered",
          "UML::Message::sendEvent",
          "UML::Message::receiveEvent"
        ]
      },
      {
        "operations": {},
        "name": "arguments",
        "body": "\n\t\t\tnull\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "or": 2,
          "oclIsKindOf": 2,
          "oclAsType": 4,
          "asSequence": 1,
          "at": 1,
          "size": 2,
          "and": 3,
          "conformsTo": 1,
          "implies": 2,
          "notEmpty": 1,
          "=": 5,
          "indexOf": 1,
          "first": 1
        },
        "name": "signature_is_operation_reply",
        "body": "\n\t\t\tmessageSort = MessageSort::reply and\n\t\t\tsignature.oclIsKindOf(Operation) implies\n\t\t\tlet\n\t\t\t  replyParms : OrderedSet(Parameter) = signature.oclAsType(Operation)\n\t\t\t  .ownedParameter->select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::return)\n\t\t\tin\n\t\t\t  replyParms->size() =\n\t\t\t  self.argument->size() and\n\t\t\t  self.argument->forAll(o |\n\t\t\t    o.oclIsKindOf(Expression) and\n\t\t\t    let\n\t\t\t      e : Expression = o.oclAsType(Expression)\n\t\t\t    in\n\t\t\t      (\n\t\t\t        e.operand->notEmpty() implies\n\t\t\t        let\n\t\t\t          p : Parameter = replyParms->at(\n\t\t\t            self.argument->indexOf(o))\n\t\t\t        in\n\t\t\t          e.operand->asSequence()\n\t\t\t          ->first()\n\t\t\t          .type.oclAsType(Classifier)\n\t\t\t          .conformsTo(\n\t\t\t            p.type.oclAsType(Classifier))\n\t\t\t      ))\n\t\n\t\n\t\n\t\n\t\n\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "OperationCallExpImpl": 26,
          "VariableExpImpl": 17,
          "LetExpImpl": 3,
          "EnumLiteralExpImpl": 4,
          "TypeExpImpl": 6,
          "PropertyCallExpImpl": 14
        },
        "properties": [
          "UML::Expression::operand",
          "UML::Message::signature",
          "UML::Message::argument",
          "UML::Message::messageSort",
          "UML::Parameter::direction",
          "UML::Operation::ownedParameter",
          "UML::TypedElement::type"
        ]
      },
      {
        "operations": {
          "or": 3,
          "oclIsKindOf": 2,
          "and": 3,
          "oclAsSet": 1,
          "implies": 1,
          "notEmpty": 1,
          "=": 5
        },
        "name": "signature_refer_to",
        "body": "\n\t\t\tsignature->notEmpty() implies\n\t\t\t(\n\t\t\t  signature.oclIsKindOf(Operation) and\n\t\t\t  (messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall or messageSort = MessageSort::reply\n\t\t\t  ) or\n\t\t\t  signature.oclIsKindOf(Signal) and messageSort = MessageSort::asynchSignal\n\t\t\t) and name = signature.name\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 16,
          "VariableExpImpl": 9,
          "EnumLiteralExpImpl": 4,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::Message::signature",
          "UML::Message::messageSort",
          "UML::NamedElement::name"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 2,
          "asOrderedSet": 1,
          "isEmpty": 1,
          "oclAsType": 6,
          "not": 1,
          "at": 1,
          "size": 3,
          "oclIsTypeOf": 1,
          "inheritedMember": 1,
          "and": 4,
          "oclAsSet": 1,
          "conformsTo": 1,
          "implies": 2,
          "=": 3,
          "indexOf": 1
        },
        "name": "signature_is_signal",
        "body": "\n\t\t\tmessageSort = MessageSort::asynchSignal and\n\t\t\tsignature.oclIsKindOf(Signal) implies\n\t\t\tlet\n\t\t\t  signalAttributes : OrderedSet(Property) = signature.oclAsType(Signal)\n\t\t\t  .inheritedMember()\n\t\t\t  ->select(n |\n\t\t\t    n.oclIsTypeOf(Property))\n\t\t\t  ->collect(oclAsType(Property))\n\t\t\t  ->asOrderedSet()\n\t\t\tin\n\t\t\t  signalAttributes->size() =\n\t\t\t  self.argument->size() and\n\t\t\t  self.argument->forAll(o |\n\t\t\t    (\n\t\t\t      not (\n\t\t\t        o.oclIsKindOf(Expression) and\n\t\t\t        o.oclAsType(Expression)\n\t\t\t        .symbol->size() = 0 and\n\t\t\t        o.oclAsType(Expression)\n\t\t\t        .operand->isEmpty()\n\t\t\t      ) implies\n\t\t\t      let\n\t\t\t        p : Property = signalAttributes->at(\n\t\t\t          self.argument->indexOf(o))\n\t\t\t      in\n\t\t\t        o.type.oclAsType(Classifier)\n\t\t\t        .conformsTo(\n\t\t\t          p.type.oclAsType(Classifier))\n\t\t\t    ))\n\t\n\t\t",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 3,
          "OperationCallExpImpl": 29,
          "VariableExpImpl": 16,
          "LetExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 9,
          "PropertyCallExpImpl": 10
        },
        "properties": [
          "UML::Expression::operand",
          "UML::Expression::symbol",
          "UML::Message::signature",
          "UML::Message::argument",
          "UML::Message::messageSort",
          "UML::TypedElement::type"
        ]
      }
    ],
    "properties": []
  }
]
