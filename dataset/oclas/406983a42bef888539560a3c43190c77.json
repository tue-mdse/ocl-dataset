[
  {
    "name": "Operation",
    "expressions": [
      {
        "operations": {},
        "name": "LoadableImplementation",
        "body": "\n\ttrue\n",
        "type": "ConstraintImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "UniquePostconditionName",
        "body": "postcondition->isUnique(name)\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::Operation::postcondition"
        ]
      },
      {
        "operations": {},
        "name": "UniquePreconditionName",
        "body": "precondition->isUnique(name)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::Operation::precondition"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "implies": 1,
          "CompatibleBody": 1
        },
        "name": "CompatibleReturn",
        "body": "bodyExpression <> null and bodyExpression.oclIsKindOf(ExpressionInOCL) implies CompatibleBody(bodyExpression)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": ["pivot::Operation::bodyExpression"]
      }
    ],
    "properties": [
      "MessageType",
      "redefinedOperation",
      "precondition",
      "owningType",
      "raisedException",
      "isValidating",
      "CallOperationAction",
      "Operation",
      "isInvalidating",
      "class",
      "ownedParameter",
      "OperationCallExp",
      "postcondition",
      "bodyExpression",
      "templateParameter",
      "precedence"
    ]
  },
  {
    "name": "Annotation",
    "expressions": [],
    "properties": [
      "ownedContent",
      "reference",
      "ownedDetail",
      "NamedElement"
    ]
  },
  {
    "name": "ReferringElement",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Vertex",
    "expressions": [],
    "properties": [
      "outgoing",
      "incoming",
      "container"
    ]
  },
  {
    "name": "Namespace",
    "expressions": [],
    "properties": [
      "Constraint",
      "ownedRule",
      "Import"
    ]
  },
  {
    "name": "MessageExp",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "oclIsKindOf": 1
        },
        "name": "TargetIsNotACollection",
        "body": "not target.type.oclIsKindOf (CollectionType)\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::MessageExp::target",
          "pivot::TypedElement::type"
        ]
      },
      {
        "operations": {
          "size": 2,
          "oclAsSet": 2,
          "+": 1,
          "=": 1
        },
        "name": "OneCallOrOneSend",
        "body": "calledOperation->size() + sentSignal->size() = 1\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 6,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::MessageExp::calledOperation",
          "pivot::MessageExp::sentSignal"
        ]
      }
    ],
    "properties": [
      "calledOperation",
      "target",
      "argument",
      "sentSignal"
    ]
  },
  {
    "name": "Constraint",
    "expressions": [{
      "operations": {},
      "name": "UniqueName",
      "body": "true ",
      "type": "ConstraintImpl",
      "constructs": {"BooleanLiteralExpImpl": 1},
      "properties": []
    }],
    "properties": [
      "context",
      "isCallable",
      "Operation",
      "Transition",
      "Type",
      "specification",
      "State",
      "constrainedElement",
      "Namespace",
      "Operation"
    ]
  },
  {
    "name": "PropertyCallExp",
    "expressions": [
      {
        "operations": {},
        "name": "getSpecializedReferredPropertyOwningType",
        "body": "referredProperty.owningType ",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::PropertyCallExp::referredProperty",
          "pivot::Property::owningType"
        ]
      },
      {
        "operations": {},
        "name": "getSpecializedReferredPropertyType",
        "body": "referredProperty.type ",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::PropertyCallExp::referredProperty",
          "pivot::TypedElement::type"
        ]
      },
      {
        "operations": {
          "getSpecializedReferredPropertyType": 1,
          "=": 1
        },
        "name": "CompatibleResultType",
        "body": "type = getSpecializedReferredPropertyType()\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 2,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["pivot::TypedElement::type"]
      },
      {
        "operations": {
          "not": 1,
          "oclBadOperation": 1,
          "implies": 1
        },
        "name": "NonStaticSourceTypeIsConformant",
        "body": "not referredProperty.isStatic implies source.type.conformsTo(getSpecializedReferredPropertyOwningType())",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "pivot::Feature::isStatic",
          "pivot::PropertyCallExp::referredProperty",
          "pivot::TypedElement::type",
          "pivot::CallExp::source"
        ]
      }
    ],
    "properties": ["referredProperty"]
  },
  {
    "name": "DynamicElement",
    "expressions": [],
    "properties": ["metaType"]
  },
  {
    "name": "LambdaType",
    "expressions": [],
    "properties": [
      "parameterType",
      "contextType",
      "resultType"
    ]
  },
  {
    "name": "Parameter",
    "expressions": [],
    "properties": [
      "Iteration",
      "Iteration",
      "Variable",
      "operation"
    ]
  },
  {
    "name": "StateMachine",
    "expressions": [],
    "properties": [
      "region",
      "Pseudostate",
      "StateMachine",
      "submachineState",
      "Region",
      "connectionPoint",
      "extendedStateMachine"
    ]
  },
  {
    "name": "AssociativityKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "DynamicType",
    "expressions": [],
    "properties": [
      "ownedProperty",
      "metaType"
    ]
  },
  {
    "name": "BagType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "CollectionRange",
    "expressions": [],
    "properties": [
      "first",
      "last"
    ]
  },
  {
    "name": "SequenceType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "IfExp",
    "expressions": [{
      "operations": {"=": 1},
      "name": "ConditionTypeIsBoolean",
      "body": "self.condition.type = Boolean\n\n",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 1,
        "OperationCallExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "pivot::TypedElement::type",
        "pivot::IfExp::condition"
      ]
    }],
    "properties": [
      "elseExpression",
      "condition",
      "thenExpression"
    ]
  },
  {
    "name": "NumericLiteralExp",
    "expressions": [],
    "properties": []
  },
  {
    "name": "SelfType",
    "expressions": [{
      "operations": {},
      "name": "specializeIn",
      "body": "selfType\n\n",
      "type": "OperationImpl",
      "constructs": {"VariableExpImpl": 1},
      "properties": []
    }],
    "properties": []
  },
  {
    "name": "Stereotype",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Integer",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Library",
    "expressions": [],
    "properties": ["ownedPrecedence"]
  },
  {
    "name": "MessageType",
    "expressions": [],
    "properties": [
      "referredOperation",
      "referredSignal"
    ]
  },
  {
    "name": "TypeExp",
    "expressions": [],
    "properties": ["referredType"]
  },
  {
    "name": "Signal",
    "expressions": [],
    "properties": [
      "SendSignalAction",
      "MessageType"
    ]
  },
  {
    "name": "CollectionType",
    "expressions": [],
    "properties": [
      "elementType",
      "upper",
      "lower"
    ]
  },
  {
    "name": "TemplateableElement",
    "expressions": [],
    "properties": [
      "templateBinding",
      "unspecializedElement",
      "ownedTemplateSignature"
    ]
  },
  {
    "name": "Boolean",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Package",
    "expressions": [],
    "properties": [
      "nestingPackage",
      "nsURI",
      "nsPrefix",
      "Package",
      "nestedPackage",
      "importedPackage",
      "Root",
      "ownedType"
    ]
  },
  {
    "name": "Transition",
    "expressions": [],
    "properties": [
      "kind",
      "target",
      "effect",
      "container",
      "trigger",
      "source",
      "guard"
    ]
  },
  {
    "name": "ElementExtension",
    "expressions": [],
    "properties": [
      "stereotype",
      "base"
    ]
  },
  {
    "name": "MorePivotable",
    "expressions": [],
    "properties": []
  },
  {
    "name": "PackageableElement",
    "expressions": [],
    "properties": []
  },
  {
    "name": "CollectionKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "NullLiteralExp",
    "expressions": [],
    "properties": []
  },
  {
    "name": "UnspecifiedValueExp",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ConstructorPart",
    "expressions": [],
    "properties": [
      "initExpression",
      "referredProperty",
      "ConstructorExp"
    ]
  },
  {
    "name": "DynamicProperty",
    "expressions": [],
    "properties": [
      "referredProperty",
      "default",
      "DynamicType"
    ]
  },
  {
    "name": "OCLExpression",
    "expressions": [],
    "properties": [
      "IfExp",
      "ConstructorPart",
      "CollectionRange",
      "ExpressionInOCL",
      "LoopExp",
      "TupleLiteralPart",
      "NavigationCallExp",
      "IfExp",
      "IfExp",
      "Variable",
      "CollectionRange",
      "MessageExp",
      "LetExp",
      "CallExp",
      "OperationCallExp",
      "MessageExp",
      "ExpressionInOCL",
      "CollectionItem"
    ]
  },
  {
    "name": "StateExp",
    "expressions": [],
    "properties": ["referredState"]
  },
  {
    "name": "VariableExp",
    "expressions": [],
    "properties": [
      "implicit",
      "referredVariable"
    ]
  },
  {
    "name": "FeatureCallExp",
    "expressions": [],
    "properties": ["isPre"]
  },
  {
    "name": "AssociationClassCallExp",
    "expressions": [],
    "properties": ["referredAssociationClass"]
  },
  {
    "name": "OpaqueExpression",
    "expressions": [],
    "properties": [
      "Property",
      "message",
      "language",
      "Operation",
      "body",
      "Constraint"
    ]
  },
  {
    "name": "TupleLiteralExp",
    "expressions": [],
    "properties": ["part"]
  },
  {
    "name": "String",
    "expressions": [],
    "properties": []
  },
  {
    "name": "InvalidType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "LetExp",
    "expressions": [{
      "operations": {"=": 1},
      "name": "TypeIsInType",
      "body": "type = _'in'.type\n\n",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "pivot::TypedElement::type",
        "pivot::LetExp::in"
      ]
    }],
    "properties": [
      "variable",
      "in"
    ]
  },
  {
    "name": "Nameable",
    "expressions": [],
    "properties": []
  },
  {
    "name": "AnyType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "OperationTemplateParameter",
    "expressions": [],
    "properties": ["parameteredElement"]
  },
  {
    "name": "TupleLiteralPart",
    "expressions": [],
    "properties": [
      "TupleLiteralExp",
      "initExpression"
    ]
  },
  {
    "name": "UnspecifiedType",
    "expressions": [],
    "properties": [
      "upperBound",
      "lowerBound"
    ]
  },
  {
    "name": "Detail",
    "expressions": [],
    "properties": [
      "Annotation",
      "value"
    ]
  },
  {
    "name": "ConnectionPointReference",
    "expressions": [],
    "properties": [
      "exit",
      "entry",
      "state",
      "State"
    ]
  },
  {
    "name": "Import",
    "expressions": [],
    "properties": [
      "importedNamespace",
      "Root"
    ]
  },
  {
    "name": "TemplateParameterType",
    "expressions": [],
    "properties": ["specification"]
  },
  {
    "name": "Precedence",
    "expressions": [],
    "properties": [
      "associativity",
      "order",
      "Library",
      "Operation"
    ]
  },
  {
    "name": "VoidType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "NavigationCallExp",
    "expressions": [],
    "properties": [
      "qualifier",
      "navigationSource"
    ]
  },
  {
    "name": "State",
    "expressions": [],
    "properties": [
      "submachine",
      "Region",
      "deferrableTrigger",
      "region",
      "ConnectionPointReference",
      "exit",
      "isOrthogonal",
      "Pseudostate",
      "doActivity",
      "connectionPoint",
      "connection",
      "StateExp",
      "isComposite",
      "isSubmachineState",
      "stateInvariant",
      "State",
      "entry",
      "redefinedState",
      "isSimple"
    ]
  },
  {
    "name": "RealLiteralExp",
    "expressions": [],
    "properties": ["realSymbol"]
  },
  {
    "name": "ConstructorExp",
    "expressions": [],
    "properties": [
      "part",
      "value"
    ]
  },
  {
    "name": "Property",
    "expressions": [
      {
        "operations": {
          "<>": 1,
          "oclIsKindOf": 1,
          "and": 1,
          "implies": 1,
          "CompatibleBody": 1
        },
        "name": "CompatibleDefaultExpression",
        "body": "defaultExpression <> null and defaultExpression.oclIsKindOf(ExpressionInOCL) implies CompatibleBody(defaultExpression)\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 4,
          "NullLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": ["pivot::Property::defaultExpression"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "and": 1,
          "includes": 1,
          "oclAsType": 1,
          "oclContainer": 1
        },
        "name": "isAttribute",
        "body": "\n--Type.allInstances()->exists(c| c.ownedAttribute->includes(p))\nlet container : ocl::OclElement = oclContainer() in container.oclIsKindOf(Type) and container.oclAsType(Type).ownedAttribute->includes(self)\n\n",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5,
          "LetExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 1
        },
        "properties": ["pivot::Type::ownedAttribute"]
      }
    ],
    "properties": [
      "isResolveProxies",
      "Property",
      "default",
      "Property",
      "class",
      "implicit",
      "isReadOnly",
      "NavigationCallExp",
      "referredProperty",
      "ConstructorPart",
      "owningType",
      "association",
      "isID",
      "isVolatile",
      "isDerived",
      "Property",
      "defaultExpression",
      "PropertyCallExp",
      "redefinedProperty",
      "isTransient",
      "Property",
      "isUnsettable",
      "opposite",
      "keys",
      "subsettedProperty",
      "DynamicProperty",
      "Property",
      "isComposite"
    ]
  },
  {
    "name": "Variable",
    "expressions": [],
    "properties": [
      "ExpressionInOCL",
      "IterateExp",
      "LoopExp",
      "LetExp",
      "initExpression",
      "ExpressionInOCL",
      "representedParameter",
      "implicit",
      "ExpressionInOCL"
    ]
  },
  {
    "name": "Type",
    "expressions": [
      {
        "operations": {},
        "name": "specializeIn",
        "body": "self\n\n",
        "type": "OperationImpl",
        "constructs": {"VariableExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "UniqueInvariantName",
        "body": "ownedInvariant->isUnique(name)\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::Type::ownedInvariant"
        ]
      }
    ],
    "properties": [
      "ownedOperation",
      "templateParameter",
      "package",
      "ownedAttribute",
      "DataType",
      "instanceClassName",
      "DynamicElement",
      "Metaclass",
      "LambdaType",
      "ownedInvariant",
      "ElementExtension",
      "superClass",
      "TypeTemplateParameter",
      "LambdaType",
      "Type",
      "CollectionType",
      "LambdaType",
      "UnspecifiedType",
      "UnspecifiedType",
      "Operation",
      "TypedElement",
      "TypeExp"
    ]
  },
  {
    "name": "EnumLiteralExp",
    "expressions": [{
      "operations": {"=": 1},
      "name": "TypeIsEnumerationType",
      "body": "self.type = referredEnumLiteral.enumeration\n\n",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "pivot::TypedElement::type",
        "pivot::EnumerationLiteral::enumeration",
        "pivot::EnumLiteralExp::referredEnumLiteral"
      ]
    }],
    "properties": ["referredEnumLiteral"]
  },
  {
    "name": "NamedElement",
    "expressions": [],
    "properties": [
      "ownedAnnotation",
      "name",
      "isStatic"
    ]
  },
  {
    "name": "ParameterableElement",
    "expressions": [{
      "operations": {
        "oclIsKindOf": 1,
        "oclType": 1
      },
      "name": "isCompatibleWith",
      "body": "\np.oclIsKindOf(self.oclType())\n\n",
      "type": "OperationImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 2
      },
      "properties": []
    }],
    "properties": [
      "templateParameter",
      "TemplateParameterSubstitution",
      "owningTemplateParameter",
      "TemplateParameter",
      "TemplateParameterSubstitution",
      "TemplateParameter"
    ]
  },
  {
    "name": "TupleType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "CollectionLiteralExp",
    "expressions": [
      {
        "operations": {"<>": 1},
        "name": "CollectionKindIsConcrete",
        "body": "kind <> CollectionKind::Collection\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["pivot::CollectionLiteralExp::kind"]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "implies": 1,
          "=": 1
        },
        "name": "SetKindIsSet",
        "body": "kind = CollectionKind::Set implies type.oclIsKindOf (SetType)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::CollectionLiteralExp::kind",
          "pivot::TypedElement::type"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "implies": 1,
          "=": 1
        },
        "name": "OrderedSetKindIsOrderedSet",
        "body": "kind = CollectionKind::OrderedSet implies type.oclIsKindOf (OrderedSetType)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::CollectionLiteralExp::kind",
          "pivot::TypedElement::type"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "implies": 1,
          "=": 1
        },
        "name": "BagKindIsBag",
        "body": "kind = CollectionKind::Bag implies type.oclIsKindOf (BagType)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::CollectionLiteralExp::kind",
          "pivot::TypedElement::type"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "implies": 1,
          "=": 1
        },
        "name": "SequenceKindIsSequence",
        "body": "kind = CollectionKind::Sequence implies type.oclIsKindOf (SequenceType)\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::CollectionLiteralExp::kind",
          "pivot::TypedElement::type"
        ]
      }
    ],
    "properties": [
      "kind",
      "part"
    ]
  },
  {
    "name": "EnumerationLiteral",
    "expressions": [],
    "properties": [
      "value",
      "enumeration",
      "EnumLiteralExp"
    ]
  },
  {
    "name": "CallOperationAction",
    "expressions": [],
    "properties": [
      "MessageExp",
      "operation"
    ]
  },
  {
    "name": "Feature",
    "expressions": [],
    "properties": [
      "isStatic",
      "implementationClass",
      "implementation"
    ]
  },
  {
    "name": "FinalState",
    "expressions": [],
    "properties": []
  },
  {
    "name": "LiteralExp",
    "expressions": [],
    "properties": []
  },
  {
    "name": "TransitionKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "AssociationClass",
    "expressions": [],
    "properties": [
      "unownedAttribute",
      "AssociationClassCallExp"
    ]
  },
  {
    "name": "TypedElement",
    "expressions": [],
    "properties": [
      "type",
      "isRequired"
    ]
  },
  {
    "name": "Visitable",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Pseudostate",
    "expressions": [],
    "properties": [
      "ConnectionPointReference",
      "kind",
      "stateMachine",
      "StateMachine",
      "State",
      "state",
      "ConnectionPointReference"
    ]
  },
  {
    "name": "SetType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "UnlimitedNaturalLiteralExp",
    "expressions": [],
    "properties": ["unlimitedNaturalSymbol"]
  },
  {
    "name": "ValueSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ExpressionInOCL",
    "expressions": [],
    "properties": [
      "messageExpression",
      "bodyExpression",
      "resultVariable",
      "contextVariable",
      "parameterVariable"
    ]
  },
  {
    "name": "DataType",
    "expressions": [],
    "properties": [
      "isSerializable",
      "behavioralType"
    ]
  },
  {
    "name": "Metaclass",
    "expressions": [],
    "properties": ["instanceType"]
  },
  {
    "name": "TypedMultiplicityElement",
    "expressions": [
      {
        "operations": {},
        "name": "makeParameter",
        "body": "Parameter{name='name'}\n\n",
        "type": "OperationImpl",
        "constructs": {
          "StringLiteralExpImpl": 1,
          "ShadowExpImpl": 1
        },
        "properties": []
      },
      {
        "operations": {"oclBadOperation": 1},
        "name": "CompatibleBody",
        "body": "\n\tbodySpecification.type.conformsTo(self.type)",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 1
        },
        "properties": ["pivot::TypedElement::type"]
      }
    ],
    "properties": []
  },
  {
    "name": "Object",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Root",
    "expressions": [],
    "properties": [
      "externalURI",
      "nestedPackage",
      "imports"
    ]
  },
  {
    "name": "PrimitiveLiteralExp",
    "expressions": [],
    "properties": []
  },
  {
    "name": "LoopExp",
    "expressions": [
      {
        "operations": {"oclIsKindOf": 1},
        "name": "SourceIsCollection",
        "body": "source.type.oclIsKindOf (CollectionType)\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CallExp::source"
        ]
      },
      {
        "operations": {
          "isEmpty": 1,
          "oclAsSet": 1
        },
        "name": "NoInitializers",
        "body": "self.iterator->forAll(initExpression->isEmpty())\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::Variable::initExpression",
          "pivot::LoopExp::iterator"
        ]
      }
    ],
    "properties": [
      "referredIteration",
      "iterator",
      "body"
    ]
  },
  {
    "name": "Throwable",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Real",
    "expressions": [],
    "properties": []
  },
  {
    "name": "PrimitiveType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Enumeration",
    "expressions": [],
    "properties": ["ownedLiteral"]
  },
  {
    "name": "Behavior",
    "expressions": [],
    "properties": [
      "State",
      "State",
      "Class",
      "Transition",
      "State"
    ]
  },
  {
    "name": "CallExp",
    "expressions": [],
    "properties": [
      "source",
      "implicit"
    ]
  },
  {
    "name": "IterateExp",
    "expressions": [
      {
        "operations": {"oclBadOperation": 1},
        "name": "BodyTypeConformsToResultType",
        "body": "_'body'.type.conformsTo(result.type)",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::LoopExp::body"
        ]
      },
      {
        "operations": {
          "size": 1,
          "oclAsSet": 1,
          "=": 1
        },
        "name": "OneInitializer",
        "body": "self.result.initExpression->size() = 1\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::IterateExp::result",
          "pivot::Variable::initExpression"
        ]
      },
      {
        "operations": {"=": 1},
        "name": "TypeIsResultType",
        "body": "type = result.type\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "pivot::IterateExp::result",
          "pivot::TypedElement::type"
        ]
      }
    ],
    "properties": ["result"]
  },
  {
    "name": "TemplateParameterSubstitution",
    "expressions": [],
    "properties": [
      "actual",
      "ownedActual",
      "formal",
      "templateBinding"
    ]
  },
  {
    "name": "Profile",
    "expressions": [],
    "properties": []
  },
  {
    "name": "SendSignalAction",
    "expressions": [],
    "properties": [
      "signal",
      "MessageExp"
    ]
  },
  {
    "name": "OperationCallExp",
    "expressions": [
      {
        "operations": {
          "at": 2,
          "size": 1,
          "oclBadOperation": 1
        },
        "name": "ArgumentTypeIsConformant",
        "body": "\n\tlet operation : Operation = self.referredOperation in\n\tlet parameters : OrderedSet(Parameter) = operation.ownedParameter in\n\tlet selfType : Type = operation.owningType in\n\tSequence{1..argument->size()}->forAll (i | \n\t\tlet argument : OCLExpression = argument->at(i) in\n\t\tlet parameter : Parameter = parameters->at(i) in\n\t\tlet parameterType : Type = parameter.type in\n\t\targument.type.conformsTo(parameterType.specializeIn(self, selfType)))\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 10,
          "LetExpImpl": 6,
          "IntegerLiteralExpImpl": 1,
          "CollectionLiteralExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::Operation::ownedParameter",
          "pivot::OperationCallExp::argument",
          "pivot::OperationCallExp::referredOperation",
          "pivot::Operation::owningType"
        ]
      },
      {
        "operations": {
          "size": 2,
          "=": 1
        },
        "name": "ArgumentCount",
        "body": "argument->size() = referredOperation.ownedParameter->size()\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "pivot::OperationCallExp::argument",
          "pivot::OperationCallExp::referredOperation",
          "pivot::Operation::ownedParameter"
        ]
      }
    ],
    "properties": [
      "argument",
      "referredOperation"
    ]
  },
  {
    "name": "TemplateBinding",
    "expressions": [],
    "properties": [
      "parameterSubstitution",
      "signature",
      "boundElement"
    ]
  },
  {
    "name": "CollectionLiteralPart",
    "expressions": [],
    "properties": ["CollectionLiteralExp"]
  },
  {
    "name": "CollectionItem",
    "expressions": [{
      "operations": {"=": 1},
      "name": "TypeIsItemType",
      "body": "type = item.type\n\n",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 1,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "pivot::TypedElement::type",
        "pivot::CollectionItem::item"
      ]
    }],
    "properties": ["item"]
  },
  {
    "name": "Pivotable",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Comment",
    "expressions": [],
    "properties": [
      "Element",
      "body",
      "annotatedElement"
    ]
  },
  {
    "name": "IntegerLiteralExp",
    "expressions": [{
      "operations": {"=": 1},
      "name": "TypeIsInteger",
      "body": "self.type = Integer\n\n",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["pivot::TypedElement::type"]
    }],
    "properties": ["integerSymbol"]
  },
  {
    "name": "Element",
    "expressions": [
      {
        "operations": {},
        "name": "getValue",
        "body": "null\n\n",
        "type": "OperationImpl",
        "constructs": {"NullLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {"oclContents": 1},
        "name": "allOwnedElements",
        "body": "\n--self->closure(oclContents())\noclContents()\n\n",
        "type": "OperationImpl",
        "constructs": {
          "VariableExpImpl": 1,
          "OperationCallExpImpl": 1
        },
        "properties": []
      }
    ],
    "properties": [
      "ownedComment",
      "extension",
      "Annotation",
      "Annotation",
      "Constraint",
      "Comment"
    ]
  },
  {
    "name": "StringLiteralExp",
    "expressions": [],
    "properties": ["stringSymbol"]
  },
  {
    "name": "VariableDeclaration",
    "expressions": [],
    "properties": ["VariableExp"]
  },
  {
    "name": "OrderedSetType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Iteration",
    "expressions": [],
    "properties": [
      "ownedIterator",
      "ownedAccumulator",
      "LoopExp"
    ]
  },
  {
    "name": "IteratorExp",
    "expressions": [
      {
        "operations": {
          "oclBadOperation": 1,
          "oclAsType": 1
        },
        "name": "IteratorTypeIsSourceElementType",
        "body": "self.iterator->forAll(source.type.oclAsType (CollectionType).elementType.conformsTo(type))",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CallExp::source",
          "pivot::CollectionType::elementType",
          "pivot::LoopExp::iterator"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2
        },
        "name": "IsUniqueTypeIsBoolean",
        "body": "name = 'isUnique' implies type = Boolean\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2
        },
        "name": "AnyBodyTypeIsBoolean",
        "body": "name = 'any' implies _'body'.type = 'Boolean'\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "StringLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name",
          "pivot::LoopExp::body"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2,
          "oclAsType": 2
        },
        "name": "CollectElementTypeIsSourceElementType",
        "body": "name = 'collect' implies\ntype.oclAsType(CollectionType).elementType =\n_'body'.type.oclAsType(CollectionType).elementType\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "TypeExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CollectionType::elementType",
          "pivot::NamedElement::name",
          "pivot::LoopExp::body"
        ]
      },
      {
        "operations": {
          "or": 1,
          "implies": 1,
          "=": 3
        },
        "name": "RejectOrSelectTypeIsSourceType",
        "body": "name = 'reject' or name = 'select' implies type = source.type\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 5,
          "StringLiteralExpImpl": 2,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CallExp::source",
          "pivot::NamedElement::name"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2
        },
        "name": "OneBodyTypeIsBoolean",
        "body": "name = 'one' implies _'body'.type = Boolean\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name",
          "pivot::LoopExp::body"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "oclAsType": 2,
          "=": 2
        },
        "name": "ClosureElementTypeIsSourceElementType",
        "body": "name = 'closure' implies\ntype.oclAsType(CollectionType).elementType\n= source.type.oclAsType(CollectionType).elementType\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "TypeExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CallExp::source",
          "pivot::NamedElement::name",
          "pivot::CollectionType::elementType"
        ]
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 4,
          "implies": 1,
          "=": 1
        },
        "name": "CollectTypeIsUnordered",
        "body": "name = 'collect' implies\nif source.type.oclIsKindOf(SequenceType) or source.type.oclIsKindOf(OrderedSetType) then\ntype.oclIsKindOf(SequenceType)\nelse\ntype.oclIsKindOf(BagType)\nendif\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 7,
          "TypeExpImpl": 4,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CallExp::source",
          "pivot::NamedElement::name"
        ]
      },
      {
        "operations": {
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "CollectHasOneIterator",
        "body": "name = 'collect' implies iterator->size() = 1\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::LoopExp::iterator"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "implies": 1,
          "oclAsType": 2,
          "=": 2
        },
        "name": "ClosureSourceElementTypeIsBodyElementType",
        "body": "name = 'closure' implies\nsource.type.oclAsType(CollectionType).elementType =\nif _'body'.type.oclIsKindOf(CollectionType)\nthen _'body'.type.oclAsType(CollectionType).elementType\nelse _'body'.type\nendif\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 5,
          "TypeExpImpl": 3,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 11
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CallExp::source",
          "pivot::NamedElement::name",
          "pivot::CollectionType::elementType",
          "pivot::LoopExp::body"
        ]
      },
      {
        "operations": {
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "CollectNestedHasOneIterator",
        "body": "name = 'collectNested' implies iterator->size() = 1\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::LoopExp::iterator"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2
        },
        "name": "OneTypeIsBoolean",
        "body": "name = 'one' implies type = Boolean\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2,
          "oclAsType": 2
        },
        "name": "SortedByElementTypeIsSourceElementType",
        "body": "name = 'sortedBy' implies\ntype.oclAsType(CollectionType).elementType =\n_'body'.type.oclAsType(CollectionType).elementType\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CollectionType::elementType",
          "pivot::NamedElement::name",
          "pivot::LoopExp::body"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2,
          "oclAsType": 1
        },
        "name": "AnyTypeIsSourceElementType",
        "body": "name = 'any' implies type = source.type.oclAsType(CollectionType).elementType\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 5
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CallExp::source",
          "pivot::CollectionType::elementType",
          "pivot::NamedElement::name"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2
        },
        "name": "CollectNestedTypeIsBodyType",
        "body": "name = 'collectNested' implies type = _'body'.type\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 3,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name",
          "pivot::LoopExp::body"
        ]
      },
      {
        "operations": {
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "OneHasOneIterator",
        "body": "name = 'one' implies iterator->size() = 1\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::LoopExp::iterator"
        ]
      },
      {
        "operations": {
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "ClosureHasOneIterator",
        "body": "name = 'closure' implies iterator->size() = 1\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::LoopExp::iterator"
        ]
      },
      {
        "operations": {
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "SortedByHasOneIterator",
        "body": "name = 'sortedBy' implies iterator->size() = 1\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::LoopExp::iterator"
        ]
      },
      {
        "operations": {},
        "name": "SortedByIteratorTypeIsComparable",
        "body": "\n\ttrue\n\n",
        "type": "ConstraintImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "implies": 1,
          "=": 2
        },
        "name": "ForAllBodyTypeIsBoolean",
        "body": "name = 'forAll' implies _'body'.type = Boolean\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name",
          "pivot::LoopExp::body"
        ]
      },
      {
        "operations": {},
        "name": "ClosureBodyTypeIsConformanttoIteratorType",
        "body": "\n\ttrue\n",
        "type": "ConstraintImpl",
        "constructs": {"BooleanLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {
          "or": 1,
          "size": 1,
          "implies": 1,
          "=": 3
        },
        "name": "RejectOrSelectHasOneIterator",
        "body": "name = 'reject' or name = 'select' implies iterator->size() = 1\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 6,
          "VariableExpImpl": 3,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 2,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::LoopExp::iterator"
        ]
      },
      {
        "operations": {
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "IsUniqueHasOneIterator",
        "body": "name = 'isUnique' implies iterator->size() = 1\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 4,
          "VariableExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::LoopExp::iterator"
        ]
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 4,
          "implies": 1,
          "=": 1
        },
        "name": "SortedByIsOrderedIfSourceIsOrdered",
        "body": "name = 'sortedBy' implies\nif source.type.oclIsKindOf(SequenceType) or source.type.oclIsKindOf(BagType) then\ntype.oclIsKindOf(SequenceType)\nelse\ntype.oclIsKindOf(OrderedSetType)\nendif\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 7,
          "TypeExpImpl": 4,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CallExp::source",
          "pivot::NamedElement::name"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2
        },
        "name": "ExistsTypeIsBoolean",
        "body": "name = 'exists' implies type = Boolean\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name"
        ]
      },
      {
        "operations": {
          "oclIsKindOf": 1,
          "implies": 1,
          "=": 1
        },
        "name": "CollectNestedTypeIsBag",
        "body": "name = 'collectNested' implies type.oclIsKindOf(BagType)\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2
        },
        "name": "ForAllTypeIsBoolean",
        "body": "name = 'forAll' implies type = Boolean\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name"
        ]
      },
      {
        "operations": {
          "or": 1,
          "implies": 1,
          "=": 3
        },
        "name": "RejectOrSelectTypeIsBoolean",
        "body": "name = 'reject' or name = 'select' implies type = Boolean\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 5,
          "VariableExpImpl": 3,
          "StringLiteralExpImpl": 2,
          "TypeExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name"
        ]
      },
      {
        "operations": {
          "size": 1,
          "implies": 1,
          "=": 2
        },
        "name": "AnyHasOneIterator",
        "body": "name = 'any' implies iterator->size() = 1\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "pivot::NamedElement::name",
          "pivot::LoopExp::iterator"
        ]
      },
      {
        "operations": {
          "implies": 1,
          "=": 2
        },
        "name": "ExistsBodyTypeIsBoolean",
        "body": "name = 'exists' implies _'body'.type = Boolean\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::NamedElement::name",
          "pivot::LoopExp::body"
        ]
      },
      {
        "operations": {
          "or": 1,
          "oclIsKindOf": 4,
          "implies": 1,
          "=": 1
        },
        "name": "ClosureTypeIsUniqueCollection",
        "body": "name = 'closure' implies\nif source.type.oclIsKindOf(SequenceType) or source.type.oclIsKindOf(OrderedSetType) then\ntype.oclIsKindOf(OrderedSetType)\nelse\ntype.oclIsKindOf(SetType)\nendif\n\n",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 7,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 4,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 7
        },
        "properties": [
          "pivot::TypedElement::type",
          "pivot::CallExp::source",
          "pivot::NamedElement::name"
        ]
      }
    ],
    "properties": []
  },
  {
    "name": "Trigger",
    "expressions": [],
    "properties": [
      "Transition",
      "State"
    ]
  },
  {
    "name": "UnlimitedNatural",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Region",
    "expressions": [],
    "properties": [
      "state",
      "subvertex",
      "StateMachine",
      "extendedRegion",
      "Region",
      "stateMachine",
      "State",
      "transition"
    ]
  },
  {
    "name": "Visitor",
    "expressions": [],
    "properties": []
  },
  {
    "name": "PseudostateKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "LibraryFeature",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Class",
    "expressions": [],
    "properties": [
      "superClass",
      "isInterface",
      "instanceClassName",
      "ownedAttribute",
      "ownedOperation",
      "isAbstract",
      "ownedBehavior"
    ]
  },
  {
    "name": "TypeTemplateParameter",
    "expressions": [],
    "properties": [
      "parameteredElement",
      "constrainingType",
      "allowSubstitutable"
    ]
  },
  {
    "name": "TemplateParameter",
    "expressions": [],
    "properties": [
      "ownedDefault",
      "ownedParameteredElement",
      "TemplateParameterSubstitution",
      "default",
      "parameteredElement",
      "signature",
      "TemplateSignature"
    ]
  },
  {
    "name": "TemplateSignature",
    "expressions": [],
    "properties": [
      "TemplateBinding",
      "ownedParameter",
      "parameter",
      "template"
    ]
  },
  {
    "name": "BooleanLiteralExp",
    "expressions": [{
      "operations": {"=": 1},
      "name": "TypeIsBoolean",
      "body": "self.type = Boolean\n\n",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 1,
        "VariableExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 1
      },
      "properties": ["pivot::TypedElement::type"]
    }],
    "properties": ["booleanSymbol"]
  },
  {
    "name": "InvalidLiteralExp",
    "expressions": [],
    "properties": []
  }
]
