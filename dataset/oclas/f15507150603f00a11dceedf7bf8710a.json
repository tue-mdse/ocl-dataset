[
  {
    "name": "Association",
    "expressions": [],
    "properties": [
      "StructuralView",
      "ends"
    ]
  },
  {
    "name": "InstantiationType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Gate",
    "expressions": [],
    "properties": ["Interaction"]
  },
  {
    "name": "LiteralString",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "InteractionOperatorKind",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Interaction",
    "expressions": [],
    "properties": [
      "properties",
      "MessageView",
      "lifelines",
      "formalGates",
      "AspectMessageView",
      "messages"
    ]
  },
  {
    "name": "AssociationEnd",
    "expressions": [
      {
        "operations": {
          "<>": 2,
          "and": 1
        },
        "name": "uniqueName",
        "body": "Tuple {\n\tmessage : String = 'AssociationEnds of a class must be unique',\n\tstatus : Boolean = self.myClass.associationEnds->select(associationEnd : AssociationEnd | associationEnd.name <> null and associationEnd.name <> '')->isUnique(name)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 3,
          "NullLiteralExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 2,
          "PropertyCallExpImpl": 6
        },
        "properties": [
          "ram::NamedElement::name",
          "ram::AssociationEnd::myClass",
          "$$::Tuple::status",
          "ram::Class::associationEnds"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "at": 1
        },
        "name": "getType",
        "body": "self.assoc.ends->select(end : AssociationEnd | end <> self)->at(1).myClass",
        "type": "OperationImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 2,
          "IntegerLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::AssociationEnd::myClass",
          "ram::Association::ends",
          "ram::AssociationEnd::assoc"
        ]
      }
    ],
    "properties": [
      "myClass",
      "navigable",
      "assoc"
    ]
  },
  {
    "name": "RString",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.String'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getName",
        "body": "'String'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "OccurrenceSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ObjectType",
    "expressions": [],
    "properties": [
      "RCollection",
      "Reference"
    ]
  },
  {
    "name": "Lifeline",
    "expressions": [],
    "properties": [
      "coveredBy",
      "Interaction",
      "represents",
      "localProperties"
    ]
  },
  {
    "name": "Aspect",
    "expressions": [{
      "operations": {
        "allInstances": 2,
        "union": 2,
        "=": 2
      },
      "name": "mandatoryAspectParameters",
      "body": "let mappableElements : Set(MappableElement) = Set{} in mappableElements->union(Class.allInstances()->select(partial = true))->union(Operation.allInstances()->select(partial = true))",
      "type": "PropertyImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 6,
        "LetExpImpl": 1,
        "TypeExpImpl": 2,
        "CollectionLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2,
        "BooleanLiteralExpImpl": 2
      },
      "properties": [
        "ram::Class::partial",
        "ram::Operation::partial"
      ]
    }],
    "properties": [
      "layout",
      "instantiations",
      "mandatoryAspectParameters",
      "Instantiation",
      "messageViews",
      "structuralView"
    ]
  },
  {
    "name": "Layout",
    "expressions": [],
    "properties": [
      "containers",
      "Aspect"
    ]
  },
  {
    "name": "MappableElement",
    "expressions": [],
    "properties": [
      "Mapping",
      "Mapping",
      "Aspect"
    ]
  },
  {
    "name": "Classifier",
    "expressions": [],
    "properties": [
      "operations",
      "Class",
      "StructuralView"
    ]
  },
  {
    "name": "MessageEnd",
    "expressions": [],
    "properties": [
      "Message",
      "Message",
      "message"
    ]
  },
  {
    "name": "LiteralInteger",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "LiteralBoolean",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "ImplementationClass",
    "expressions": [],
    "properties": ["instanceClassName"]
  },
  {
    "name": "AspectMessageView",
    "expressions": [{
      "operations": {
        "not": 1,
        "includes": 1
      },
      "name": "notAffectedBySelf",
      "body": "Tuple {\n\tmessage : String = 'Message View may not be affected by itself',\n\tstatus : Boolean = not self.affectedBy->includes(self)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "ram::AbstractMessageView::affectedBy",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "AbstractMessageView",
      "advice",
      "pointcut"
    ]
  },
  {
    "name": "Message",
    "expressions": [
      {
        "operations": {
          "not": 1,
          "oclIsUndefined": 1,
          "=": 1
        },
        "name": "validReturns",
        "body": "Tuple {\n\tmessage : String = 'Returns may only be specified if message sort is reply message',\n\tstatus : Boolean = if not self.returns.oclIsUndefined() then self.messageSort = MessageSort::reply else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 3,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 3,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::returns",
          "$$::Tuple::status",
          "ram::Message::messageSort"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsUndefined": 1,
          "oclIsTypeOf": 4,
          "getType": 1,
          "oclIsKindOf": 1,
          "oclAsType": 4,
          "oclType": 1
        },
        "name": "validReturnsValue",
        "body": "Tuple {\n\tmessage : String = 'Type of return value must match the type of the return',\n\tstatus : Boolean = if self.returns.oclIsTypeOf(StructuralFeatureValue) then let value : StructuralFeatureValue = self.returns.oclAsType(StructuralFeatureValue).value in if not value.oclIsUndefined() then let type : Type = if value.oclIsTypeOf(Attribute) then value.oclAsType(Attribute).type else if value.oclIsTypeOf(Reference) then value.oclAsType(Reference).type else value.oclAsType(AssociationEnd).getType() endif endif in type.oclIsTypeOf(self.signature.returnType.oclType()) else true endif else if self.returns.oclIsKindOf(LiteralSpecification) then false else true endif endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 13,
          "VariableExpImpl": 11,
          "LetExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 8,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 5,
          "PropertyCallExpImpl": 9,
          "BooleanLiteralExpImpl": 3
        },
        "properties": [
          "ram::StructuralFeatureValue::value",
          "ram::Message::returns",
          "ram::Operation::returnType",
          "$$::Tuple::status",
          "ram::Attribute::type",
          "ram::Reference::type",
          "ram::Message::signature"
        ]
      },
      {
        "operations": {
          "oclIsTypeOf": 1,
          "=": 1
        },
        "name": "assignToAllowed",
        "body": "Tuple {\n\tmessage : String = 'assignTo may not be specified for operations whose return type is void',\n\tstatus : Boolean = if self.signature.returnType.oclIsTypeOf(RVoid) then self.assignTo = null else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "NullLiteralExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Operation::returnType",
          "$$::Tuple::status",
          "ram::Message::assignTo",
          "ram::Message::signature"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 2,
          "at": 2,
          "oclIsKindOf": 2,
          "and": 3,
          "asOrderedSet": 2,
          "<": 1,
          "oclAsType": 2,
          "=": 1,
          "indexOf": 2
        },
        "name": "validSelfMessage",
        "body": "Tuple {\n\tmessage : String = 'receiveEvent of a self message may not come before the sendEvent',\n\tstatus : Boolean = if not self.receiveEvent.oclIsUndefined() and self.receiveEvent.oclIsKindOf(MessageOccurrenceSpecification) and not self.sendEvent.oclIsUndefined() and self.sendEvent.oclIsKindOf(MessageOccurrenceSpecification) then if self.sendEvent.oclAsType(MessageOccurrenceSpecification).covered->asOrderedSet()->at(1) = self.receiveEvent.oclAsType(MessageOccurrenceSpecification).covered->asOrderedSet()->at(1) then self.interaction.fragments->indexOf(self.sendEvent) < self.interaction.fragments->indexOf(self.receiveEvent) else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 19,
          "VariableExpImpl": 10,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 4,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 2,
          "BooleanLiteralExpImpl": 2,
          "PropertyCallExpImpl": 15
        },
        "properties": [
          "ram::InteractionFragment::covered",
          "ram::Message::sendEvent",
          "ram::Message::receiveEvent",
          "$$::Tuple::status",
          "ram::Message::interaction",
          "ram::FragmentContainer::fragments"
        ]
      },
      {
        "operations": {
          "at": 2,
          "oclIsKindOf": 2,
          "and": 1,
          "asOrderedSet": 2,
          "=": 1,
          "oclAsType": 2
        },
        "name": "selfMessage",
        "body": "if self.sendEvent.oclIsKindOf(MessageOccurrenceSpecification) and self.receiveEvent.oclIsKindOf(MessageOccurrenceSpecification) then self.sendEvent.oclAsType(MessageOccurrenceSpecification).covered->asOrderedSet()->at(1) = self.receiveEvent.oclAsType(MessageOccurrenceSpecification).covered->asOrderedSet()->at(1) else false endif",
        "type": "PropertyImpl",
        "constructs": {
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 4,
          "IntegerLiteralExpImpl": 2,
          "TypeExpImpl": 4,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 6,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::InteractionFragment::covered",
          "ram::Message::sendEvent",
          "ram::Message::receiveEvent"
        ]
      },
      {
        "operations": {
          "<>": 1,
          "not": 2,
          "oclIsUndefined": 2,
          "size": 2,
          "oclIsKindOf": 1,
          "and": 4,
          "includes": 1,
          "oclAsType": 1,
          "=": 2
        },
        "name": "argumentsSpecified",
        "body": "Tuple {\n\tmessage : String = 'All arguments of the operation must be specified',\n\tstatus : Boolean = if self.messageSort <> MessageSort::reply and not self.sendEvent.oclIsUndefined() and self.sendEvent.oclIsKindOf(MessageOccurrenceSpecification) and not self.signature.oclIsUndefined() then let container : FragmentContainer = self.sendEvent.oclAsType(MessageOccurrenceSpecification).container in if container.fragments->includes(self.sendEvent) then self.signature.parameters->size() = self.arguments->size() and self.signature.parameters->forAll(currentParameter : Parameter | self.arguments->one(argument : ParameterValueMapping | argument.parameter = currentParameter)) else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 13,
          "OperationCallExpImpl": 16,
          "LetExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 16,
          "BooleanLiteralExpImpl": 2
        },
        "properties": [
          "ram::Message::arguments",
          "ram::Message::sendEvent",
          "ram::InteractionFragment::container",
          "ram::ParameterValueMapping::parameter",
          "$$::Tuple::status",
          "ram::Message::messageSort",
          "ram::Operation::parameters",
          "ram::Message::signature",
          "ram::FragmentContainer::fragments"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 1,
          "at": 1,
          "and": 1,
          "asOrderedSet": 1,
          "isEmpty": 1,
          "includes": 1,
          "=": 1,
          "indexOf": 2,
          "oclAsType": 2,
          ">=": 1
        },
        "name": "createMessageIsFirst",
        "body": "Tuple {\n\tmessage : String = 'The create message occurrence may not come after any other occurrence on this lifeline',\n\tstatus : Boolean = if self.messageSort = MessageSort::createMessage then if not self.receiveEvent.oclIsUndefined() and not self.receiveEvent.oclAsType(InteractionFragment).covered->isEmpty() then let event : InteractionFragment = self.receiveEvent.oclAsType(InteractionFragment) in event.covered->asOrderedSet()->at(1).coveredBy->forAll(fragment : InteractionFragment | if event.container.fragments->includes(fragment) then event.container.fragments->indexOf(fragment) >= event.container.fragments->indexOf(event) else true endif) else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 11,
          "OperationCallExpImpl": 14,
          "LetExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 14,
          "BooleanLiteralExpImpl": 3
        },
        "properties": [
          "ram::InteractionFragment::covered",
          "ram::Lifeline::coveredBy",
          "ram::InteractionFragment::container",
          "ram::Message::receiveEvent",
          "$$::Tuple::status",
          "ram::Message::messageSort",
          "ram::FragmentContainer::fragments"
        ]
      },
      {
        "operations": {
          "at": 2,
          "oclIsTypeOf": 2,
          "and": 2,
          "asOrderedSet": 2,
          "includes": 2,
          "oclAsType": 2
        },
        "name": "boundariesNotCrossed",
        "body": "Tuple {\n\tmessage : String = 'Messages may not cross boundaries of CombinedFragments or their operands',\n\tstatus : Boolean = let send : MessageOccurrenceSpecification = self.sendEvent in let receive : MessageOccurrenceSpecification = self.receiveEvent in if send.container.oclIsTypeOf(InteractionOperand) and receive.container.oclIsTypeOf(InteractionOperand) then send.container.oclAsType(InteractionOperand).CombinedFragment.covered->includes(send.covered->asOrderedSet()->at(1)) and receive.container.oclAsType(InteractionOperand).CombinedFragment.covered->includes(receive.covered->asOrderedSet()->at(1)) else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 8,
          "OperationCallExpImpl": 12,
          "LetExpImpl": 2,
          "OppositePropertyCallExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 4,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 11,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::InteractionFragment::covered",
          "ram::InteractionFragment::container",
          "ram::Message::sendEvent",
          "ram::Message::receiveEvent",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "not": 2,
          "oclIsUndefined": 1,
          "at": 1,
          "and": 1,
          "asOrderedSet": 1,
          "isEmpty": 1,
          "includes": 1,
          "oclAsType": 2,
          "indexOf": 2,
          "=": 1
        },
        "name": "deleteMessageIsLast",
        "body": "Tuple {\n\tmessage : String = 'The destruction occurrence may not come before any other occurrence on this lifeline',\n\tstatus : Boolean = if self.messageSort = MessageSort::deleteMessage then if not self.receiveEvent.oclIsUndefined() and not self.receiveEvent.oclAsType(InteractionFragment).covered->isEmpty() then let event : InteractionFragment = self.receiveEvent.oclAsType(InteractionFragment) in event.covered->asOrderedSet()->at(1).coveredBy->forAll(fragment : InteractionFragment | if event.container.fragments->includes(fragment) then event.container.fragments->indexOf(fragment) <= event.container.fragments->indexOf(event) else true endif) else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 14,
          "VariableExpImpl": 11,
          "LetExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 14,
          "BooleanLiteralExpImpl": 3
        },
        "properties": [
          "ram::InteractionFragment::covered",
          "ram::InteractionFragment::container",
          "ram::Lifeline::coveredBy",
          "ram::Message::receiveEvent",
          "$$::Tuple::status",
          "ram::Message::messageSort",
          "ram::FragmentContainer::fragments"
        ]
      },
      {
        "operations": {
          "not": 2,
          "<>": 1,
          "oclIsUndefined": 2,
          "at": 1,
          "oclIsKindOf": 1,
          "oclIsTypeOf": 3,
          "getType": 1,
          "and": 1,
          "asOrderedSet": 1,
          "includes": 1,
          "oclAsType": 6
        },
        "name": "validSignature",
        "body": "Tuple {\n\tmessage : String = 'Message signature must be an operation of the classifier that is represented by the lifeline of the receive event',\n\tstatus : Boolean = if self.messageSort <> MessageSort::reply and not self.receiveEvent.oclIsUndefined() then let typedElement : TypedElement = self.receiveEvent.oclAsType(InteractionFragment).covered->asOrderedSet()->at(1).represents in if not typedElement.oclIsUndefined() then let type : Type = if typedElement.oclIsTypeOf(Parameter) then typedElement.oclAsType(Parameter).type else if typedElement.oclIsTypeOf(Attribute) then typedElement.oclAsType(Attribute).type else if typedElement.oclIsTypeOf(Reference) then typedElement.oclAsType(Reference).type else typedElement.oclAsType(AssociationEnd).getType() endif endif endif in if type.oclIsKindOf(Classifier) then type.oclAsType(Classifier).operations->includes(self.signature) else true endif else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 14,
          "OperationCallExpImpl": 20,
          "LetExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 10,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 6,
          "BooleanLiteralExpImpl": 3,
          "PropertyCallExpImpl": 11
        },
        "properties": [
          "ram::Classifier::operations",
          "ram::InteractionFragment::covered",
          "ram::Parameter::type",
          "ram::Message::receiveEvent",
          "ram::Attribute::type",
          "$$::Tuple::status",
          "ram::Message::messageSort",
          "ram::Reference::type",
          "ram::Lifeline::represents",
          "ram::Message::signature"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 2,
          "oclIsKindOf": 2,
          "and": 3,
          "indexOf": 2,
          "oclAsType": 1,
          "=": 1,
          "-": 1
        },
        "name": "noCrossingMessages",
        "body": "Tuple {\n\tmessage : String = 'Messages may not cross each other, MessageEnds of one message must come one after the other (also, send must come before receive)',\n\tstatus : Boolean = if not self.receiveEvent.oclIsUndefined() and self.receiveEvent.oclIsKindOf(MessageOccurrenceSpecification) and not self.sendEvent.oclIsUndefined() and self.sendEvent.oclIsKindOf(MessageOccurrenceSpecification) then let container : FragmentContainer = self.receiveEvent.oclAsType(MessageOccurrenceSpecification).container in let indexDifference : Integer = container.fragments->indexOf(self.receiveEvent) - container.fragments->indexOf(self.sendEvent) in indexDifference = 1 else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 14,
          "VariableExpImpl": 10,
          "LetExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 3,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 11,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::InteractionFragment::container",
          "ram::Message::sendEvent",
          "ram::Message::receiveEvent",
          "$$::Tuple::status",
          "ram::FragmentContainer::fragments"
        ]
      },
      {
        "operations": {
          "not": 1,
          "oclIsUndefined": 1,
          "oclIsKindOf": 1,
          "oclIsTypeOf": 2,
          "getType": 1,
          "oclAsType": 3,
          "oclType": 1
        },
        "name": "validAssignTo",
        "body": "Tuple {\n\tmessage : String = 'Return type of signature operation must match the type of assignTo',\n\tstatus : Boolean = if not self.assignTo.oclIsUndefined() then let type : Type = if self.assignTo.oclIsTypeOf(Attribute) then self.assignTo.oclAsType(Attribute).type else if self.assignTo.oclIsTypeOf(Reference) then self.assignTo.oclAsType(Reference).type else self.assignTo.oclAsType(AssociationEnd).getType() endif endif in type.oclIsKindOf(self.signature.returnType.oclType()) else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 8,
          "OperationCallExpImpl": 10,
          "LetExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 5,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 11,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Operation::returnType",
          "ram::Attribute::type",
          "$$::Tuple::status",
          "ram::Reference::type",
          "ram::Message::assignTo",
          "ram::Message::signature"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 2,
          "oclIsTypeOf": 1,
          "=": 1
        },
        "name": "returnsSpecified",
        "body": "Tuple {\n\tmessage : String = 'Reply message must have returns specified if return type is not void',\n\tstatus : Boolean = if self.messageSort = MessageSort::reply then if not self.signature.returnType.oclIsTypeOf(RVoid) then not self.returns.oclIsUndefined() else self.returns.oclIsUndefined() endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 4,
          "OperationCallExpImpl": 6,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 6,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Message::returns",
          "ram::Operation::returnType",
          "$$::Tuple::status",
          "ram::Message::messageSort",
          "ram::Message::signature"
        ]
      }
    ],
    "properties": [
      "selfMessage",
      "arguments",
      "returns",
      "sendEvent",
      "receiveEvent",
      "messageSort",
      "interaction",
      "MessageEnd",
      "assignTo",
      "signature"
    ]
  },
  {
    "name": "DestructionOccurrenceSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ValueSpecification",
    "expressions": [],
    "properties": [
      "Message",
      "ParameterValueMapping",
      "ExecutionStatement",
      "InteractionOperand"
    ]
  },
  {
    "name": "StructuralFeature",
    "expressions": [],
    "properties": [
      "StructuralFeatureValue",
      "static",
      "Message"
    ]
  },
  {
    "name": "FragmentContainer",
    "expressions": [],
    "properties": ["fragments"]
  },
  {
    "name": "Property",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "=": 1,
          "-": 1,
          ">": 1
        },
        "name": "validUpperBound",
        "body": "Tuple {\n\tmessage : String = 'The upperbound must be greater than zero or -1 representing *',\n\tstatus : Boolean = self.upperBound > 0 or self.upperBound = - 1\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 4,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::Property::upperBound",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {
          "<=": 1,
          "or": 1,
          "=": 1,
          "-": 1
        },
        "name": "validMultiplicity",
        "body": "Tuple {\n\tmessage : String = 'The lowerBound must be less than or equal to the upperBound',\n\tstatus : Boolean = self.lowerBound <= self.upperBound or self.upperBound = - 1\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 4,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "$$::Tuple::status",
          "ram::Property::upperBound",
          "ram::Property::lowerBound"
        ]
      },
      {
        "operations": {">=": 1},
        "name": "validLowerBound",
        "body": "Tuple {\n\tmessage : String = 'The lowerbound must be greater than or equal to zero',\n\tstatus : Boolean = self.lowerBound >= 0\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 1,
          "VariableExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "$$::Tuple::status",
          "ram::Property::lowerBound"
        ]
      }
    ],
    "properties": [
      "referenceType",
      "upperBound",
      "lowerBound"
    ]
  },
  {
    "name": "Visibility",
    "expressions": [],
    "properties": []
  },
  {
    "name": "InteractionOperand",
    "expressions": [],
    "properties": [
      "interactionConstraint",
      "CombinedFragment"
    ]
  },
  {
    "name": "RAny",
    "expressions": [{
      "operations": {},
      "name": "getName",
      "body": "'*'",
      "type": "OperationImpl",
      "constructs": {"StringLiteralExpImpl": 1},
      "properties": []
    }],
    "properties": []
  },
  {
    "name": "OpaqueExpression",
    "expressions": [],
    "properties": [
      "language",
      "body"
    ]
  },
  {
    "name": "MessageViewReference",
    "expressions": [{
      "operations": {
        "size": 1,
        ">": 1
      },
      "name": "isAffectedBy",
      "body": "Tuple {\n\tmessage : String = 'The MessageViewReference must have at least one affectedBy',\n\tstatus : Boolean = self.affectedBy->size() > 0\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "TupleLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "ram::AbstractMessageView::affectedBy",
        "$$::Tuple::status"
      ]
    }],
    "properties": ["references"]
  },
  {
    "name": "Reference",
    "expressions": [],
    "properties": [
      "type",
      "Interaction"
    ]
  },
  {
    "name": "ReferenceType",
    "expressions": [],
    "properties": []
  },
  {
    "name": "REnumLiteral",
    "expressions": [],
    "properties": ["enum"]
  },
  {
    "name": "LiteralSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "ContainerMap",
    "expressions": [],
    "properties": [
      "key",
      "Layout",
      "value"
    ]
  },
  {
    "name": "StructuralView",
    "expressions": [
      {
        "operations": {},
        "name": "noTwoClassesWithSameName",
        "body": "Tuple {\n\tmessage : String = 'Name of a class has to be unique',\n\tstatus : Boolean = self.classes->isUnique(name)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::NamedElement::name",
          "$$::Tuple::status",
          "ram::StructuralView::classes"
        ]
      },
      {
        "operations": {},
        "name": "uniqueTypes",
        "body": "Tuple {\n\tmessage : String = 'There may be only one type of the same type',\n\tstatus : Boolean = self.types->isUnique(name)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::NamedElement::name",
          "$$::Tuple::status",
          "ram::StructuralView::types"
        ]
      }
    ],
    "properties": [
      "Aspect",
      "classes",
      "types",
      "associations"
    ]
  },
  {
    "name": "RInt",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Integer'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getName",
        "body": "'int'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "LayoutElement",
    "expressions": [],
    "properties": [
      "ElementMap",
      "y",
      "x"
    ]
  },
  {
    "name": "ElementMap",
    "expressions": [],
    "properties": [
      "key",
      "ContainerMap",
      "value"
    ]
  },
  {
    "name": "Type",
    "expressions": [],
    "properties": [
      "Operation",
      "Parameter",
      "StructuralView"
    ]
  },
  {
    "name": "RVoid",
    "expressions": [{
      "operations": {},
      "name": "getName",
      "body": "'void'",
      "type": "OperationImpl",
      "constructs": {"StringLiteralExpImpl": 1},
      "properties": []
    }],
    "properties": []
  },
  {
    "name": "StructuralFeatureValue",
    "expressions": [],
    "properties": ["value"]
  },
  {
    "name": "Parameter",
    "expressions": [{
      "operations": {
        "not": 1,
        "oclIsTypeOf": 1
      },
      "name": "notVoid",
      "body": "Tuple {\n\tmessage : String = 'The type of the parameter may not be void',\n\tstatus : Boolean = not self.type.oclIsTypeOf(RVoid)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 1,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "ram::Parameter::type",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "Operation",
      "type",
      "ParameterValueMapping",
      "ParameterValue"
    ]
  },
  {
    "name": "RList",
    "expressions": [],
    "properties": []
  },
  {
    "name": "CombinedFragment",
    "expressions": [{
      "operations": {
        "or": 2,
        "size": 1,
        "=": 4
      },
      "name": "validOperands",
      "body": "Tuple {\n\tmessage : String = 'opt and loop fragments may only have one operand',\n\tstatus : Boolean = if self.interactionOperator = InteractionOperatorKind::opt or self.interactionOperator = InteractionOperatorKind::loop or self.interactionOperator = InteractionOperatorKind::critical then self.operands->size() = 1 else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 4,
        "OperationCallExpImpl": 7,
        "TupleLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "EnumLiteralExpImpl": 3,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 5,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::CombinedFragment::interactionOperator",
        "ram::CombinedFragment::operands",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "interactionOperator",
      "operands"
    ]
  },
  {
    "name": "EObject",
    "expressions": [],
    "properties": [
      "ElementMap",
      "ContainerMap"
    ]
  },
  {
    "name": "MessageOccurrenceSpecification",
    "expressions": [],
    "properties": []
  },
  {
    "name": "REnum",
    "expressions": [],
    "properties": ["literals"]
  },
  {
    "name": "Attribute",
    "expressions": [],
    "properties": [
      "type",
      "Class"
    ]
  },
  {
    "name": "TypedElement",
    "expressions": [],
    "properties": ["Lifeline"]
  },
  {
    "name": "Mapping",
    "expressions": [
      {
        "operations": {
          "or": 1,
          "oclIsTypeOf": 2
        },
        "name": "validSourceModelElement",
        "body": "Tuple {\n\tmessage : String = 'The source model element may only be of type Class or Operation',\n\tstatus : Boolean = self.fromElement.oclIsTypeOf(Class) or self.fromElement.oclIsTypeOf(Operation)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "OperationCallExpImpl": 3,
          "VariableExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 3
        },
        "properties": [
          "ram::Mapping::fromElement",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {
          "oclIsTypeOf": 1,
          "oclIsKindOf": 2,
          "oclType": 1
        },
        "name": "sameTypesMapped",
        "body": "Tuple {\n\tmessage : String = 'Mapping must be between same types of elements',\n\tstatus : Boolean = self.toElements->forAll(element : MappableElement | if element.oclIsKindOf(Classifier) then self.fromElement.oclIsKindOf(Classifier) else element.oclIsTypeOf(self.fromElement.oclType()) endif)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 4,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 4
        },
        "properties": [
          "ram::Mapping::fromElement",
          "$$::Tuple::status",
          "ram::Mapping::toElements"
        ]
      },
      {
        "operations": {
          "oclIsTypeOf": 2,
          "oclIsKindOf": 1,
          "and": 1,
          "includes": 3,
          "oclAsType": 2
        },
        "name": "validMapping",
        "body": "Tuple {\n\tmessage : String = 'Source must be from depending aspect and targets must be from current aspect',\n\tstatus : Boolean = let clazz : Class = if fromElement.oclIsTypeOf(Operation) then fromElement.oclAsType(Operation).Classifier else fromElement endif in self.Instantiation.externalAspect.structuralView.classes->includes(clazz) and self.toElements->forAll(element : MappableElement | let clazz : Class = if element.oclIsTypeOf(Operation) then element.oclAsType(Operation).Classifier else element endif in if clazz.oclIsKindOf(PrimitiveType) then self.Instantiation.Aspect.structuralView.types->includes(clazz) else self.Instantiation.Aspect.structuralView.classes->includes(clazz) endif)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "VariableExpImpl": 14,
          "OperationCallExpImpl": 9,
          "LetExpImpl": 2,
          "OppositePropertyCallExpImpl": 7,
          "TupleLiteralExpImpl": 1,
          "TypeExpImpl": 5,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 3,
          "PropertyCallExpImpl": 12
        },
        "properties": [
          "ram::Mapping::fromElement",
          "$$::Tuple::status",
          "ram::Mapping::toElements",
          "ram::StructuralView::classes",
          "ram::Aspect::structuralView",
          "ram::StructuralView::types",
          "ram::Instantiation::externalAspect"
        ]
      }
    ],
    "properties": [
      "Instantiation",
      "fromElement",
      "toElements"
    ]
  },
  {
    "name": "AbstractMessageView",
    "expressions": [],
    "properties": [
      "affectedBy",
      "Aspect"
    ]
  },
  {
    "name": "RCollection",
    "expressions": [{
      "operations": {
        "or": 1,
        "oclIsUndefined": 1,
        "size": 1,
        "oclIsTypeOf": 2,
        "and": 2,
        "+": 4,
        "oclAsType": 2,
        "substring": 1,
        "oclType": 2
      },
      "name": "getName",
      "body": "let partial : String = if type.oclIsTypeOf(Class) and type.oclAsType(Class).partial or type.oclIsTypeOf(Operation) and type.oclAsType(Operation).partial then '|' else '' endif in let name : String = self.oclType().name.substring(2, self.oclType().name.size()) in if type.name.oclIsUndefined() then name else name + '<' + partial + type.name + '>' endif",
      "type": "OperationImpl",
      "constructs": {
        "OperationCallExpImpl": 16,
        "VariableExpImpl": 11,
        "LetExpImpl": 2,
        "IntegerLiteralExpImpl": 1,
        "StringLiteralExpImpl": 4,
        "TypeExpImpl": 4,
        "IfExpImpl": 2,
        "PropertyCallExpImpl": 12
      },
      "properties": [
        "pivot::NamedElement::name",
        "ram::NamedElement::name",
        "ram::Class::partial",
        "ram::Operation::partial",
        "ram::RCollection::type"
      ]
    }],
    "properties": ["type"]
  },
  {
    "name": "Operation",
    "expressions": [{
      "operations": {
        "oclIsTypeOf": 2,
        "and": 1,
        "oclAsSet": 1,
        "=": 2,
        "oclAsType": 1
      },
      "name": "messageViewDefined",
      "body": "Tuple {\n\tmessage : String = 'MessageView missing for public operation',\n\tstatus : Boolean = if visibility = Visibility::public and self.Classifier.oclIsTypeOf(Class) then self.Classifier.StructuralView.Aspect.messageViews->select(messageView : AbstractMessageView | messageView.oclIsTypeOf(MessageView))->one(messageView : AbstractMessageView | messageView.oclAsType(MessageView).specifies = self) else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "IteratorExpImpl": 2,
        "OperationCallExpImpl": 7,
        "VariableExpImpl": 6,
        "OppositePropertyCallExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "EnumLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "TypeExpImpl": 3,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 6,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::MessageView::specifies",
        "ram::Operation::visibility",
        "$$::Tuple::status",
        "OclInvalid::oclBadProperty"
      ]
    }],
    "properties": [
      "MessageView",
      "AspectMessageView",
      "visibility",
      "static",
      "returnType",
      "partial",
      "abstract",
      "Classifier",
      "parameters",
      "Message"
    ]
  },
  {
    "name": "ExecutionStatement",
    "expressions": [],
    "properties": ["specification"]
  },
  {
    "name": "TemporaryProperty",
    "expressions": [],
    "properties": ["Lifeline"]
  },
  {
    "name": "MessageSort",
    "expressions": [],
    "properties": []
  },
  {
    "name": "Class",
    "expressions": [{
      "operations": {
        "not": 1,
        "includes": 1
      },
      "name": "notSelfSuperType",
      "body": "Tuple {\n\tmessage : String = 'A class may not be it\\'s own supertype',\n\tstatus : Boolean = not self.superTypes->includes(self)\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 2,
        "OperationCallExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 2
      },
      "properties": [
        "$$::Tuple::status",
        "ram::Class::superTypes"
      ]
    }],
    "properties": [
      "attributes",
      "partial",
      "associationEnds",
      "abstract",
      "superTypes"
    ]
  },
  {
    "name": "NamedElement",
    "expressions": [{
      "operations": {
        "<>": 1,
        "oclIsTypeOf": 1,
        "and": 1,
        "oclAsType": 1,
        "=": 1
      },
      "name": "validName",
      "body": "Tuple {\n\tmessage : String = 'Name of RAM elements may not be empty',\n\tstatus : Boolean = if self.oclIsTypeOf(AssociationEnd) and self.oclAsType(AssociationEnd).navigable = false then true else self.name <> '' endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 5,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 2,
        "TypeExpImpl": 2,
        "IfExpImpl": 1,
        "BooleanLiteralExpImpl": 2,
        "PropertyCallExpImpl": 3
      },
      "properties": [
        "ram::NamedElement::name",
        "ram::AssociationEnd::navigable",
        "$$::Tuple::status"
      ]
    }],
    "properties": ["name"]
  },
  {
    "name": "ParameterValue",
    "expressions": [{
      "operations": {
        "oclIsTypeOf": 1,
        "oclType": 1
      },
      "name": "validValueType",
      "body": "Tuple {\n\tmessage : String = 'Type of value must match the type of the parameter',\n\tstatus : Boolean = self.parameter.type.oclIsTypeOf(self.ParameterValueMapping.parameter.type.oclType())\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 2,
        "VariableExpImpl": 2,
        "OppositePropertyCallExpImpl": 1,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "PropertyCallExpImpl": 5
      },
      "properties": [
        "ram::Parameter::type",
        "ram::ParameterValueMapping::parameter",
        "$$::Tuple::status",
        "ram::ParameterValue::parameter"
      ]
    }],
    "properties": ["parameter"]
  },
  {
    "name": "Instantiation",
    "expressions": [
      {
        "operations": {"=": 2},
        "name": "mandatoryAspectParametersMapped",
        "body": "Tuple {\n\tmessage : String = 'Partial elements from lower-level aspects have to be mapped',\n\tstatus : Boolean = if self.type = InstantiationType::Depends then self.externalAspect.mandatoryAspectParameters->forAll(element : MappableElement | self.mappings->exists(fromElement = element)) else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 2,
          "VariableExpImpl": 5,
          "OperationCallExpImpl": 2,
          "TupleLiteralExpImpl": 1,
          "EnumLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 6,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::Aspect::mandatoryAspectParameters",
          "ram::Mapping::fromElement",
          "$$::Tuple::status",
          "ram::Instantiation::externalAspect",
          "ram::Instantiation::type",
          "ram::Instantiation::mappings"
        ]
      },
      {
        "operations": {
          "not": 1,
          "=": 1
        },
        "name": "aspectCannotMapSelf",
        "body": "Tuple {\n\tmessage : String = 'Aspect may not depend on itself',\n\tstatus : Boolean = not (self.externalAspect = self.Aspect)\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 2,
          "OperationCallExpImpl": 2,
          "OppositePropertyCallExpImpl": 1,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "PropertyCallExpImpl": 2
        },
        "properties": [
          "$$::Tuple::status",
          "ram::Instantiation::externalAspect"
        ]
      }
    ],
    "properties": [
      "Aspect",
      "externalAspect",
      "type",
      "mappings"
    ]
  },
  {
    "name": "ParameterValueMapping",
    "expressions": [{
      "operations": {
        "not": 1,
        "oclIsUndefined": 1,
        "oclIsTypeOf": 4,
        "getType": 1,
        "oclIsKindOf": 1,
        "oclAsType": 4,
        "oclType": 1
      },
      "name": "validParameterValue",
      "body": "Tuple {\n\tmessage : String = 'Type of value must match the type of the parameter',\n\tstatus : Boolean = if self.value.oclIsTypeOf(StructuralFeatureValue) then let value : StructuralFeatureValue = self.value.oclAsType(StructuralFeatureValue).value in if not value.oclIsUndefined() then let type : Type = if value.oclIsTypeOf(Attribute) then value.oclAsType(Attribute).type else if value.oclIsTypeOf(Reference) then value.oclAsType(Reference).type else value.oclAsType(AssociationEnd).getType() endif endif in type.oclIsTypeOf(self.parameter.type.oclType()) else true endif else if self.value.oclIsKindOf(LiteralSpecification) then false else true endif endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "OperationCallExpImpl": 13,
        "VariableExpImpl": 11,
        "LetExpImpl": 2,
        "TupleLiteralExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "TypeExpImpl": 8,
        "IfExpImpl": 5,
        "PropertyCallExpImpl": 9,
        "BooleanLiteralExpImpl": 3
      },
      "properties": [
        "ram::ParameterValueMapping::value",
        "ram::StructuralFeatureValue::value",
        "ram::Parameter::type",
        "ram::ParameterValueMapping::parameter",
        "$$::Tuple::status",
        "ram::Attribute::type",
        "ram::Reference::type"
      ]
    }],
    "properties": [
      "value",
      "Message",
      "parameter"
    ]
  },
  {
    "name": "PrimitiveType",
    "expressions": [],
    "properties": ["Attribute"]
  },
  {
    "name": "RChar",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Character'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getName",
        "body": "'char'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "RSet",
    "expressions": [],
    "properties": []
  },
  {
    "name": "RBoolean",
    "expressions": [
      {
        "operations": {},
        "name": "getInstanceClassName",
        "body": "'java.lang.Boolean'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      },
      {
        "operations": {},
        "name": "getName",
        "body": "'boolean'",
        "type": "OperationImpl",
        "constructs": {"StringLiteralExpImpl": 1},
        "properties": []
      }
    ],
    "properties": []
  },
  {
    "name": "OriginalBehaviorExecution",
    "expressions": [],
    "properties": []
  },
  {
    "name": "InteractionFragment",
    "expressions": [{
      "operations": {
        "not": 1,
        "size": 1,
        "oclIsTypeOf": 1,
        "and": 1,
        "notEmpty": 1,
        "=": 1
      },
      "name": "validCoveredMultiplicity",
      "body": "Tuple {\n\tmessage : String = 'InteractionFragment may only have one Lifeline it covers (except CombinedFragment)',\n\tstatus : Boolean = if not self.oclIsTypeOf(CombinedFragment) and covered->notEmpty() then covered->size() = 1 else true endif\n}.status",
      "type": "ConstraintImpl",
      "constructs": {
        "VariableExpImpl": 3,
        "OperationCallExpImpl": 6,
        "TupleLiteralExpImpl": 1,
        "IntegerLiteralExpImpl": 1,
        "TypeExpImpl": 1,
        "StringLiteralExpImpl": 1,
        "IfExpImpl": 1,
        "PropertyCallExpImpl": 3,
        "BooleanLiteralExpImpl": 1
      },
      "properties": [
        "ram::InteractionFragment::covered",
        "$$::Tuple::status"
      ]
    }],
    "properties": [
      "covered",
      "container"
    ]
  },
  {
    "name": "MessageView",
    "expressions": [
      {
        "operations": {
          "oclIsUndefined": 1,
          "and": 1,
          "notEmpty": 1
        },
        "name": "isAffectedBy",
        "body": "Tuple {\n\tmessage : String = 'An empty MessageView must have at least one affectedBy',\n\tstatus : Boolean = if self.specification.oclIsUndefined() and self.specifies.partial then self.affectedBy->notEmpty() else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 3,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 5,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::MessageView::specifies",
          "ram::MessageView::specification",
          "ram::AbstractMessageView::affectedBy",
          "ram::Operation::partial",
          "$$::Tuple::status"
        ]
      },
      {
        "operations": {
          "not": 2,
          "oclIsUndefined": 1,
          "at": 1,
          "size": 1,
          "oclIsTypeOf": 1,
          "and": 1,
          "asOrderedSet": 1,
          "=": 1,
          ">": 1
        },
        "name": "specifiesIsFirstMessage",
        "body": "Tuple {\n\tmessage : String = 'The first message in the MessageView must match specifies of the MessageView',\n\tstatus : Boolean = if not self.specification.oclIsUndefined() and self.specification.messages->size() > 0 then self.specifies = self.specification.messages->select(message : Message | not message.sendEvent.oclIsTypeOf(MessageOccurrenceSpecification))->asOrderedSet()->at(1).signature else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "IteratorExpImpl": 1,
          "OperationCallExpImpl": 10,
          "VariableExpImpl": 5,
          "TupleLiteralExpImpl": 1,
          "IntegerLiteralExpImpl": 2,
          "StringLiteralExpImpl": 1,
          "TypeExpImpl": 1,
          "IfExpImpl": 1,
          "PropertyCallExpImpl": 9,
          "BooleanLiteralExpImpl": 1
        },
        "properties": [
          "ram::MessageView::specifies",
          "ram::MessageView::specification",
          "ram::Message::sendEvent",
          "$$::Tuple::status",
          "ram::Interaction::messages",
          "ram::Message::signature"
        ]
      },
      {
        "operations": {
          "not": 3,
          "oclIsUndefined": 2
        },
        "name": "specificationDefined",
        "body": "Tuple {\n\tmessage : String = 'A MessageView for a non-partial operation must have a specification',\n\tstatus : Boolean = if not self.specifies.oclIsUndefined() then if not self.specifies.partial then not self.specification.oclIsUndefined() else true endif else true endif\n}.status",
        "type": "ConstraintImpl",
        "constructs": {
          "VariableExpImpl": 3,
          "OperationCallExpImpl": 5,
          "TupleLiteralExpImpl": 1,
          "StringLiteralExpImpl": 1,
          "IfExpImpl": 2,
          "PropertyCallExpImpl": 5,
          "BooleanLiteralExpImpl": 2
        },
        "properties": [
          "ram::MessageView::specifies",
          "ram::MessageView::specification",
          "ram::Operation::partial",
          "$$::Tuple::status"
        ]
      }
    ],
    "properties": [
      "specifies",
      "specification",
      "MessageViewReference"
    ]
  }
]
