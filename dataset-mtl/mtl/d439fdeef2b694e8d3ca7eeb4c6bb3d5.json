[
  {
    "operations": {},
    "body": "aStateMachine.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "aStateMachine.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "aStateMachine.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {
      "selectByType": 1,
      "=": 1
    },
    "body": "aStateMachine.region->collect(temp1 : Region | getAllVertex(temp1))->selectByType(uml::Pseudostate)->select(temp2 : Pseudostate | temp2.kind.=(uml::PseudostateKind::shallowHistory))->sortedBy(temp3 : Pseudostate | temp3.name)",
    "type": "ForIter",
    "constructs": {
      "IteratorExpImpl": 3,
      "VariableExpImpl": 4,
      "OperationCallExpImpl": 2,
      "QueryInvocationSpec": 1,
      "EnumLiteralExpImpl": 1,
      "TypeExpImpl": 1,
      "PropertyCallExpImpl": 3
    },
    "properties": [
      "kind",
      "name",
      "region"
    ]
  },
  {
    "operations": {},
    "body": "ips.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {
      "selectByKind": 1,
      "allOwnedElements": 1
    },
    "body": "aStateMachine.allOwnedElements()->selectByKind(uml::Vertex)->sortedBy(temp1 : Vertex | temp1.name)",
    "type": "ForIter",
    "constructs": {
      "IteratorExpImpl": 1,
      "VariableExpImpl": 2,
      "OperationCallExpImpl": 2,
      "TypeExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "is.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "aStateMachine.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "is.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "is.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {
      "selectByType": 1,
      "=": 1
    },
    "body": "ism.region->collect(temp1 : Region | getAllVertex(temp1))->selectByType(uml::Pseudostate)->select(temp2 : Pseudostate | temp2.kind.=(uml::PseudostateKind::shallowHistory))->sortedBy(temp3 : Pseudostate | temp3.name)",
    "type": "ForIter",
    "constructs": {
      "IteratorExpImpl": 3,
      "VariableExpImpl": 4,
      "OperationCallExpImpl": 2,
      "QueryInvocationSpec": 1,
      "EnumLiteralExpImpl": 1,
      "TypeExpImpl": 1,
      "PropertyCallExpImpl": 3
    },
    "properties": [
      "kind",
      "name",
      "region"
    ]
  },
  {
    "operations": {
      "selectByType": 1,
      "sep": 1
    },
    "body": "getAllVertexInRegion(ips.container)->selectByType(uml::State)->collect(temp1 : State | temp1.name)->sep('['', '', '', '']')",
    "type": "TemplateExpression",
    "constructs": {
      "IteratorExpImpl": 1,
      "VariableExpImpl": 2,
      "OperationCallExpImpl": 2,
      "QueryInvocationSpec": 1,
      "TypeExpImpl": 1,
      "StringLiteralExpImpl": 3,
      "PropertyCallExpImpl": 2
    },
    "properties": [
      "container",
      "name"
    ]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {"+": 2},
    "body": "'[''.+(ips.name).+('']')",
    "type": "TemplateExpression",
    "constructs": {
      "OperationCallExpImpl": 2,
      "VariableExpImpl": 1,
      "StringLiteralExpImpl": 2,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {"notEmpty": 1},
    "body": "is.connection->select(temp1 : ConnectionPointReference | temp1.entry->notEmpty())->sortedBy(temp2 : ConnectionPointReference | temp2.name)",
    "type": "ForIter",
    "constructs": {
      "IteratorExpImpl": 2,
      "VariableExpImpl": 3,
      "OperationCallExpImpl": 1,
      "PropertyCallExpImpl": 3
    },
    "properties": [
      "entry",
      "name",
      "connection"
    ]
  },
  {
    "operations": {},
    "body": "icpr.entry->collect(temp1 : Pseudostate | temp1.name)",
    "type": "TemplateExpression",
    "constructs": {
      "IteratorExpImpl": 1,
      "VariableExpImpl": 2,
      "PropertyCallExpImpl": 2
    },
    "properties": [
      "entry",
      "name"
    ]
  },
  {
    "operations": {},
    "body": "is.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "aStateMachine.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "is.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {"+": 6},
    "body": "'['onenter'.+(icpr.entry->collect(temp1 : Pseudostate | temp1.name)).+(''](event, '').+(is.name).+('', '').+(icpr.entry->collect(temp2 : Pseudostate | temp2.name)).+('')')",
    "type": "TemplateExpression",
    "constructs": {
      "IteratorExpImpl": 2,
      "OperationCallExpImpl": 6,
      "VariableExpImpl": 5,
      "StringLiteralExpImpl": 4,
      "PropertyCallExpImpl": 5
    },
    "properties": [
      "entry",
      "name"
    ]
  },
  {
    "operations": {"notEmpty": 1},
    "body": "is.connection->select(temp1 : ConnectionPointReference | temp1.exit->notEmpty())->sortedBy(temp2 : ConnectionPointReference | temp2.name)",
    "type": "ForIter",
    "constructs": {
      "IteratorExpImpl": 2,
      "OperationCallExpImpl": 1,
      "VariableExpImpl": 3,
      "PropertyCallExpImpl": 3
    },
    "properties": [
      "exit",
      "name",
      "connection"
    ]
  },
  {
    "operations": {"+": 2},
    "body": "is.name.+('_').+(icpr.exit->collect(temp1 : Pseudostate | temp1.name))",
    "type": "TemplateExpression",
    "constructs": {
      "IteratorExpImpl": 1,
      "VariableExpImpl": 3,
      "OperationCallExpImpl": 2,
      "StringLiteralExpImpl": 1,
      "PropertyCallExpImpl": 3
    },
    "properties": [
      "exit",
      "name"
    ]
  },
  {
    "operations": {
      "selectByType": 1,
      "=": 1
    },
    "body": "ism.region->collect(temp1 : Region | getAllVertex(temp1))->selectByType(uml::Pseudostate)->select(temp2 : Pseudostate | temp2.kind.=(uml::PseudostateKind::shallowHistory))->sortedBy(temp3 : Pseudostate | temp3.name)",
    "type": "ForIter",
    "constructs": {
      "IteratorExpImpl": 3,
      "OperationCallExpImpl": 2,
      "VariableExpImpl": 4,
      "QueryInvocationSpec": 1,
      "EnumLiteralExpImpl": 1,
      "TypeExpImpl": 1,
      "PropertyCallExpImpl": 3
    },
    "properties": [
      "kind",
      "name",
      "region"
    ]
  },
  {
    "operations": {
      "selectByType": 1,
      "sep": 1
    },
    "body": "getAllVertexInRegion(ips.container)->selectByType(uml::State)->collect(temp1 : State | temp1.name)->sep('['', '', '', '']')",
    "type": "TemplateExpression",
    "constructs": {
      "IteratorExpImpl": 1,
      "OperationCallExpImpl": 2,
      "VariableExpImpl": 2,
      "QueryInvocationSpec": 1,
      "TypeExpImpl": 1,
      "StringLiteralExpImpl": 3,
      "PropertyCallExpImpl": 2
    },
    "properties": [
      "container",
      "name"
    ]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ism.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {"+": 2},
    "body": "'[''.+(ips.name).+('']')",
    "type": "TemplateExpression",
    "constructs": {
      "OperationCallExpImpl": 2,
      "VariableExpImpl": 1,
      "StringLiteralExpImpl": 2,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {"+": 2},
    "body": "is.name.+('_').+(icpr.exit->collect(temp1 : Pseudostate | temp1.name))",
    "type": "TemplateExpression",
    "constructs": {
      "IteratorExpImpl": 1,
      "VariableExpImpl": 3,
      "OperationCallExpImpl": 2,
      "StringLiteralExpImpl": 1,
      "PropertyCallExpImpl": 3
    },
    "properties": [
      "exit",
      "name"
    ]
  },
  {
    "operations": {"notEmpty": 1},
    "body": "icpr.outgoing->notEmpty()",
    "type": "IfExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "OperationCallExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["outgoing"]
  },
  {
    "operations": {},
    "body": "sequence",
    "type": "QueryInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "aStateMachine.name",
    "type": "QueryInvocationArgument",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {
      "not": 1,
      "oclIsTypeOf": 1,
      "and": 1,
      "asSet": 1,
      "oclAsType": 1,
      "=": 1
    },
    "body": "aStateMachine.region->collect(temp1 : Region | getAllTransitionInRegion(temp1))->select(temp2 : Transition | checkTransition(temp2))->select(temp3 : Transition | temp3.target.oclIsTypeOf(uml::Pseudostate).and(temp3.target.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::exitPoint)).not())->collect(temp4 : Transition | getTransitionBegin(temp4))->select(temp5 : Transition | checkTransition(temp5))->collect(temp6 : Transition | temp6.name)->asSet()",
    "type": "ForIter",
    "constructs": {
      "IteratorExpImpl": 6,
      "OperationCallExpImpl": 6,
      "VariableExpImpl": 8,
      "QueryInvocationSpec": 4,
      "EnumLiteralExpImpl": 1,
      "TypeExpImpl": 2,
      "PropertyCallExpImpl": 5
    },
    "properties": [
      "kind",
      "name",
      "target",
      "region"
    ]
  },
  {
    "operations": {},
    "body": "transition",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "aStateMachine",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "sequence",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {
      "at": 2,
      "or": 1,
      "notEmpty": 2
    },
    "body": "sequence->at(1)->notEmpty().or(sequence->at(2)->notEmpty())",
    "type": "IfExpression",
    "constructs": {
      "OperationCallExpImpl": 5,
      "VariableExpImpl": 2,
      "IntegerLiteralExpImpl": 2
    },
    "properties": []
  },
  {
    "operations": {},
    "body": "transition",
    "type": "QueryInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {"at": 1},
    "body": "sequence->at(1)",
    "type": "ForIter",
    "constructs": {
      "VariableExpImpl": 1,
      "OperationCallExpImpl": 1,
      "IntegerLiteralExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {},
    "body": "transition",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "history",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "aStateMachine",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "'sameLevel'",
    "type": "TemplateInvocationArgument",
    "constructs": {"StringLiteralExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "stateLimit1",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {"sep": 1},
    "body": "stateLimit1->sep('['', '', '', '']')",
    "type": "TemplateExpression",
    "constructs": {
      "OperationCallExpImpl": 1,
      "VariableExpImpl": 1,
      "StringLiteralExpImpl": 3
    },
    "properties": []
  },
  {
    "operations": {"+": 2},
    "body": "'[''.+(history.name).+('']')",
    "type": "TemplateExpression",
    "constructs": {
      "OperationCallExpImpl": 2,
      "VariableExpImpl": 1,
      "StringLiteralExpImpl": 2,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {"at": 1},
    "body": "sequence->at(2)",
    "type": "ForIter",
    "constructs": {
      "OperationCallExpImpl": 1,
      "VariableExpImpl": 1,
      "IntegerLiteralExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {},
    "body": "transition",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "history",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "aStateMachine",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "'outRegion'",
    "type": "TemplateInvocationArgument",
    "constructs": {"StringLiteralExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "stateLimit2",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {"sep": 1},
    "body": "stateLimit2->sep('['', '', '', '']')",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "OperationCallExpImpl": 1,
      "StringLiteralExpImpl": 3
    },
    "properties": []
  },
  {
    "operations": {"not": 1},
    "body": "clearHistory(history).not()",
    "type": "IfExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "OperationCallExpImpl": 1,
      "QueryInvocationSpec": 1
    },
    "properties": []
  },
  {
    "operations": {"+": 2},
    "body": "'[''.+(history.name).+('']')",
    "type": "TemplateExpression",
    "constructs": {
      "OperationCallExpImpl": 2,
      "VariableExpImpl": 1,
      "StringLiteralExpImpl": 2,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {"+": 2},
    "body": "'[''.+(history.name).+('']')",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "OperationCallExpImpl": 2,
      "StringLiteralExpImpl": 2,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "aStateMachine.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {
      "<>": 1,
      "at": 1,
      "asSequence": 1
    },
    "body": "getInitTransition(aStateMachine.region->asSequence()->at(1)).<>(null)",
    "type": "IfExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "OperationCallExpImpl": 3,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 1,
      "IntegerLiteralExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["region"]
  },
  {
    "operations": {
      "at": 1,
      "asSequence": 1
    },
    "body": "getInitTransition(aStateMachine.region->asSequence()->at(1)).target.name",
    "type": "TemplateExpression",
    "constructs": {
      "OperationCallExpImpl": 2,
      "VariableExpImpl": 1,
      "QueryInvocationSpec": 1,
      "IntegerLiteralExpImpl": 1,
      "PropertyCallExpImpl": 3
    },
    "properties": [
      "name",
      "target",
      "region"
    ]
  },
  {
    "operations": {
      "or": 1,
      "oclIsTypeOf": 2,
      "allOwnedElements": 1,
      "oclAsType": 1
    },
    "body": "aStateMachine.allOwnedElements()->select(temp1 : Element | temp1.oclIsTypeOf(uml::State).or(temp1.oclIsTypeOf(uml::Pseudostate)))->collect(temp2 : Element | temp2.oclAsType(uml::Vertex))->sortedBy(temp3 : Vertex | temp3.name)",
    "type": "ForIter",
    "constructs": {
      "IteratorExpImpl": 3,
      "OperationCallExpImpl": 5,
      "VariableExpImpl": 5,
      "TypeExpImpl": 3,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "is",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "outgoings",
    "type": "TemplateInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {"not": 1},
    "body": "outgoings->select(temp1 : Transition | checkTransition(temp1))->select(temp2 : Transition | isCompositeStateWithoutInitial(temp2.target).not())->sortedBy(temp3 : Transition | temp3.name)",
    "type": "ForIter",
    "constructs": {
      "IteratorExpImpl": 3,
      "VariableExpImpl": 4,
      "OperationCallExpImpl": 1,
      "QueryInvocationSpec": 2,
      "PropertyCallExpImpl": 2
    },
    "properties": [
      "name",
      "target"
    ]
  },
  {
    "operations": {"=": 1},
    "body": "ips.kind.=(uml::PseudostateKind::entryPoint)",
    "type": "IfExpression",
    "constructs": {
      "OperationCallExpImpl": 1,
      "VariableExpImpl": 1,
      "EnumLiteralExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["kind"]
  },
  {
    "operations": {},
    "body": "it.name",
    "type": "QueryInvocationArgument",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "ips.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "it.target",
    "type": "QueryInvocationArgument",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["target"]
  },
  {
    "operations": {"=": 1},
    "body": "ips.kind.=(uml::PseudostateKind::initial)",
    "type": "IfExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "OperationCallExpImpl": 1,
      "EnumLiteralExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["kind"]
  },
  {
    "operations": {"excluding": 1},
    "body": "getTransitionBegin(it)->excluding(null)->sortedBy(temp1 : Transition | temp1.name)->collect(temp2 : Transition | temp2.name)",
    "type": "ForIter",
    "constructs": {
      "IteratorExpImpl": 2,
      "VariableExpImpl": 3,
      "OperationCallExpImpl": 1,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 1,
      "PropertyCallExpImpl": 2
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "itn",
    "type": "QueryInvocationArgument",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {},
    "body": "ips.name",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["name"]
  },
  {
    "operations": {},
    "body": "it.target",
    "type": "QueryInvocationArgument",
    "constructs": {
      "VariableExpImpl": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["target"]
  },
  {
    "operations": {"invoke": 1},
    "body": "self.invoke('com.iauto.mist.spec.m2t.uml2html.util.utils', 'generateOnbeforeMethod(java.lang.String, org.eclipse.uml2.uml.StateMachine, java.util.List)', Sequence {transition, stm, sequence})",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 4,
      "OperationCallExpImpl": 1,
      "StringLiteralExpImpl": 2,
      "CollectionLiteralExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {"invoke": 1},
    "body": "self.invoke('com.iauto.mist.spec.m2t.uml2html.util.utils', 'generateExitNodeInRegionOfTransition(java.lang.String, org.eclipse.uml2.uml.Pseudostate, org.eclipse.uml2.uml.StateMachine, java.lang.String, java.util.List)', Sequence {transition, history, stm, type, sequence})",
    "type": "TemplateExpression",
    "constructs": {
      "VariableExpImpl": 6,
      "OperationCallExpImpl": 1,
      "StringLiteralExpImpl": 2,
      "CollectionLiteralExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {"invoke": 1},
    "body": "self->invoke('com.iauto.mist.spec.m2t.uml2html.util.utils', 'transitionInit(java.util.List, java.lang.String)', Sequence {transitions, stateMachineName})",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 1,
      "VariableExpImpl": 3,
      "StringLiteralExpImpl": 2,
      "CollectionLiteralExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {"invoke": 1},
    "body": "self.invoke('com.iauto.mist.spec.m2t.uml2html.util.utils', 'genOutgoingsWithExitPoint(org.eclipse.uml2.uml.Vertex, java.util.List , java.lang.Boolean)', Sequence {iv, outgoings, false})",
    "type": "TemplateExpression",
    "constructs": {
      "OperationCallExpImpl": 1,
      "VariableExpImpl": 3,
      "StringLiteralExpImpl": 2,
      "CollectionLiteralExpImpl": 1,
      "BooleanLiteralExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {
      "notEmpty": 3,
      "=": 1
    },
    "body": "if history.container.state.outgoing->select(temp1 : Transition | temp1.target.=(history))->notEmpty() then true else if history.incoming->select(temp2 : Transition | Set {temp2.source}->notEmpty())->collect(temp3 : Transition | ignoreChoiceOutgoing(temp3))->select(temp4 : Transition | checkTransition(temp4))->select(temp5 : Transition | isVertexInRegion(temp5.source,history.container))->notEmpty() then true else false endif endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 5,
      "VariableExpImpl": 9,
      "OperationCallExpImpl": 4,
      "QueryInvocationSpec": 3,
      "CollectionLiteralExpImpl": 1,
      "IfExpImpl": 2,
      "PropertyCallExpImpl": 8,
      "BooleanLiteralExpImpl": 3
    },
    "properties": [
      "container",
      "state",
      "outgoing",
      "target",
      "incoming",
      "source"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "oclAsType": 1
    },
    "body": "if transition.target.oclIsTypeOf(uml::ConnectionPointReference) then transition.target.oclAsType(uml::ConnectionPointReference).state else transition.target endif",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 3,
      "OperationCallExpImpl": 2,
      "TypeExpImpl": 2,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 4
    },
    "properties": [
      "state",
      "target"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 2,
      "union": 2,
      "notEmpty": 2,
      "oclAsType": 4
    },
    "body": "if iv.oclIsTypeOf(uml::ConnectionPointReference) then Set {iv.oclAsType(uml::ConnectionPointReference).state}->union(iv.oclAsType(uml::ConnectionPointReference).state.connection)->collect(temp1 : Vertex | temp1.incoming)->select(temp2 : Transition | Set {temp2.source}->notEmpty())->collect(temp3 : Transition | ignoreChoiceOutgoing(temp3))->select(temp4 : Transition | checkTransition(temp4))->select(temp5 : Transition | isVertexInRegion(temp5.source,ir)) else if iv.oclIsTypeOf(uml::State) then iv.oclAsType(uml::State).incoming->union(iv.oclAsType(uml::State).connection->collect(temp6 : ConnectionPointReference | temp6.incoming))->select(temp7 : Transition | Set {temp7.source}->notEmpty())->collect(temp8 : Transition | ignoreChoiceOutgoing(temp8))->select(temp9 : Transition | checkTransition(temp9))->select(temp10 : Transition | isVertexInRegion(temp10.source,ir)) else null endif endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 10,
      "VariableExpImpl": 18,
      "OperationCallExpImpl": 10,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 6,
      "TypeExpImpl": 6,
      "CollectionLiteralExpImpl": 3,
      "IfExpImpl": 2,
      "PropertyCallExpImpl": 11
    },
    "properties": [
      "state",
      "connection",
      "incoming",
      "source"
    ]
  },
  {
    "operations": {
      "at": 2,
      "or": 1,
      "oclIsTypeOf": 3,
      "and": 2,
      "notEmpty": 3,
      "oclAsType": 6,
      "=": 2,
      "asSequence": 2
    },
    "body": "if iv.oclIsTypeOf(uml::ConnectionPointReference) then iv.oclAsType(uml::ConnectionPointReference).entry->any(temp1 : Pseudostate | temp1.outgoing->notEmpty()).name else if iv.oclIsTypeOf(uml::Pseudostate).and(iv.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::exitPoint).or(iv.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::entryPoint))).and(Set {iv.oclAsType(uml::Pseudostate).state}->notEmpty()) then getTargetNode(iv.outgoing->asSequence()->at(1).target) else if iv.oclIsTypeOf(uml::State) then if iv.oclAsType(uml::State).region->notEmpty() then getTargetNode(getInitTransition(iv.oclAsType(uml::State).region->asSequence()->at(1)).target) else iv.name endif else iv.name endif endif endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 1,
      "OperationCallExpImpl": 21,
      "VariableExpImpl": 13,
      "QueryInvocationSpec": 3,
      "EnumLiteralExpImpl": 2,
      "IntegerLiteralExpImpl": 2,
      "TypeExpImpl": 9,
      "CollectionLiteralExpImpl": 1,
      "IfExpImpl": 4,
      "PropertyCallExpImpl": 13
    },
    "properties": [
      "kind",
      "entry",
      "outgoing",
      "region",
      "name",
      "target",
      "state"
    ]
  },
  {
    "operations": {"<>": 1},
    "body": "if iv.container.stateMachine.<>(null) then iv.container.stateMachine.submachineState->collect(temp1 : State | temp1.name) else getTopStateName(iv.container.state) endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 1,
      "VariableExpImpl": 4,
      "OperationCallExpImpl": 1,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 1,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 8
    },
    "properties": [
      "container",
      "state",
      "submachineState",
      "stateMachine",
      "name"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "selectByType": 3,
      "notEmpty": 3,
      "=": 1,
      "oclAsType": 1
    },
    "body": "if iv.oclIsTypeOf(uml::State) then let state : State = iv.oclAsType(uml::State) in if state.region->collect(temp1 : Region | temp1.ownedMember)->selectByType(uml::State)->notEmpty() then if state.region->collect(temp2 : Region | temp2.ownedMember)->selectByType(uml::Pseudostate)->notEmpty() then let c : Collection(Pseudostate) = state.region->collect(temp3 : Region | temp3.ownedMember)->selectByType(uml::Pseudostate) in if c->select(temp4 : Pseudostate | temp4.kind.=(uml::PseudostateKind::initial))->notEmpty() then false else true endif else true endif else false endif else false endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 4,
      "OperationCallExpImpl": 9,
      "VariableExpImpl": 10,
      "LetExpImpl": 2,
      "EnumLiteralExpImpl": 1,
      "TypeExpImpl": 5,
      "IfExpImpl": 4,
      "BooleanLiteralExpImpl": 5,
      "PropertyCallExpImpl": 7
    },
    "properties": [
      "kind",
      "ownedMember",
      "region"
    ]
  }
]
