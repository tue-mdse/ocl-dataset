[
  {
    "operations": {},
    "body": "self",
    "type": "QueryExpression",
    "constructs": {"VariableExpImpl": 1},
    "properties": []
  },
  {
    "operations": {
      "selectByType": 1,
      "oclAsType": 1
    },
    "body": "aModel.member->selectByType(uml::StateMachine)->collect(temp1 : StateMachine | temp1.oclAsType(uml::StateMachine))",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 1,
      "OperationCallExpImpl": 2,
      "VariableExpImpl": 2,
      "TypeExpImpl": 2,
      "PropertyCallExpImpl": 1
    },
    "properties": ["member"]
  },
  {
    "operations": {"isEmpty": 1},
    "body": "getAllStateMachine(aModel)->any(temp1 : StateMachine | temp1.submachineState->isEmpty())",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 1,
      "VariableExpImpl": 2,
      "OperationCallExpImpl": 1,
      "QueryInvocationSpec": 1,
      "PropertyCallExpImpl": 1
    },
    "properties": ["submachineState"]
  },
  {
    "operations": {
      "selectByType": 2,
      "union": 1,
      "notEmpty": 1
    },
    "body": "if aRegion.subvertex->selectByType(uml::State)->collect(temp1 : State | temp1.region)->notEmpty() then aRegion.transition->union(aRegion.subvertex->selectByType(uml::State)->collect(temp2 : State | temp2.region)->collect(temp3 : Region | getAllTransitionInRegion(temp3))) else aRegion.transition endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 3,
      "VariableExpImpl": 7,
      "OperationCallExpImpl": 4,
      "QueryInvocationSpec": 1,
      "TypeExpImpl": 2,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 6
    },
    "properties": [
      "transition",
      "region",
      "subvertex"
    ]
  },
  {
    "operations": {
      "selectByType": 2,
      "isEmpty": 1,
      "=": 2
    },
    "body": "if region.subvertex->selectByType(uml::Pseudostate)->select(temp1 : Pseudostate | temp1.kind.=(uml::PseudostateKind::initial))->isEmpty() then null else region.subvertex->selectByType(uml::Pseudostate)->select(temp2 : Pseudostate | temp2.kind.=(uml::PseudostateKind::initial))->collect(temp3 : Pseudostate | temp3.outgoing)->any(temp4 : Transition | checkTransition(temp4)) endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 4,
      "VariableExpImpl": 6,
      "OperationCallExpImpl": 5,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 1,
      "EnumLiteralExpImpl": 2,
      "TypeExpImpl": 2,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 5
    },
    "properties": [
      "kind",
      "outgoing",
      "subvertex"
    ]
  },
  {
    "operations": {
      "not": 1,
      "oclIsTypeOf": 2,
      "and": 2,
      "asSet": 1,
      "=": 2,
      "oclAsType": 2
    },
    "body": "aStateMachine.region->collect(temp1 : Region | getAllTransitionInRegion(temp1))->select(temp2 : Transition | checkTransition(temp2))->select(temp3 : Transition | temp3.source.oclIsTypeOf(uml::Pseudostate).and(temp3.source.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::entryPoint)))->select(temp4 : Transition | temp4.target.oclIsTypeOf(uml::Pseudostate).and(temp4.target.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::shallowHistory)).not())->asSet()",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 4,
      "OperationCallExpImpl": 10,
      "VariableExpImpl": 7,
      "QueryInvocationSpec": 2,
      "EnumLiteralExpImpl": 2,
      "TypeExpImpl": 4,
      "PropertyCallExpImpl": 7
    },
    "properties": [
      "kind",
      "target",
      "region",
      "source"
    ]
  },
  {
    "operations": {
      "and": 1,
      "notEmpty": 2
    },
    "body": "if Set {aTransition.source}->notEmpty().and(Set {aTransition.target}->notEmpty()) then true else false endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 3,
      "VariableExpImpl": 2,
      "CollectionLiteralExpImpl": 2,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 2,
      "BooleanLiteralExpImpl": 2
    },
    "properties": [
      "target",
      "source"
    ]
  },
  {
    "operations": {
      "union": 1,
      "asSet": 1
    },
    "body": "let transitions : Bag(Transition) = getAllTransitionInRegion(aRegion)->select(temp1 : Transition | checkTransition(temp1)) in transitions->collect(temp2 : Transition | temp2.source)->union(transitions->collect(temp3 : Transition | temp3.target))->asSet()",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 3,
      "VariableExpImpl": 6,
      "OperationCallExpImpl": 2,
      "LetExpImpl": 1,
      "QueryInvocationSpec": 2,
      "PropertyCallExpImpl": 2
    },
    "properties": [
      "target",
      "source"
    ]
  },
  {
    "operations": {
      "not": 1,
      "oclIsTypeOf": 1,
      "and": 1,
      "selectByType": 2,
      "union": 1,
      "notEmpty": 2,
      "oclAsType": 1
    },
    "body": "if aRegion.subvertex->selectByType(uml::State)->collect(temp1 : State | temp1.region)->notEmpty() then aRegion.subvertex->select(temp2 : Vertex | temp2.oclIsTypeOf(uml::State).and(temp2.oclAsType(uml::State).region->notEmpty()).not())->union(aRegion.subvertex->selectByType(uml::State)->collect(temp3 : State | temp3.region)->collect(temp4 : Region | getAllVertexInRegion(temp4))) else aRegion.subvertex endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 4,
      "VariableExpImpl": 9,
      "OperationCallExpImpl": 9,
      "QueryInvocationSpec": 1,
      "TypeExpImpl": 4,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 7
    },
    "properties": [
      "region",
      "subvertex"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "and": 1,
      "asSet": 1,
      "notEmpty": 1,
      "oclAsType": 2
    },
    "body": "if aVertex.oclIsTypeOf(uml::State).and(aVertex.oclAsType(uml::State).region->notEmpty()) then aVertex.oclAsType(uml::State).region->collect(temp1 : Region | temp1.subvertex)->collect(temp2 : Vertex | getVertexWhetherNesting(temp2)) else Set {aVertex}->asSet() endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 2,
      "OperationCallExpImpl": 6,
      "VariableExpImpl": 6,
      "QueryInvocationSpec": 1,
      "TypeExpImpl": 3,
      "CollectionLiteralExpImpl": 1,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 3
    },
    "properties": [
      "region",
      "subvertex"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "isEmpty": 1,
      "notEmpty": 1,
      "oclAsType": 1,
      "=": 1
    },
    "body": "if aVertex.oclIsTypeOf(uml::ConnectionPointReference) then isVertexInRegion(aVertex.oclAsType(uml::ConnectionPointReference).state,aRegion) else if Set {aVertex.container}->isEmpty() then false else if aVertex.container.=(aRegion) then true else if Set {aVertex.container.state}->notEmpty() then isVertexInRegion(aVertex.container.state,aRegion) else false endif endif endif endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 5,
      "VariableExpImpl": 9,
      "QueryInvocationSpec": 2,
      "TypeExpImpl": 2,
      "CollectionLiteralExpImpl": 2,
      "IfExpImpl": 4,
      "PropertyCallExpImpl": 7,
      "BooleanLiteralExpImpl": 3
    },
    "properties": [
      "container",
      "state",
      "state"
    ]
  },
  {
    "operations": {"replace": 4},
    "body": "aString.replace('interrupt_', '').replace('HDKey_', '').replace('INT@', '').replace('HDK@', '')",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 4,
      "VariableExpImpl": 1,
      "StringLiteralExpImpl": 8
    },
    "properties": []
  },
  {
    "operations": {
      "or": 6,
      "lastIndex": 1,
      "+": 2,
      "equalsIgnoreCase": 7,
      "-": 1,
      "=": 1,
      "substring": 1
    },
    "body": "let dotIndex : Integer = aString.lastIndex('.') in if dotIndex.=(1.-()) then aString.+(getDefaultPost(self)) else let suffix : String = aString.substring(dotIndex) in if suffix.equalsIgnoreCase('.jpg').or(suffix.equalsIgnoreCase('.png')).or(suffix.equalsIgnoreCase('.gif')).or(suffix.equalsIgnoreCase('.bmp')).or(suffix.equalsIgnoreCase('.jpeg')).or(suffix.equalsIgnoreCase('.svg')).or(suffix.equalsIgnoreCase('.pdf')) then aString else aString.+(getDefaultPost(self)) endif endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 19,
      "VariableExpImpl": 16,
      "LetExpImpl": 2,
      "QueryInvocationSpec": 2,
      "IntegerLiteralExpImpl": 1,
      "StringLiteralExpImpl": 8,
      "IfExpImpl": 2
    },
    "properties": []
  },
  {
    "operations": {"invoke": 1},
    "body": "self.invoke('com.iauto.mist.spec.m2t.uml2html.util.ConfigUtil', 'getDefaultPre()', Sequence {})",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "OperationCallExpImpl": 1,
      "StringLiteralExpImpl": 2,
      "CollectionLiteralExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {"invoke": 1},
    "body": "self.invoke('com.iauto.mist.spec.m2t.uml2html.util.ConfigUtil', 'getDefaultPost()', Sequence {})",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "OperationCallExpImpl": 1,
      "StringLiteralExpImpl": 2,
      "CollectionLiteralExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {
      "or": 1,
      "oclIsTypeOf": 3,
      "and": 5,
      "includes": 2,
      "union": 1,
      "notEmpty": 8,
      "asSet": 2,
      "oclAsType": 7,
      "=": 3,
      "containingStateMachine": 2
    },
    "body": "if it.source.oclIsTypeOf(uml::Pseudostate).and(it.source.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::entryPoint).or(it.source.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::exitPoint))).and(Set {it.source.oclAsType(uml::Pseudostate).state}->notEmpty()) then let icpr : Bag(ConnectionPointReference) = it.containingStateMachine().submachineState->collect(temp1 : State | temp1.connection)->select(temp2 : ConnectionPointReference | temp2.entry->includes(it.source)) in it.source.oclAsType(uml::Pseudostate).incoming->select(temp3 : Transition | Set {temp3.source}->notEmpty())->collect(temp4 : Transition | getTransitionBegin(temp4))->union(icpr->collect(temp5 : ConnectionPointReference | temp5.incoming)->select(temp6 : Transition | Set {temp6.source}->notEmpty())->collect(temp7 : Transition | getTransitionBegin(temp7))) else if it.source.oclIsTypeOf(uml::Pseudostate).and(it.source.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::entryPoint)) then let icpr : Bag(ConnectionPointReference) = it.containingStateMachine().submachineState->collect(temp8 : State | temp8.connection)->select(temp9 : ConnectionPointReference | temp9.entry->includes(it.source)) in if icpr->collect(temp10 : ConnectionPointReference | temp10.incoming)->notEmpty().and(icpr->collect(temp11 : ConnectionPointReference | temp11.incoming)->collect(temp12 : Transition | temp12.source)->notEmpty()) then icpr->collect(temp13 : ConnectionPointReference | temp13.incoming)->select(temp14 : Transition | Set {temp14.source}->notEmpty())->collect(temp15 : Transition | getTransitionBegin(temp15)) else Set {null}->asSet() endif else if it.source.oclIsTypeOf(uml::ConnectionPointReference).and(it.source.oclAsType(uml::ConnectionPointReference).exit->notEmpty()) then let ips : Collection(Pseudostate) = it.source.oclAsType(uml::ConnectionPointReference).exit in ips->collect(temp16 : Pseudostate | temp16.incoming)->select(temp17 : Transition | Set {temp17.source}->notEmpty())->collect(temp18 : Transition | getTransitionBegin(temp18)) else Set {it}->asSet() endif endif endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 18,
      "VariableExpImpl": 38,
      "OperationCallExpImpl": 34,
      "LetExpImpl": 3,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 4,
      "EnumLiteralExpImpl": 3,
      "TypeExpImpl": 10,
      "CollectionLiteralExpImpl": 7,
      "IfExpImpl": 4,
      "PropertyCallExpImpl": 35
    },
    "properties": [
      "kind",
      "entry",
      "submachineState",
      "exit",
      "connection",
      "incoming",
      "source",
      "state"
    ]
  },
  {
    "operations": {
      "at": 5,
      "or": 1,
      "oclIsTypeOf": 3,
      "and": 3,
      "includes": 2,
      "notEmpty": 13,
      "=": 2,
      "oclAsType": 12,
      "containingStateMachine": 2,
      "asSequence": 5
    },
    "body": "if it.target.oclIsTypeOf(uml::Pseudostate).and(it.target.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::exitPoint).or(it.target.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::entryPoint))) then if Set {it.target.oclAsType(uml::Pseudostate).state}->notEmpty() then getTransitionEnd(it.target.outgoing->asSequence()->at(1)) else if it.containingStateMachine().submachineState->collect(temp1 : State | temp1.connection)->one(temp2 : ConnectionPointReference | temp2.exit->includes(it.target)) then let icpr : ConnectionPointReference = it.containingStateMachine().submachineState->collect(temp3 : State | temp3.connection)->any(temp4 : ConnectionPointReference | temp4.exit->includes(it.target)) in if icpr.outgoing->notEmpty().and(icpr.outgoing->collect(temp5 : Transition | temp5.target)->notEmpty()) then getTransitionEnd(icpr.outgoing->any(temp6 : Transition | Set {temp6.target}->notEmpty())) else null endif else null endif endif else if it.target.oclIsTypeOf(uml::ConnectionPointReference) then if it.target.oclAsType(uml::ConnectionPointReference).entry->notEmpty() then let ips : Collection(Pseudostate) = it.target.oclAsType(uml::ConnectionPointReference).entry in if ips->collect(temp7 : Pseudostate | temp7.outgoing)->notEmpty().and(ips->collect(temp8 : Pseudostate | temp8.outgoing)->collect(temp9 : Transition | temp9.target)->notEmpty()) then getTransitionEnd(ips->collect(temp10 : Pseudostate | temp10.outgoing)->any(temp11 : Transition | Set {temp11.target}->notEmpty())) else null endif else null endif else if it.target.oclIsTypeOf(uml::State) then if Set {it.target.oclAsType(uml::State).submachine}->notEmpty() then if it.target.oclAsType(uml::State).submachine.region->notEmpty() then if Set {getInitTransition(it.target.oclAsType(uml::State).submachine.region->asSequence()->at(1))}->notEmpty() then getTransitionEnd(getInitTransition(it.target.oclAsType(uml::State).submachine.region->asSequence()->at(1))) else null endif else null endif else if it.target.oclAsType(uml::State).region->notEmpty() then if Set {getInitTransition(it.target.oclAsType(uml::State).region->asSequence()->at(1))}->notEmpty() then getTransitionEnd(getInitTransition(it.target.oclAsType(uml::State).region->asSequence()->at(1))) else null endif else it endif endif else it endif endif endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 11,
      "VariableExpImpl": 39,
      "OperationCallExpImpl": 48,
      "LetExpImpl": 2,
      "NullLiteralExpImpl": 7,
      "QueryInvocationSpec": 9,
      "IntegerLiteralExpImpl": 5,
      "EnumLiteralExpImpl": 2,
      "TypeExpImpl": 15,
      "CollectionLiteralExpImpl": 6,
      "IfExpImpl": 13,
      "PropertyCallExpImpl": 50
    },
    "properties": [
      "entry",
      "kind",
      "submachineState",
      "exit",
      "region",
      "outgoing",
      "target",
      "connection",
      "region",
      "submachine",
      "state"
    ]
  },
  {
    "operations": {
      "checkTransition": 1,
      "or": 1,
      "oclIsTypeOf": 4,
      "and": 4,
      "selectByType": 1,
      "isEmpty": 2,
      "includes": 2,
      "asSet": 6,
      "notEmpty": 5,
      "oclAsType": 5,
      "=": 2,
      "containingStateMachine": 4
    },
    "body": "if it.source.oclIsTypeOf(uml::Pseudostate).and(it.source.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::entryPoint)) then if it.containingStateMachine().submachineState->collect(temp1 : State | temp1.connection)->one(temp2 : ConnectionPointReference | temp2.entry->includes(it.source)) then let icpr : ConnectionPointReference = it.containingStateMachine().submachineState->collect(temp3 : State | temp3.connection)->any(temp4 : ConnectionPointReference | temp4.entry->includes(it.source)) in if icpr.incoming->isEmpty().or(icpr.incoming->collect(temp5 : Transition | temp5.source)->isEmpty()) then Set {null}->asSet() else icpr.incoming->select(temp6 : Transition | Set {temp6.source}->notEmpty())->collect(temp7 : Transition | getTransitionBeginExtend(temp7)) endif else Set {null}->asSet() endif else if it.source.oclIsTypeOf(uml::Pseudostate).and(it.source.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::initial)) then if it.containingStateMachine().submachineState->notEmpty() then getTransitionBeginExtend(it.containingStateMachine().submachineState->collect(temp8 : State | temp8.incoming)->select(temp9 : Transition | temp9.checkTransition())->any(temp10 : Transition | true)) else Set {null}->asSet() endif else if it.source.oclIsTypeOf(uml::ConnectionPointReference).and(it.source.oclAsType(uml::ConnectionPointReference).exit->notEmpty()) then let ips : Collection(Pseudostate) = it.source.oclAsType(uml::ConnectionPointReference).exit in ips->collect(temp11 : Pseudostate | temp11.incoming)->select(temp12 : Transition | Set {temp12.source}->notEmpty())->collect(temp13 : Transition | getTransitionBeginExtend(temp13)) else if it.source.oclIsTypeOf(uml::State).and(it.source.oclAsType(uml::State).region->collect(temp14 : Region | temp14.ownedMember)->selectByType(uml::State)->notEmpty()) then if isCompositeStateWithoutInitial(it.source) then Set {it}->asSet() else Set {null}->asSet() endif else Set {it}->asSet() endif endif endif endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 14,
      "VariableExpImpl": 35,
      "OperationCallExpImpl": 37,
      "LetExpImpl": 2,
      "NullLiteralExpImpl": 4,
      "QueryInvocationSpec": 4,
      "EnumLiteralExpImpl": 2,
      "TypeExpImpl": 10,
      "CollectionLiteralExpImpl": 8,
      "IfExpImpl": 8,
      "PropertyCallExpImpl": 34,
      "BooleanLiteralExpImpl": 1
    },
    "properties": [
      "entry",
      "kind",
      "submachineState",
      "exit",
      "ownedMember",
      "region",
      "incoming",
      "connection",
      "source"
    ]
  },
  {
    "operations": {
      "union": 1,
      "asSet": 2,
      "notEmpty": 2
    },
    "body": "if aStateMachine.submachineState->notEmpty() then aStateMachine.submachineState->collect(temp1 : State | temp1.incoming)->select(temp2 : Transition | checkTransition(temp2))->union(aStateMachine.submachineState->collect(temp3 : State | temp3.connection)->select(temp4 : ConnectionPointReference | temp4.entry->notEmpty())->collect(temp5 : ConnectionPointReference | temp5.incoming)->select(temp6 : Transition | checkTransition(temp6)))->asSet() else Set {null}->asSet() endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 6,
      "VariableExpImpl": 9,
      "OperationCallExpImpl": 5,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 2,
      "CollectionLiteralExpImpl": 1,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 7
    },
    "properties": [
      "entry",
      "submachineState",
      "incoming",
      "connection"
    ]
  },
  {
    "operations": {
      "isEmpty": 1,
      "includes": 2,
      "union": 1,
      "notEmpty": 1,
      "asSet": 2,
      "containingStateMachine": 2
    },
    "body": "if Set {is.submachine}->isEmpty() then is.containingStateMachine().region->collect(temp1 : Region | getAllTransitionInRegion(temp1))->select(temp2 : Transition | checkTransition(temp2))->select(temp3 : Transition | getVertexWhetherNesting(temp3.source)->includes(is))->asSet() else is.containingStateMachine().region->collect(temp4 : Region | getAllTransitionInRegion(temp4))->select(temp5 : Transition | checkTransition(temp5))->select(temp6 : Transition | getVertexWhetherNesting(temp6.source)->includes(is))->union(is.connection->select(temp7 : ConnectionPointReference | temp7.exit->notEmpty())->collect(temp8 : ConnectionPointReference | temp8.outgoing)->select(temp9 : Transition | checkTransition(temp9)))->asSet() endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 9,
      "OperationCallExpImpl": 9,
      "VariableExpImpl": 15,
      "QueryInvocationSpec": 7,
      "CollectionLiteralExpImpl": 1,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 8
    },
    "properties": [
      "exit",
      "outgoing",
      "connection",
      "region",
      "source",
      "submachine"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "and": 1,
      "notEmpty": 1,
      "oclAsType": 1
    },
    "body": "if it.source.oclIsTypeOf(uml::ConnectionPointReference).and(it.source.oclAsType(uml::ConnectionPointReference).exit->notEmpty()) then true else false endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 4,
      "VariableExpImpl": 2,
      "TypeExpImpl": 2,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 3,
      "BooleanLiteralExpImpl": 2
    },
    "properties": [
      "exit",
      "source"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "+": 1,
      "notEmpty": 1,
      "oclAsType": 1
    },
    "body": "if it.source.oclIsTypeOf(uml::State) then let state : State = it.source.oclAsType(uml::State) in if isCompositeStateWithoutInitial(state) then state.name.+('から') else if Set {state.submachine}->notEmpty() then state.name else getLsName(state) endif endif else it.source.name endif",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 8,
      "OperationCallExpImpl": 4,
      "LetExpImpl": 1,
      "QueryInvocationSpec": 2,
      "TypeExpImpl": 2,
      "StringLiteralExpImpl": 1,
      "CollectionLiteralExpImpl": 1,
      "IfExpImpl": 3,
      "PropertyCallExpImpl": 7
    },
    "properties": [
      "name",
      "source",
      "submachine"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "notEmpty": 1,
      "oclAsType": 1,
      "containingStateMachine": 2
    },
    "body": "if it.source.oclIsTypeOf(uml::State) then let state : State = it.source.oclAsType(uml::State) in if Set {state.submachine}->notEmpty() then state.submachine.name else state.containingStateMachine().name endif else it.source.containingStateMachine().name endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 5,
      "VariableExpImpl": 6,
      "LetExpImpl": 1,
      "TypeExpImpl": 2,
      "CollectionLiteralExpImpl": 1,
      "IfExpImpl": 2,
      "PropertyCallExpImpl": 8
    },
    "properties": [
      "name",
      "source",
      "submachine"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "notEmpty": 1,
      "oclAsType": 1
    },
    "body": "if it.source.oclIsTypeOf(uml::State) then let state : State = it.source.oclAsType(uml::State) in if isCompositeStateWithoutInitial(state) then 'otherIncoming' else if Set {state.submachine}->notEmpty() then 'otherIncoming' else 'exitPointIncoming' endif endif else 'otherIncoming' endif",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 4,
      "OperationCallExpImpl": 3,
      "LetExpImpl": 1,
      "QueryInvocationSpec": 1,
      "StringLiteralExpImpl": 4,
      "TypeExpImpl": 2,
      "CollectionLiteralExpImpl": 1,
      "IfExpImpl": 3,
      "PropertyCallExpImpl": 3
    },
    "properties": [
      "source",
      "submachine"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "selectByType": 3,
      "notEmpty": 3,
      "oclAsType": 1,
      "=": 1
    },
    "body": "if iv.oclIsTypeOf(uml::State) then let state : State = iv.oclAsType(uml::State) in if state.region->collect(temp1 : Region | temp1.ownedMember)->selectByType(uml::State)->notEmpty() then if state.region->collect(temp2 : Region | temp2.ownedMember)->selectByType(uml::Pseudostate)->notEmpty() then let c : Collection(Pseudostate) = state.region->collect(temp3 : Region | temp3.ownedMember)->selectByType(uml::Pseudostate) in if c->select(temp4 : Pseudostate | temp4.kind.=(uml::PseudostateKind::initial))->notEmpty() then true else false endif else false endif else false endif else false endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 4,
      "VariableExpImpl": 10,
      "OperationCallExpImpl": 9,
      "LetExpImpl": 2,
      "EnumLiteralExpImpl": 1,
      "TypeExpImpl": 5,
      "IfExpImpl": 4,
      "PropertyCallExpImpl": 7,
      "BooleanLiteralExpImpl": 5
    },
    "properties": [
      "kind",
      "ownedMember",
      "region"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 2,
      "selectByType": 2,
      "and": 3,
      "includes": 2,
      "notEmpty": 5,
      "oclAsType": 3,
      "=": 2,
      "containingStateMachine": 2
    },
    "body": "if it.target.oclIsTypeOf(uml::Pseudostate).and(it.target.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::exitPoint)) then if it.containingStateMachine().submachineState->collect(temp1 : State | temp1.connection)->one(temp2 : ConnectionPointReference | temp2.exit->includes(it.target)) then let icpr : ConnectionPointReference = it.containingStateMachine().submachineState->collect(temp3 : State | temp3.connection)->any(temp4 : ConnectionPointReference | temp4.exit->includes(it.target)) in if icpr.outgoing->notEmpty().and(icpr.outgoing->collect(temp5 : Transition | temp5.target)->notEmpty()) then getTransitionEnd(icpr.outgoing->any(temp6 : Transition | Set {temp6.target}->notEmpty())) else null endif else null endif else if it.target.oclIsTypeOf(uml::State).and(it.target.oclAsType(uml::State).region->collect(temp7 : Region | temp7.ownedMember)->selectByType(uml::State)->notEmpty()) then if isCompositeStateWithoutInitial(it.target) then let is : State = it.target.oclAsType(uml::State) in getTransitionEnd(is.region->collect(temp8 : Region | temp8.subvertex)->selectByType(uml::Pseudostate)->select(temp9 : Pseudostate | temp9.kind.=(uml::PseudostateKind::initial))->collect(temp10 : Pseudostate | temp10.outgoing)->any(temp11 : Transition | Set {temp11.target}->notEmpty())) else null endif else it endif endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 11,
      "VariableExpImpl": 26,
      "OperationCallExpImpl": 21,
      "LetExpImpl": 2,
      "NullLiteralExpImpl": 3,
      "QueryInvocationSpec": 3,
      "EnumLiteralExpImpl": 2,
      "TypeExpImpl": 7,
      "CollectionLiteralExpImpl": 2,
      "IfExpImpl": 5,
      "PropertyCallExpImpl": 27
    },
    "properties": [
      "kind",
      "submachineState",
      "exit",
      "ownedMember",
      "outgoing",
      "region",
      "target",
      "connection",
      "subvertex"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "notEmpty": 1,
      "oclAsType": 2
    },
    "body": "if it.target.oclIsTypeOf(uml::ConnectionPointReference) then if it.target.oclAsType(uml::ConnectionPointReference).entry->notEmpty() then it.target.oclAsType(uml::ConnectionPointReference).state.name else null endif else it.target.name endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 4,
      "VariableExpImpl": 4,
      "NullLiteralExpImpl": 1,
      "TypeExpImpl": 3,
      "IfExpImpl": 2,
      "PropertyCallExpImpl": 8
    },
    "properties": [
      "entry",
      "state",
      "name",
      "target"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "and": 1,
      "oclAsType": 1,
      "=": 1
    },
    "body": "if aTransition.source.oclIsTypeOf(uml::Pseudostate).and(aTransition.source.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::choice)) then aTransition.source.incoming->collect(temp1 : Transition | ignoreChoiceOutgoing(temp1)) else aTransition endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 1,
      "OperationCallExpImpl": 4,
      "VariableExpImpl": 5,
      "QueryInvocationSpec": 1,
      "EnumLiteralExpImpl": 1,
      "TypeExpImpl": 2,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 5
    },
    "properties": [
      "kind",
      "incoming",
      "source"
    ]
  },
  {
    "operations": {"replaceAll": 3},
    "body": "aString.replaceAll('\r\n|\r|\n', '\\\\r\\\\n').replaceAll('\\'', '\\\\\\'').replaceAll('\\\"', '\\\\\\\"')",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 3,
      "VariableExpImpl": 1,
      "StringLiteralExpImpl": 6
    },
    "properties": []
  },
  {
    "operations": {"replaceAll": 1},
    "body": "aString.replaceAll('<S_[AUD]_[01]\\|.*?>', '')",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 1,
      "OperationCallExpImpl": 1,
      "StringLiteralExpImpl": 2
    },
    "properties": []
  },
  {
    "operations": {"replaceAll": 3},
    "body": "aString.replaceAll('\r\n|\r|\n', '\\\\r').replaceAll('\\'', '\\\\\\'').replaceAll('\\\"', '\\\\\\\"')",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 3,
      "VariableExpImpl": 1,
      "StringLiteralExpImpl": 6
    },
    "properties": []
  },
  {
    "operations": {
      "size": 1,
      "index": 1,
      "+": 1,
      "=": 1,
      "-": 1,
      "substring": 1
    },
    "body": "let prefixIndex : Integer = aString.index('resources/img/') in if prefixIndex.=(1.-()) then aString else aString.substring(prefixIndex.+('resources/img/'.size())) endif",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 5,
      "OperationCallExpImpl": 6,
      "LetExpImpl": 1,
      "IntegerLiteralExpImpl": 1,
      "StringLiteralExpImpl": 2,
      "IfExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {
      "+": 1,
      "replaceAll": 4
    },
    "body": "aString.replaceAll('\t', '    ').replaceAll('\\\\', '\\\\\\\\').replaceAll('\"', '\\\"').replaceAll(''', '\\'.+('''))",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 5,
      "VariableExpImpl": 1,
      "StringLiteralExpImpl": 9
    },
    "properties": []
  },
  {
    "operations": {"replaceAll": 4},
    "body": "aString.replaceAll('\t', '_').replaceAll('\"', '_').replaceAll('/', '_').replaceAll('\\\\', '_')",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 4,
      "VariableExpImpl": 1,
      "StringLiteralExpImpl": 8
    },
    "properties": []
  },
  {
    "operations": {},
    "body": "if specTransitionCheck(getTransitionEnd(it)) then getSelfTransSpecValue(getTransitionEnd(it)) else escapeText(otherEscapeText(getExpectValue(getTransitionEnd(it)))) endif",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 3,
      "QueryInvocationSpec": 8,
      "IfExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "and": 1,
      "notEmpty": 2,
      "oclAsType": 1,
      "=": 2
    },
    "body": "if Set {it.ownedRule->any(temp1 : Constraint | temp1.name.=('info'))}->notEmpty() then let ic : Constraint = it.ownedRule->any(temp2 : Constraint | temp2.name.=('info')) in if Set {ic.specification}->notEmpty().and(ic.specification.oclIsTypeOf(uml::LiteralString)) then let ils : LiteralString = ic.specification.oclAsType(uml::LiteralString) in escapeText(otherEscapeText(ils.value)) else null endif else null endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 2,
      "OperationCallExpImpl": 7,
      "VariableExpImpl": 8,
      "LetExpImpl": 2,
      "NullLiteralExpImpl": 2,
      "QueryInvocationSpec": 2,
      "TypeExpImpl": 2,
      "StringLiteralExpImpl": 2,
      "CollectionLiteralExpImpl": 2,
      "IfExpImpl": 2,
      "PropertyCallExpImpl": 8
    },
    "properties": [
      "value",
      "name",
      "ownedRule",
      "specification"
    ]
  },
  {
    "operations": {
      "or": 1,
      "oclIsTypeOf": 1,
      "and": 1,
      "notEmpty": 1,
      "=": 1,
      "oclAsType": 1
    },
    "body": "if it.target.oclIsTypeOf(uml::State).and(it.target.oclAsType(uml::State).region->notEmpty()).or(it.source.=(it.target)) then true else false endif",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 4,
      "OperationCallExpImpl": 6,
      "TypeExpImpl": 2,
      "IfExpImpl": 1,
      "PropertyCallExpImpl": 5,
      "BooleanLiteralExpImpl": 2
    },
    "properties": [
      "region",
      "target",
      "source"
    ]
  },
  {
    "operations": {"invoke": 1},
    "body": "self.invoke('com.iauto.mist.spec.m2t.uml2html.util.utils', 'xmlID(org.eclipse.uml2.uml.Element)', Sequence {e})",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 2,
      "OperationCallExpImpl": 1,
      "StringLiteralExpImpl": 2,
      "CollectionLiteralExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {
      "getModel": 3,
      "<>": 2,
      "at": 3,
      "and": 1,
      "selectByType": 4,
      "notEmpty": 1,
      "asSequence": 3
    },
    "body": "if aModel.ownedMember->selectByType(uml::StateMachine)->collect(temp1 : StateMachine | temp1.submachineState)->notEmpty() then if aModel.ownedMember->selectByType(uml::StateMachine)->collect(temp2 : StateMachine | temp2.submachineState)->asSequence()->at(1).getModel().<>(null).and(aModel.ownedMember->selectByType(uml::StateMachine)->collect(temp3 : StateMachine | temp3.submachineState)->asSequence()->at(1).getModel().<>(aModel)) then getTopModel(aModel.ownedMember->selectByType(uml::StateMachine)->collect(temp4 : StateMachine | temp4.submachineState)->asSequence()->at(1).getModel()) else aModel endif else aModel endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 4,
      "VariableExpImpl": 11,
      "OperationCallExpImpl": 17,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 1,
      "IntegerLiteralExpImpl": 3,
      "TypeExpImpl": 4,
      "IfExpImpl": 2,
      "PropertyCallExpImpl": 8
    },
    "properties": [
      "submachineState",
      "ownedMember"
    ]
  },
  {
    "operations": {"equalsIgnoreCase": 1},
    "body": "if aString.equalsIgnoreCase('AppCloseWarning') then 'アプリ終了' else aString endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 1,
      "VariableExpImpl": 2,
      "StringLiteralExpImpl": 2,
      "IfExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {
      "<>": 3,
      "oclIsTypeOf": 2,
      "and": 4,
      "notEmpty": 2,
      "oclAsType": 2
    },
    "body": "if Set {is.stateInvariant}->notEmpty().and(is.stateInvariant.oclIsTypeOf(uml::Constraint)) then let ic : Constraint = is.stateInvariant.oclAsType(uml::Constraint) in if Set {ic.specification}->notEmpty().and(ic.specification.oclIsTypeOf(uml::LiteralString)) then let ils : LiteralString = ic.specification.oclAsType(uml::LiteralString) in if ils.name.<>(null).and(ils.name.<>('')).and(ils.name.<>('constraintSpec')) then ils.name else is.name endif else is.name endif else is.name endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 13,
      "VariableExpImpl": 13,
      "LetExpImpl": 2,
      "NullLiteralExpImpl": 1,
      "TypeExpImpl": 4,
      "StringLiteralExpImpl": 2,
      "CollectionLiteralExpImpl": 2,
      "IfExpImpl": 3,
      "PropertyCallExpImpl": 13
    },
    "properties": [
      "stateInvariant",
      "name",
      "specification"
    ]
  },
  {
    "operations": {
      "<>": 3,
      "oclIsTypeOf": 2,
      "and": 4,
      "notEmpty": 2,
      "oclAsType": 2
    },
    "body": "if Set {is.stateInvariant}->notEmpty().and(is.stateInvariant.oclIsTypeOf(uml::Constraint)) then let ic : Constraint = is.stateInvariant.oclAsType(uml::Constraint) in if Set {ic.specification}->notEmpty().and(ic.specification.oclIsTypeOf(uml::LiteralString)) then let ils : LiteralString = ic.specification.oclAsType(uml::LiteralString) in if ils.name.<>(null).and(ils.name.<>('')).and(ils.name.<>('constraintSpec')) then ils.name else appCloseWarningChange(is.name) endif else appCloseWarningChange(is.name) endif else appCloseWarningChange(is.name) endif",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 13,
      "OperationCallExpImpl": 13,
      "LetExpImpl": 2,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 3,
      "StringLiteralExpImpl": 2,
      "TypeExpImpl": 4,
      "CollectionLiteralExpImpl": 2,
      "IfExpImpl": 3,
      "PropertyCallExpImpl": 13
    },
    "properties": [
      "stateInvariant",
      "name",
      "specification"
    ]
  },
  {
    "operations": {
      "<>": 2,
      "oclIsTypeOf": 2,
      "and": 3,
      "+": 1,
      "notEmpty": 2,
      "=": 3,
      "oclAsType": 2
    },
    "body": "if Set {is.ownedRule->any(temp1 : Constraint | temp1.name.=('id'))}->notEmpty().and(is.ownedRule->any(temp2 : Constraint | temp2.name.=('id')).oclIsTypeOf(uml::Constraint)) then let ic : Constraint = is.ownedRule->any(temp3 : Constraint | temp3.name.=('id')).oclAsType(uml::Constraint) in if Set {ic.specification}->notEmpty().and(ic.specification.oclIsTypeOf(uml::LiteralString)) then let ils : LiteralString = ic.specification.oclAsType(uml::LiteralString) in if ils.value.<>(null).and(ils.value.<>('')) then ils.value.+(' ') else '' endif else '' endif else '' endif",
    "type": "QueryExpression",
    "constructs": {
      "IteratorExpImpl": 3,
      "OperationCallExpImpl": 15,
      "VariableExpImpl": 12,
      "LetExpImpl": 2,
      "NullLiteralExpImpl": 1,
      "StringLiteralExpImpl": 8,
      "TypeExpImpl": 4,
      "CollectionLiteralExpImpl": 2,
      "IfExpImpl": 3,
      "PropertyCallExpImpl": 12
    },
    "properties": [
      "value",
      "name",
      "ownedRule",
      "specification"
    ]
  },
  {
    "operations": {"invoke": 1},
    "body": "self.invoke('com.iauto.mist.spec.common.plugin.util.AtlDataTracker', 'getCommonQueryMajorId(org.eclipse.uml2.uml.State)', Sequence {is})",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 1,
      "VariableExpImpl": 2,
      "StringLiteralExpImpl": 2,
      "CollectionLiteralExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {
      "oclIsTypeOf": 5,
      "and": 3,
      "oclAsType": 5,
      "=": 3
    },
    "body": "if it.target.oclIsTypeOf(uml::State) then let is : State = it.target.oclAsType(uml::State) in getMajorIdByPageFile(is) else if it.target.oclIsTypeOf(uml::Pseudostate).and(it.target.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::shallowHistory)) then it.target.name else if it.target.oclIsTypeOf(uml::Pseudostate).and(it.target.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::terminate)) then 'アプリ終了' else if it.target.oclIsTypeOf(uml::Pseudostate).and(it.target.oclAsType(uml::Pseudostate).kind.=(uml::PseudostateKind::choice)) then it.target.name else if it.target.oclIsTypeOf(uml::ConnectionPointReference) then let is : State = it.target.oclAsType(uml::ConnectionPointReference).state in getMajorIdByPageFile(is) else null endif endif endif endif endif",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 14,
      "OperationCallExpImpl": 16,
      "LetExpImpl": 2,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 2,
      "EnumLiteralExpImpl": 3,
      "TypeExpImpl": 10,
      "StringLiteralExpImpl": 1,
      "IfExpImpl": 5,
      "PropertyCallExpImpl": 18
    },
    "properties": [
      "kind",
      "state",
      "name",
      "target"
    ]
  },
  {
    "operations": {
      "oclIsTypeOf": 1,
      "notEmpty": 1,
      "oclAsType": 1,
      "containingStateMachine": 2
    },
    "body": "if it.target.oclIsTypeOf(uml::State) then let is : State = it.target.oclAsType(uml::State) in if Set {is.submachine}->notEmpty() then is.submachine.name else is.containingStateMachine().name endif else it.target.containingStateMachine().name endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 5,
      "VariableExpImpl": 6,
      "LetExpImpl": 1,
      "TypeExpImpl": 2,
      "CollectionLiteralExpImpl": 1,
      "IfExpImpl": 2,
      "PropertyCallExpImpl": 8
    },
    "properties": [
      "name",
      "target",
      "submachine"
    ]
  },
  {
    "operations": {
      "<>": 1,
      "replaceAll": 1
    },
    "body": "if s.<>(null) then s.replaceAll('<S_[AUD]_[01]\\|.*?>', '') else '' endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 2,
      "VariableExpImpl": 2,
      "NullLiteralExpImpl": 1,
      "StringLiteralExpImpl": 3,
      "IfExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {"<>": 1},
    "body": "if s.<>(null) then escapeText(otherEscapeText(removeRevisionFormat(s))) else '' endif",
    "type": "QueryExpression",
    "constructs": {
      "VariableExpImpl": 2,
      "OperationCallExpImpl": 1,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 3,
      "StringLiteralExpImpl": 1,
      "IfExpImpl": 1
    },
    "properties": []
  },
  {
    "operations": {"<>": 1},
    "body": "if s.<>(null) then escapeText(otherEscapeText(s)) else '' endif",
    "type": "QueryExpression",
    "constructs": {
      "OperationCallExpImpl": 1,
      "VariableExpImpl": 2,
      "NullLiteralExpImpl": 1,
      "QueryInvocationSpec": 2,
      "StringLiteralExpImpl": 1,
      "IfExpImpl": 1
    },
    "properties": []
  }
]
