[comment encoding = UTF-8 /]
[** Copyright (C) 2016  Tatiana Person Montero

This program is free software: you can redistribute it and/or modify
it under the terms of the Eclipse Public License as published by
the Eclipse Software Foundation, either version 1 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
Eclipse Public License for more details.

You should have received a copy of the Eclipse Public License
along with this program.  If not, see <https://www.eclipse.org/legal/epl-v10.html>*/]

[module generateSonarGrammar('http://www.eclipse.org/2008/Xtext')]
[import Xtext2SonarM2T::main::utilTemplateRename /]
[import Xtext2SonarM2T::main::utilTemplateCompare /]

[**
 * The documentation of the template SonarGrammarImpl.
 * @param aGrammar
 */]
[template public SonarGrammarImpl(aGrammar : Grammar)]
[comment @main /]
[if (not aGrammar.name.contains('Terminals'))]
[let grammarName: String = aGrammar.name.replaceAll('[a-zA-Z0-9]+\\.', '')]
[file (grammarName.concat('Impl.java'), false, 'UTF-8')]
package org.sonar.[grammarName/].api;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.sonar.sslr.api.Grammar;
import org.sonar.sslr.grammar.GrammarRuleKey;
import org.sonar.[grammarName/].[grammarName/]Configuration;
import org.sonar.sslr.grammar.LexerfulGrammarBuilder;
import static com.sonar.sslr.api.GenericTokenType.IDENTIFIER;
import static org.sonar.[grammarName/].api.[grammarName/]TokenType.NUMBER;
import static org.sonar.[grammarName/].api.[grammarName/]TokenType.STRING;
import static org.sonar.[grammarName/].api.[grammarName/]TokenType.CHARACTER;
[for(rule : TerminalRule | aGrammar.eAllContents(xtext::TerminalRule))]
 	[if((rule.name.toUpper().equalsIgnoreCase('NUMBER') <> true)._and(rule.name.toUpper().equalsIgnoreCase('STRING') <> true)._and(rule.name.toUpper().equalsIgnoreCase('CHARACTER') <> true))]
import static org.sonar.[grammarName/].api.[grammarName/]TokenType.[rule.name/];
	[/if]
[/for]

public enum [grammarName.concat('Impl').toUpperFirst()/] implements GrammarRuleKey {
	[for(enum: EnumRule | aGrammar.eAllContents(xtext::EnumRule))]
	[enum.name.toUpper()/],
	[/for]
	[for (nameRule : String | aGrammar.eAllContents(xtext::ParserRule).name)]
	[comment The nameRule is not a name of TokenRule /]
	 [if((nameRule.toUpper().equalsIgnoreCase('NUMBER') <> true)._and(nameRule.toUpper().equalsIgnoreCase('STRING') <> true)._and(nameRule.toUpper().equalsIgnoreCase('CHARACTER') <> true))]
		[if((i = aGrammar.eAllContents(xtext::ParserRule)->size() - 1)._and((aGrammar.eAllContents(xtext::ParserRule)->last().name.toUpper().equalsIgnoreCase('NUMBER') = true)
			._or(aGrammar.eAllContents(xtext::ParserRule)->last().name.toUpper().equalsIgnoreCase('STRING') = true)._or(aGrammar.eAllContents(xtext::ParserRule)->last().name.toUpper().equalsIgnoreCase('CHARACTER') = true)))]
	[nameRule.toUpper()/];
		[elseif(not(i = aGrammar.eAllContents(xtext::ParserRule)->size()))]
	[nameRule.toUpper()/],
		[else]
	[nameRule.toUpper()/];
		[/if]
	[/if]
	[/for]

	public static final Logger LOG = LoggerFactory.getLogger("[grammarName.concat('Impl').toUpperFirst()/]");

	public static Grammar create([grammarName.concat('Configuration')/] conf) {
		 LexerfulGrammarBuilder b = LexerfulGrammarBuilder.create();

		 generate(b);
		[comment --- The first rule is the main rule of the Xtext grammar./]
		 b.setRootRule([aGrammar.rules->at(1).name.toUpper()/]);

		 return b.buildWithMemoizationOfMatchesForAllRules();
	}

	private static void generate(LexerfulGrammarBuilder b) {
		[comment --- First, the Terminal rules./]
		[for(terminal: TerminalRule | aGrammar.eAllContents(xtext::TerminalRule))] [comment The terminal ID of Xtext is changed for com.sonar.sslr.api.GenericTokenType.IDENTIFIER./]
		b.rule([terminal.name/]).is([if((terminal.type.classifier.name = 'EString')._and(terminal.name = 'ID'))]b.firstOf(b.isOneOfThem(com.sonar.sslr.api.GenericTokenType.IDENTIFIER, com.sonar.sslr.api.GenericTokenType.IDENTIFIER),"|", ".")[elseif((terminal.type.classifier.name = 'EString')._and(terminal.name <> 'ID'))]b.isOneOfThem(STRING, STRING)[else]b.isOneOfThem(NUMBER, NUMBER)[/if]);
		[/for]
		[comment --- Second, the Enum rules. /]
		[for(enum: EnumRule | aGrammar.eAllContents(xtext::EnumRule))]
		b.rule([enum.name.toUpper()/]).is(
			[for(literal: EnumLiteralDeclaration | enum.eAllContents(xtext::EnumLiteralDeclaration))]
				[if(i = 1)]
			b.firstOf(b.isOneOfThem([grammarName.concat('Keyword').toUpperFirst()/].[literal.literal.value.renameKeywordWithSpecialCharacterTemplate().toUpper()/], [grammarName.concat('Keyword').toUpperFirst()/].[literal.literal.value.renameKeywordWithSpecialCharacterTemplate().toUpper()/]),
				[elseif(i = enum.eAllContents(xtext::EnumLiteralDeclaration)->size())]
			b.isOneOfThem([grammarName.concat('Keyword').toUpperFirst()/].[literal.literal.value.renameKeywordWithSpecialCharacterTemplate().toUpper()/], [grammarName.concat('Keyword').toUpperFirst()/].[literal.literal.value.renameKeywordWithSpecialCharacterTemplate().toUpper()/])
				[else]
			b.isOneOfThem([grammarName.concat('Keyword').toUpperFirst()/].[literal.literal.value.renameKeywordWithSpecialCharacterTemplate().toUpper()/], [grammarName.concat('Keyword').toUpperFirst()/].[literal.literal.value.renameKeywordWithSpecialCharacterTemplate().toUpper()/]),
				[/if]
			[/for]
		));
		[/for]
		[comment --- We select the ParserRules because are the rules that define the rule grammar in Xtext./]
		[for(rule : ParserRule | aGrammar.eAllContents(xtext::ParserRule))]
			[comment --- We ignore the first because is the top rule./]
			[if((i <> 1)._and(rule.eAllContents(xtext::RuleCall)->size() = 1)._and(rule.eAllContents(xtext::Keyword)->size() = 0)._and(rule.name.toUpper() <> 'ESTRING')._and(rule.name.toUpper() <> 'NUMBER')._and(rule.name.toUpper() <> 'STRING')._and(rule.name.toUpper() <> 'EINT')._and(rule.name.toUpper() <> 'EFLOAT'))]
				[if(rule.eAllContents(xtext::RuleCall)->at(1).rule.name.toUpper() = 'ESTRING')]
		b.rule([rule.name.toUpper()/]).is(b.isOneOfThem(STRING, STRING));
				[elseif((rule.eAllContents(xtext::RuleCall)->at(1).rule.name.toUpper() = 'EINT')._or(rule.eAllContents(xtext::RuleCall)->at(1).rule.name.toUpper() = 'NUMBER')._or(rule.eAllContents(xtext::RuleCall)->at(1).rule.name.toUpper() = 'EFLOAT'))]
		b.rule([rule.name.toUpper()/]).is(b.isOneOfThem(NUMBER, NUMBER));
				[elseif(rule.eAllContents(xtext::RuleCall)->at(1).rule.name.toUpper() = 'ID')]
		b.rule([rule.name.toUpper()/]).is(b.isOneOfThem(IDENTIFIER, IDENTIFIER));
				[else]
					[if(rule.eAllContents(xtext::RuleCall)->at(1).rule.oclIsKindOf(xtext::TerminalRule))]
		b.rule([rule.name.toUpper()/]).is(b.isOneOfThem([rule.eAllContents(xtext::RuleCall)->at(1).rule.name.toUpper()/], [rule.eAllContents(xtext::RuleCall)->at(1).rule.name.toUpper()/]));
					[else]
		b.rule([rule.name.toUpper()/]).is([rule.eAllContents(xtext::RuleCall)->at(1).rule.name.toUpper()/]);
					[/if]
				[/if]
			[elseif(rule.name.toUpper() <> 'ESTRING')._and(rule.name.toUpper() <> 'NUMBER')._and(rule.name.toUpper() <> 'STRING')._and(rule.name.toUpper() <> 'EINT')._and(rule.name.toUpper() <> 'EFLOAT')]
				[let size: Integer = rule.eAllContents(xtext::AbstractElement)->size()]

		b.rule([rule.name.toUpper()/]).is(
		[comment --- If there are only alternatives is a selection rule./]
					[if((rule.eAllContents(xtext::AbstractElement)->first().oclIsKindOf(xtext::Alternatives) = false)
					._and(((rule.eAllContents(xtext::AbstractElement)->size() > 1)._and(rule.eAllContents(xtext::AbstractElement)->first().oclIsKindOf(xtext::Assignment)._and(rule.eAllContents(xtext::AbstractElement)->at(2).oclIsKindOf(xtext::Alternatives)))) = false)
					._and((rule.eAllContents(xtext::Keyword)->size() + rule.eAllContents(xtext::RuleCall)->size()) > 1))]
		b.sequence([/if]
					[comment --- In this case, we caught all elements and processing them./]
					[for(element : AbstractElement | rule.eAllContents(xtext::AbstractElement))]
						[comment Creating variables./]
						[let isOptionalLastChild: Boolean = ((element.ancestors(xtext::Group)->size() <> 0)._and(element.ancestors(xtext::Group)->first().cardinality = '?')._and(element.ancestors(xtext::Group)->first().eAllContents(xtext::AbstractElement)->last() = element))]
						[if(element.oclIsKindOf(xtext::Group)._and(element.oclAsType(xtext::Group).cardinality = '?')
							._and(element.oclAsType(xtext::Group).ancestors(xtext::Alternatives)->size() = 0)
							._and(((element.oclAsType(xtext::Group).ancestors(xtext::Group)->size() >=1)._and(element.oclAsType(xtext::Group).ancestors(xtext::Group)->first().cardinality = '?') = false)
							._and(((element.oclAsType(xtext::Group).eAllContents(xtext::Group)->size() >=1)._and(element.oclAsType(xtext::Group).eAllContents(xtext::Group)->first().cardinality = null) = false))))]
		b.optional(
						[comment --- Start ALTERNATIVES or GROUP (* or + type)./]
						[elseif((element.oclIsKindOf(xtext::Alternatives)._and((element.oclAsType(xtext::Alternatives).ancestors()->first().oclIsKindOf(xtext::Group)
							._and(element.oclAsType(xtext::Alternatives).ancestors()->first().oclAsType(xtext::Group).cardinality = '*')) = false)
							._and(element.oclAsType(xtext::Alternatives).ancestors(xtext::Alternatives)->size() = 0))
						._or((element.oclIsKindOf(xtext::Group)._and(element.oclAsType(xtext::Group).cardinality = '*')
							._and(element.oclAsType(xtext::Group).ancestors(xtext::Alternatives)->size() = 0))
						._or(element.oclIsKindOf(xtext::Group)._and(element.oclAsType(xtext::Group).cardinality = '+')
							._and(element.oclAsType(xtext::Group).ancestors(xtext::Alternatives)->size() = 0))))]
							[for(elementAux : AbstractElement | element.eAllContents(xtext::AbstractElement))]
									[comment Creating variables. /]
									[let isOptionalLastChildAux: Boolean = ((elementAux.ancestors(xtext::Group)->size() <> 0)._and(elementAux.ancestors(xtext::Group)->first().cardinality = '?')._and(elementAux.ancestors(xtext::Group)->first().eAllContents(xtext::AbstractElement)->last() = elementAux)
									._or((elementAux.ancestors(xtext::Group)->size() >= 2)._and(elementAux.ancestors(xtext::Group)->at(2).cardinality = '?')._and(elementAux.ancestors(xtext::Group)->at(2).eAllContents(xtext::AbstractElement)->last() = elementAux)))]
									[comment --- The alternatives are RuleCall./]
									[if((i = 1)._and(element.oclIsKindOf(xtext::Alternatives)))]
		b.firstOf(
									[elseif((i = 1)._and(element.oclIsKindOf(xtext::Group)._and(element.oclAsType(xtext::Group).cardinality = '*')))]
		b.zeroOrMore(
									[elseif((i = 1)._and(element.oclIsKindOf(xtext::Group)._and(element.oclAsType(xtext::Group).cardinality = '+')))]
		b.oneOrMore(
									[/if]
									[if(elementAux.oclIsKindOf(xtext::Group)._and(elementAux.oclAsType(xtext::Group).cardinality = '?'))]
		b.optional(
									[/if]
									[if(elementAux.oclIsKindOf(xtext::RuleCall))]
										[comment Alternatives type = Rule1 | Rule2 | Rule3./]
										[if(((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)
											._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).eContents(xtext::CrossReference)->size() > 0))
											._or(elementAux.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'ID'))]
											[if(((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '*'))
													._or((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->at(1).cardinality = '*')))]
											[comment --- Are identifier of other classes of the metamodel./]
		b.zeroOrMore(com.sonar.sslr.api.GenericTokenType.IDENTIFIER)[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
											[elseif(((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '+'))
													._or((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->at(1).cardinality = '+')))]
		b.oneOrMore(com.sonar.sslr.api.GenericTokenType.IDENTIFIER)[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
											[else]
		com.sonar.sslr.api.GenericTokenType.IDENTIFIER[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
										[/if]
										[elseif(elementAux.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'ESTRING')]
												[if(((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '*'))
													._or((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->at(1).cardinality = '*')))]
		b.zeroOrMore(b.isOneOfThem(STRING, STRING))[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[elseif(((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '+'))
													._or((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->at(1).cardinality = '+')))]
		b.oneOrMore(b.isOneOfThem(STRING, STRING))[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[else]
		b.isOneOfThem(STRING, STRING)[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[/if]
										[elseif((elementAux.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'EINT')._or(elementAux.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'EFLOAT')
												._or(elementAux.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'INT')._or(elementAux.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'FLOAT'))]
												[if(((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '*'))
													._or((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->at(1).cardinality = '*')))]
		b.zeroOrMore(b.isOneOfThem(NUMBER, NUMBER))[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[elseif(((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '+'))
													._or((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->at(1).cardinality = '+')))]
		b.oneOrMore(b.isOneOfThem(NUMBER, NUMBER))[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[else]
		b.isOneOfThem(NUMBER, NUMBER)[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[/if]
										[else]
												[if(((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '*'))
													._or((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->at(1).cardinality = '*')))]
		b.zeroOrMore([elementAux.oclAsType(xtext::RuleCall).rule.name.toUpper()/])[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[elseif(((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '+'))
													._or((elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::RuleCall).ancestors(xtext::Alternatives)->at(1).cardinality = '+')))]
		b.oneOrMore([elementAux.oclAsType(xtext::RuleCall).rule.name.toUpper()/])[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[else]
		[elementAux.oclAsType(xtext::RuleCall).rule.name.toUpper()/][if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[/if]	
										[/if]
									[comment --- The alternatives are Keywords./]
								 	[elseif(elementAux.oclIsKindOf(xtext::Keyword))]
										[if(elementAux.oclAsType(xtext::Keyword).value.compareKeywordTemplate().contains('true')
											._and(elementAux.oclAsType(xtext::Keyword).value.noValidCharactersTemplate().contains('false')))]
												[if(((elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->at(1).cardinality = '*'))
													._or((elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Alternatives)->at(1).cardinality = '*')))]
		b.zeroOrMore(b.isOneOfThem([grammarName.concat('Punctuator').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/], [grammarName.concat('Punctuator').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/]))[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[elseif(((elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->at(1).cardinality = '*'))
													._or((elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Alternatives)->at(1).cardinality = '*')))]
		b.oneOrMore(b.isOneOfThem([grammarName.concat('Punctuator').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/], [grammarName.concat('Punctuator').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/]))[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[else]
		b.isOneOfThem([grammarName.concat('Punctuator').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/], [grammarName.concat('Punctuator').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/])[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[/if]
										[elseif(elementAux.oclAsType(xtext::Keyword).value.compareKeywordTemplate().contains('false')
											._and(elementAux.oclAsType(xtext::Keyword).value.noValidCharactersTemplate().contains('false')))]
												[if(((elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->at(1).cardinality = '*'))
													._or((elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Alternatives)->at(1).cardinality = '*')))]
		b.zeroOrMore(b.isOneOfThem([grammarName.concat('Keyword').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/], [grammarName.concat('Keyword').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/]))[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[elseif(((elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() > 0)
													._and(elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->at(1).cardinality = '*'))
													._or((elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Alternatives)->size() > 0)
													._and(elementAux.oclAsType(xtext::Keyword).ancestors(xtext::Alternatives)->at(1).cardinality = '*')))]
		b.oneOrMore(b.isOneOfThem([grammarName.concat('Keyword').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/], [grammarName.concat('Keyword').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/]))[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[else]
		b.isOneOfThem([grammarName.concat('Keyword').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/], [grammarName.concat('Keyword').toUpperFirst()/].[elementAux.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/])[if(isOptionalLastChildAux = true)])[/if][if(i = 1)],[elseif((i = element.eAllContents(xtext::AbstractElement)->size())._and((rule.eAllContents(xtext::AbstractElement)->last() = elementAux) = false))]),[elseif((i = element.eAllContents(xtext::AbstractElement)->size()) = false)],[/if]
												[/if]
										[/if]
									[/if]
									[comment Finally, close with the last element./]
									[if(element.oclIsKindOf(xtext::Alternatives))]
										[if((rule.eAllContents(xtext::AbstractElement)->last() = elementAux)
											._and((rule.eAllContents(xtext::AbstractElement)->first() = element)
											._or((element.ancestors(xtext::Assignment)->size() <> 0)
											._and(rule.eAllContents(xtext::AbstractElement)->first() = element.ancestors(xtext::Assignment)->first()))))]
		)).skipIfOneChild();
										[elseif(rule.eAllContents(xtext::AbstractElement)->last() = elementAux)]
		))).skipIfOneChild();
										[/if]
									[elseif((element.oclIsKindOf(xtext::Group)._and(element.oclAsType(xtext::Group).cardinality = '*'))
										._or(element.oclIsKindOf(xtext::Group)._and(element.oclAsType(xtext::Group).cardinality = '+')))]
										[if(rule.eAllContents(xtext::AbstractElement)->last() = elementAux)]
		)
										[/if]
									[/if]
									[/let]
							[/for]
						[comment --- End ALTERNATIVES./]
						[comment --- Start KEYWORDS./]
						[elseif((element.oclIsKindOf(xtext::Keyword))._and(element.ancestors(xtext::Alternatives)->size() = 0)
							._and(((element.ancestors()->first().oclIsKindOf(xtext::Group))._and(element.ancestors()->first().oclAsType(xtext::Group).cardinality = '*')) = false)
							._and(((element.ancestors()->first().oclIsKindOf(xtext::Group))._and(element.ancestors()->first().oclAsType(xtext::Group).cardinality = '+')) = false)
							._and(((element.ancestors()->first().oclIsKindOf(xtext::Assignment))._and(element.ancestors()->first().oclAsType(xtext::Assignment).ancestors()->first().oclIsKindOf(xtext::Group))._and(element.ancestors()->first().oclAsType(xtext::Assignment).ancestors()->first().oclAsType(xtext::Group).cardinality = '*')) = false)
							._and(((element.ancestors()->first().oclIsKindOf(xtext::Assignment))._and(element.ancestors()->first().oclAsType(xtext::Assignment).ancestors()->first().oclIsKindOf(xtext::Group))._and(element.ancestors()->first().oclAsType(xtext::Assignment).ancestors()->first().oclAsType(xtext::Group).cardinality = '+')) = false))]
							[comment --- If the Keyword is optional./]
							[if((element.oclAsType(xtext::Keyword).cardinality = '?')._or(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->first().cardinality = '?'))]
		b.optional(
							[/if]
							[comment --- Rename the special characters./]
							[if(element.oclAsType(xtext::Keyword).value.compareKeywordTemplate().contains('true')._and(element.oclAsType(xtext::Keyword).value.noValidCharactersTemplate().contains('false')))]
								[if(((element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() > 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->at(1).cardinality = '*'))._or(element.oclAsType(xtext::Keyword).cardinality = '*'))]
		b.zeroOrMore(b.isOneOfThem([grammarName.concat('Punctuator').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/], [grammarName.concat('Punctuator').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/]))[if((element.oclAsType(xtext::Keyword).cardinality = '?')._or(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->first().cardinality = '?'))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[elseif(((element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() > 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->at(1).cardinality = '+'))._or(element.oclAsType(xtext::Keyword).cardinality = '+'))]
		b.oneOrMore(b.isOneOfThem([grammarName.concat('Punctuator').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/], [grammarName.concat('Punctuator').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/]))[if((element.oclAsType(xtext::Keyword).cardinality = '?')._or(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->first().cardinality = '?'))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[else]
		b.isOneOfThem([grammarName.concat('Punctuator').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/], [grammarName.concat('Punctuator').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordSimpleTemplate()/])[if((element.oclAsType(xtext::Keyword).cardinality = '?')._or(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->first().cardinality = '?'))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[/if]
							[elseif(element.oclAsType(xtext::Keyword).value.compareKeywordTemplate().contains('false')._and(element.oclAsType(xtext::Keyword).value.noValidCharactersTemplate().contains('false')))]
								[if(((element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() > 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->at(1).cardinality = '*'))._or(element.oclAsType(xtext::Keyword).cardinality = '*'))]
		b.zeroOrMore(b.isOneOfThem([grammarName.concat('Keyword').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/], [grammarName.concat('Keyword').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/]))[if((element.oclAsType(xtext::Keyword).cardinality = '?')._or(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->first().cardinality = '?'))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[elseif(((element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() > 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->at(1).cardinality = '+'))._or(element.oclAsType(xtext::Keyword).cardinality = '+'))]
		b.oneOrMore(b.isOneOfThem([grammarName.concat('Keyword').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/], [grammarName.concat('Keyword').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/]))[if((element.oclAsType(xtext::Keyword).cardinality = '?')._or(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->first().cardinality = '?'))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[else]
		b.isOneOfThem([grammarName.concat('Keyword').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/], [grammarName.concat('Keyword').toUpperFirst()/].[element.oclAsType(xtext::Keyword).value.renameKeywordWithSpecialCharacterTemplate().toUpper()/])[if((element.oclAsType(xtext::Keyword).cardinality = '?')._or(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::Keyword).ancestors(xtext::Assignment)->first().cardinality = '?'))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[/if]
							[/if]
						[comment --- End KEYWORDS./]
						[comment --- Start RULECALLS./]
						[elseif(element.oclIsKindOf(xtext::RuleCall)._and(element.ancestors(xtext::Alternatives)->size() = 0)
							._and(((element.ancestors()->first().oclIsKindOf(xtext::Group))._and(element.ancestors()->first().oclAsType(xtext::Group).cardinality = '*')) = false)
							._and(((element.ancestors()->first().oclIsKindOf(xtext::Group))._and(element.ancestors()->first().oclAsType(xtext::Group).cardinality = '+')) = false)
							._and(((element.ancestors()->first().oclIsKindOf(xtext::Assignment))._and(element.ancestors()->first().oclAsType(xtext::Assignment).ancestors()->first().oclIsKindOf(xtext::Group))._and(element.ancestors()->first().oclAsType(xtext::Assignment).ancestors()->first().oclAsType(xtext::Group).cardinality = '*')) = false)
							._and(((element.ancestors()->first().oclIsKindOf(xtext::Assignment))._and(element.ancestors()->first().oclAsType(xtext::Assignment).ancestors()->first().oclIsKindOf(xtext::Group))._and(element.ancestors()->first().oclAsType(xtext::Assignment).ancestors()->first().oclAsType(xtext::Group).cardinality = '+')) = false))]
							[comment -- If the RuleCall is optional./]
							[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))]
		b.optional(
							[/if]
							[comment --- If have a Crossreference is a Identifier./]
							[if(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)]
								[if((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).eContents(xtext::CrossReference)->size() > 0)._or(element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'ID'))]
									[if((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '*')._or(element.oclAsType(xtext::RuleCall).cardinality = '*'))]
									[comment --- Are identifier of other classes of the metamodel./]
		b.zeroOrMore(com.sonar.sslr.api.GenericTokenType.IDENTIFIER)[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[elseif((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '+')._or(element.oclAsType(xtext::RuleCall).cardinality = '+'))]
		b.oneOrMore(com.sonar.sslr.api.GenericTokenType.IDENTIFIER)[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[else]
		com.sonar.sslr.api.GenericTokenType.IDENTIFIER[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[/if]
								[comment --- If is a EInt then is a 'NUMBER' of the lexer./]
								[elseif(((element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'EINT')._or(element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'EFLOAT')
									._or(element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'INT')._or(element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'FLOAT'))._and(element.ancestors(xtext::Alternatives)->size() = 0))]
									[if((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '*')._or(element.oclAsType(xtext::RuleCall).cardinality = '*'))]
		b.zeroOrMore(b.isOneOfThem(NUMBER, NUMBER))[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[elseif((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '+')._or(element.oclAsType(xtext::RuleCall).cardinality = '+'))]
		b.oneOrMore(b.isOneOfThem(NUMBER, NUMBER))[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[else]
		b.isOneOfThem(NUMBER, NUMBER)[if(element.oclAsType(xtext::RuleCall).cardinality = '?')])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[/if]
								[comment --- If is a EString then is a 'STRING' of the lexer./]
								[elseif((element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'ESTRING')._and(element.ancestors(xtext::Alternatives)->size() = 0))]
									[if((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '*')._or(element.oclAsType(xtext::RuleCall).cardinality = '*'))]
		b.zeroOrMore(b.isOneOfThem(STRING, STRING))[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[elseif((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '+')._or(element.oclAsType(xtext::RuleCall).cardinality = '+'))]
		b.oneOrMore(b.isOneOfThem(STRING, STRING))[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[else]
		b.isOneOfThem(STRING, STRING)[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[/if]
								[comment --- In this case, is a normal atribute of another class type./]
								[else]
									[if((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '*')._or(element.oclAsType(xtext::RuleCall).cardinality = '*'))]
		b.zeroOrMore([element.oclAsType(xtext::RuleCall).rule.name.toUpper()/])[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[elseif((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->at(1).cardinality = '+')._or(element.oclAsType(xtext::RuleCall).cardinality = '+'))]
		b.oneOrMore([element.oclAsType(xtext::RuleCall).rule.name.toUpper()/])[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[else]
		[element.oclAsType(xtext::RuleCall).rule.name.toUpper()/][if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
									[/if]
								[/if]
						[else]
							[if(element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'ID')]
								[comment --- Are identifier of other classes of the metamodel./]
		com.sonar.sslr.api.GenericTokenType.IDENTIFIER[if(element.oclAsType(xtext::RuleCall).cardinality = '?')])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
							[elseif(((element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'EINT')._or(element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'EFLOAT')
								._or(element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'INT')._or(element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'FLOAT'))._and(element.ancestors(xtext::Alternatives)->size() = 0))]
								[if(element.oclAsType(xtext::RuleCall).cardinality = '*')]
		b.zeroOrMore(b.isOneOfThem(NUMBER, NUMBER))[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[elseif(element.oclAsType(xtext::RuleCall).cardinality = '+')]
		b.oneOrMore(b.isOneOfThem(NUMBER, NUMBER))[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[else]
		b.isOneOfThem(NUMBER, NUMBER)[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[/if]
							[elseif((element.oclAsType(xtext::RuleCall).rule.name.toUpper() = 'ESTRING')._and(element.ancestors(xtext::Alternatives)->size() = 0))]
								[if(element.oclAsType(xtext::RuleCall).cardinality = '*')]
		b.zeroOrMore(b.isOneOfThem(STRING, STRING))[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[elseif(element.oclAsType(xtext::RuleCall).cardinality = '+')]
		b.oneOrMore(b.isOneOfThem(STRING, STRING))[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[else]
		b.isOneOfThem(STRING, STRING)[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[/if]
							[else]
								[if(element.oclAsType(xtext::RuleCall).cardinality = '*')]
		b.zeroOrMore([element.oclAsType(xtext::RuleCall).rule.name.toUpper()/])[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[elseif(element.oclAsType(xtext::RuleCall).cardinality = '+')]
		b.oneOrMore([element.oclAsType(xtext::RuleCall).rule.name.toUpper()/])[if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[else]
		[element.oclAsType(xtext::RuleCall).rule.name.toUpper()/][if((element.oclAsType(xtext::RuleCall).cardinality = '?')._or((element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->size() <> 0)._and(element.oclAsType(xtext::RuleCall).ancestors(xtext::Assignment)->first().cardinality = '?')))])[/if][if(isOptionalLastChild = true)])[/if][if(i <> size)],[/if]
								[/if]
							[/if]
						[/if]
						[comment --- End RULECALLS./]
						[/if]
						[/let]
					[/for]
		[if((rule.eAllContents(xtext::AbstractElement)->first().oclIsKindOf(xtext::Alternatives) = false)._and(((rule.eAllContents(xtext::AbstractElement)->size() > 1)._and(rule.eAllContents(xtext::AbstractElement)->first().oclIsKindOf(xtext::Assignment)._and(rule.eAllContents(xtext::AbstractElement)->at(2).oclIsKindOf(xtext::Alternatives)))) = false)._and((rule.eAllContents(xtext::Keyword)->size() + rule.eAllContents(xtext::RuleCall)->size()) > 1)._and(rule.eAllContents(xtext::AbstractElement)->last().ancestors(xtext::Alternatives)->size() = 0))]));[elseif((rule.eAllContents(xtext::Keyword)->size() + rule.eAllContents(xtext::RuleCall)->size()) = 1)]);[/if]
					[/let]
				[/if]
		[lineSeparator()/]
		[/for]
	}
}
[/file]

[file (grammarName.concat('Keyword.java'), false, 'UTF-8')]
package org.sonar.[grammarName/].api;

import com.sonar.sslr.api.AstNode;
import com.sonar.sslr.api.TokenType;
import org.sonar.sslr.grammar.GrammarRuleKey;

public enum [grammarName.concat('Keyword')/] implements TokenType, GrammarRuleKey {
		
	[for(keyword: String | aGrammar.eAllContents(xtext::Keyword).value->asSet())]
		[if((keyword.compareKeywordTemplate().contains('false')._and(keyword.noValidCharactersTemplate().contains('false'))))]
			[if(not(i = aGrammar.eAllContents(xtext::Keyword).value->asSet()->size()))]
	[keyword.renameKeywordWithSpecialCharacterTemplate().toUpper()/]("[keyword/]"),
			[else]
	[keyword.renameKeywordWithSpecialCharacterTemplate().toUpper()/]("[keyword/]");
			[/if]
		[/if]		
	[/for]
;

  private final String value;

  private [grammarName.concat('Keyword')/](String value) {
    this.value = value;
  }

  public String getName() {
    return name();
  }

  public String getValue() {
    return value;
  }

  public boolean hasToBeSkippedFromAst(AstNode node) {
    return false;
  }

  public static String['[]'/] keywordValues() {
    [grammarName.concat('Keyword')/]['[]'/] keywordsEnum = [grammarName.concat('Keyword')/].values();
    String['[]'/] keywords = new String['[keywordsEnum.length]'/];
    for (int i = 0; i < keywords.length; i++) {
      keywords['[i]'/] = keywordsEnum['[i]'/].getValue();
    }
    return keywords;
  }
}
[/file]

[file(grammarName.concat('.java'), false, 'UTF-8')]
package org.sonar.[grammarName/].api;

import com.sonar.sslr.api.Grammar;
import com.sonar.sslr.api.Rule;

public class [grammarName/] extends Grammar {
	[for (nameRule : String | aGrammar.eAllContents(xtext::ParserRule).name)]
	public Rule [nameRule.toUpper()/];
	[/for]

	@Override
	public Rule getRootRule() {
		// TODO Auto-generated method stub
		return [aGrammar.rules->at(1).name.toUpper()/];
	}
}
[/file]

[file (grammarName.concat('Punctuator.java'), false, 'UTF-8')]
package org.sonar.[grammarName/].api;

import com.sonar.sslr.api.AstNode;
import com.sonar.sslr.api.TokenType;
import org.sonar.sslr.grammar.GrammarRuleKey;

public enum [grammarName.concat('Punctuator')/] implements TokenType, GrammarRuleKey {

	[for(keyword: String | aGrammar.eAllContents(xtext::Keyword).value->asSet())]
		[if((keyword.compareKeywordTemplate().contains('true')._and(keyword.noValidCharactersTemplate().contains('false'))))]
			[if(not(i = aGrammar.eAllContents(xtext::Keyword).value->asSet()->size()))]
	[keyword.renameKeywordTemplate()/],
			[else]
	[keyword.renameKeywordTemplate()/];
			[/if]
		[/if]		
	[/for]
;

  private final String value;

  private [grammarName.concat('Punctuator')/](String word) {
    this.value = word;
  }

  public String getName() {
    return name();
  }

  public String getValue() {
    return value;
  }

  public boolean hasToBeSkippedFromAst(AstNode node) {
    return false;
  }
}
[/file]

[file (grammarName.concat('TokenType.java'), false, 'UTF-8')]
package org.sonar.[grammarName/].api;

import com.sonar.sslr.api.AstNode;
import com.sonar.sslr.api.TokenType;
import org.sonar.sslr.grammar.GrammarRuleKey;

public enum [grammarName/]TokenType implements TokenType, GrammarRuleKey {
  [for(rule : TerminalRule | aGrammar.eAllContents(xtext::TerminalRule))]
  [if((rule.name.toUpper().equalsIgnoreCase('NUMBER') <> true)._and(rule.name.toUpper().equalsIgnoreCase('STRING') <> true)._and(rule.name.toUpper().equalsIgnoreCase('CHARACTER') <> true))]
  [rule.name.toUpper()/],
  [/if]
  [/for]
  CHARACTER,
  NUMBER,
  STRING;	

  // TODO in fact it's STRING_LITERAL, but we need to keep compatibility of XPath expressions

  public String getName() {
    return name();
  }

  public String getValue() {
    return name();
  }

  public boolean hasToBeSkippedFromAst(AstNode node) {
    return false;
  }
}
[/file]
[file(grammarName.concat('AstScanner.java'), false, 'UTF-8')]
package org.sonar.[grammarName/].api;

import com.sonar.sslr.api.Grammar;
import com.sonar.sslr.impl.Parser;

import org.sonar.[grammarName/].visitors.[grammarName/]CharsetAwareVisitor;
import org.sonar.[grammarName/].visitors.[grammarName/]FileVisitor;
import org.sonar.[grammarName/].[grammarName/]CommentAnalyser;
import org.sonar.[grammarName/].[grammarName/]Configuration;
import org.sonar.[grammarName/].parser.[grammarName/]Parser;
import org.sonar.squidbridge.AstScanner;
import org.sonar.squidbridge.SquidAstVisitor;
import org.sonar.squidbridge.SquidAstVisitorContextImpl;
import org.sonar.squidbridge.api.SourceCode;
import org.sonar.squidbridge.api.SourceFile;
import org.sonar.squidbridge.api.SourceProject;
import org.sonar.squidbridge.indexer.QueryByType;
import org.sonar.squidbridge.metrics.CommentsVisitor;
import org.sonar.squidbridge.metrics.CounterVisitor;
import org.sonar.squidbridge.metrics.LinesOfCodeVisitor;
import org.sonar.squidbridge.metrics.LinesVisitor;

import java.io.File;
import java.util.Collection;

public final class [grammarName/]AstScanner {

  private [grammarName/]AstScanner() {}

  /**
   * Helper method for testing checks without having to deploy them on a Sonar instance.
   */
  public static SourceFile scanSingleFileConfig(File file, [grammarName/]Configuration [grammarName/]Config, SquidAstVisitor<Grammar>... visitors) {
	    if (!file.isFile()) {
	      throw new IllegalArgumentException("File '" + file + "' not found.");
	    }
	    AstScanner<Grammar> scanner = create([grammarName/]Config, visitors);
	    scanner.scanFile(file);
	    Collection<SourceCode> sources = scanner.getIndex().search(new QueryByType(SourceFile.class));
	    if (sources.size() != 1) {
	      throw new IllegalStateException("Only one SourceFile was expected whereas " + sources.size() + " has been returned.");
	    }
	    return (SourceFile) sources.iterator().next();
  }

  public static AstScanner<Grammar> create([grammarName/]Configuration conf, SquidAstVisitor<Grammar>... visitors) {
	final SquidAstVisitorContextImpl<Grammar> context = new SquidAstVisitorContextImpl<Grammar>(new SourceProject("[grammarName/] Project"));;
    final Parser<Grammar> parser = [grammarName/]Parser.create(/*context, conf*/);

    AstScanner.Builder<Grammar> builder = AstScanner.<Grammar> builder(context).setBaseParser(parser);

    /* Metrics */
    builder.withMetrics([grammarName/]Metric.values());

    /* Comments */
    builder.setCommentAnalyser(new [grammarName/]CommentAnalyser());

    /* Files */
    builder.setFilesMetric([grammarName/]Metric.FILES);

    /* Functions */
    builder.withSquidAstVisitor(CounterVisitor.<Grammar> builder()
            .setMetricDef([grammarName/]Metric.FUNCTIONS)
            /*.subscribeTo(TO COMPLETE WITH THE FUNCTION RULES BY THE FINAL USER) */
            .build());

    /* Metrics */
    builder.withSquidAstVisitor(new LinesVisitor<Grammar>([grammarName/]Metric.LINES));
    builder.withSquidAstVisitor(new LinesOfCodeVisitor<Grammar>([grammarName/]Metric.LINES_OF_CODE));
    builder.withSquidAstVisitor(CommentsVisitor.<Grammar>builder().withCommentMetric(
    	      [grammarName/]Metric.COMMENT_LINES)
    	      .withNoSonar(true)
    	      /*.withIgnoreHeaderComment(conf.getIgnoreHeaderComments())*/.build());
    builder.withSquidAstVisitor(CounterVisitor.<Grammar> builder()
        .setMetricDef([grammarName/]Metric.STATEMENTS)
        /*.subscribeTo(TO COMPLETE WITH THE STATEMENT RULES BY THE FINAL USER) */
        .build());
    
    builder.withSquidAstVisitor(new [grammarName/]FileVisitor<Grammar>(context));
    //builder.withSquidAstVisitor(new [grammarName/]ComplexityVisitor<Grammar>(context));

    for (SquidAstVisitor<Grammar> visitor : visitors) {
        if (visitor instanceof [grammarName/]CharsetAwareVisitor) {
            (([grammarName/]CharsetAwareVisitor) visitor).setCharset(conf.getCharset());
          }
        builder.withSquidAstVisitor(visitor);
    }
    return builder.build();
  }
}
[/file]
[file(grammarName.concat('ParseErrorLoggerVisitor.java'), false, 'UTF-8')]
package org.sonar.[grammarName/].api;

import org.sonar.[grammarName/].api.[grammarName/]Impl;
import org.sonar.squidbridge.SquidAstVisitor;
import org.sonar.squidbridge.SquidAstVisitorContext;

import com.sonar.sslr.api.AstAndTokenVisitor;
import com.sonar.sslr.api.AstNode;
import com.sonar.sslr.api.GenericTokenType;
import com.sonar.sslr.api.Grammar;
import com.sonar.sslr.api.Token;

public class [grammarName/]ParseErrorLoggerVisitor <GRAMMAR extends Grammar> extends SquidAstVisitor<GRAMMAR> implements AstAndTokenVisitor {

  private SquidAstVisitorContext context = null;

  public [grammarName/]ParseErrorLoggerVisitor(SquidAstVisitorContext context){
    this.context = context;
  }

  @Override
  public void init() {
    subscribeTo([grammarName/]Impl.[aGrammar.rules->at(1).name.toUpper()/]);
  }

  @Override
  public void visitNode(AstNode node) {
    AstNode identifierAst = node.getFirstChild(GenericTokenType.IDENTIFIER);
    if( identifierAst != null ) {
      [grammarName/]Impl.LOG.warn("['['/]{}:{}[']'/]: syntax error, skip '{}'", new Object['[]'/] {context.getFile(), node.getToken().getLine(), identifierAst.getTokenValue()});
    }
  }

  public void visitToken(Token token) {
  }
}
[/file]
[file(grammarName.concat('CommentLinesVisitor.java'), false, 'UTF-8')]
package org.sonar.[grammarName/].api;

import java.util.Set;

import org.sonar.squidbridge.SquidAstVisitor;
import org.sonar.squidbridge.api.SourceCode;
import org.sonar.squidbridge.measures.MetricDef;

import com.google.common.collect.Sets;
import com.sonar.sslr.api.AstAndTokenVisitor;
import com.sonar.sslr.api.AstNode;
import com.sonar.sslr.api.Grammar;
import com.sonar.sslr.api.Token;
import com.sonar.sslr.api.Trivia;

public class [grammarName/]CommentLinesVisitor <GRAMMAR extends Grammar> extends SquidAstVisitor<GRAMMAR> implements AstAndTokenVisitor {

  private final MetricDef metric;
  private Set<Integer> comments = Sets.newHashSet();
  private boolean seenFirstToken;
  
  public [grammarName/]CommentLinesVisitor(MetricDef metric) {
	    this.metric = metric;
  }

  @Override
  public void init() {
    subscribeTo(/*TO COMPLETE WITH THE FUNCTION RULES BY THE FINAL USER*/);
  }

  @Override
  public void visitFile(AstNode astNode) {
    comments.clear();
    seenFirstToken = false;
  }

  public void visitToken(Token token) {
    for (Trivia trivia : token.getTrivia()) {
      if (trivia.isComment()) {
        if (seenFirstToken) {
          String['[]'/] commentLines = getContext().getCommentAnalyser().getContents(trivia.getToken().getOriginalValue())
              .split("(\r)?\n|\r", -1);
          int line = trivia.getToken().getLine();
          for (String commentLine : commentLines) {
            if (!commentLine.contains("NOSONAR") && !getContext().getCommentAnalyser().isBlank(commentLine)) {
              comments.add(line);
            }
            line++;
          }
        } else {
          seenFirstToken = true;
        }
      }
    }
    seenFirstToken = true;
  }

  @Override
  public void leaveNode(AstNode astNode) {
    SourceCode sourceCode = getContext().peekSourceCode();
    int commentlines = 0;
    for (int line = sourceCode.getStartAtLine(); line <= sourceCode.getEndAtLine(); line++) {
      if (comments.contains(line)) {
        commentlines++;
      }
    }
    sourceCode.setMeasure([grammarName/]Metric.COMMENT_LINES, commentlines);
  }

  public void leaveFile(AstNode ast) {
	getContext().peekSourceCode().add(metric, comments.size());
    getContext().peekSourceCode().setMeasure([grammarName/]Metric.COMMENT_LINES, comments.size());
    comments.clear();
  }
}
[/file]
[/let]
[/if]
[/template]