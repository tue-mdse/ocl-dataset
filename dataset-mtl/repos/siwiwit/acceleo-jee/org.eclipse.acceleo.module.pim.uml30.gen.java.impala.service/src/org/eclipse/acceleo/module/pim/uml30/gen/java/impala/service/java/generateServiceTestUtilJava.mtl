[comment encoding = UTF-8 /]
[module generateServiceTestUtilJava('http://www.eclipse.org/uml2/3.0.0/UML')/]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::service::common::servicePathUtil /]
[import org::acceleo::module::pim::uml21::gen::java::common::common /]
[import org::acceleo::module::pim::uml21::gen::java::spring::common /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::common::pathUtil /]
[import org::acceleo::module::pim::uml21::gen::java::common::structure /]
[import org::acceleo::module::pim::uml21::gen::java::common::requests /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::common::requests /]
[import org::acceleo::module::pim::uml21::gen::java::common::dataTypes /]
[import org::acceleo::module::pim::uml21::gen::java::common::compositeUtil /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::dao::common::daoUtil /]
[import org::acceleo::module::pim::uml21::services::uml2services /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::common::stringUtil /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::main::common::mainCommon /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::build::common::entityUtil /]
[import org::eclipse::acceleo::module::pim::uml30::gen::java::impala::service::common::serviceCommon /]
[template public generateServiceTestUtilJava(aModel : Model)]
[file (aModel.generateProjectFolder().concat(aModel.pathToTestJava()).concat('/tests/integration/ServiceTestUtil.java'), false, 'UTF-8')]
package tests.integration;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Collection;
import javax.sql.DataSource;
import java.text.SimpleDateFormat;
import java.text.ParseException;
import java.util.Calendar;
import java.util.Date;
import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
import org.impalaframework.facade.Impala;

	[for (anEntity : Class | aModel.eAllContents(Class)->select(aClass:Class|aClass.isEntity()))]
		[if (anEntity.generateJavaPackage() <> 'tests.integration')]
import [if (anEntity.generateJavaPackage().size()>0)][anEntity.generateJavaPackage()/].[/if][anEntity.name.toUpperFirst()/]Dao;
			[if (not anEntity.hasEntityParent())]
import [if (anEntity.generateJavaPackage().size()>0)][anEntity.generateJavaPackage()/].[/if][anEntity.name.toUpperFirst()/];
			[/if]
import [if (anEntity.generateJavaPackage().size()>0)][anEntity.generateJavaPackage()/].[/if][anEntity.name.toUpperFirst()/]Impl;
		[/if]
	[/for]
	[let entities : Set(Class) = aModel.eAllContents(Class)->select(aClass:Class|aClass.isEntity())->asSet()]
		[let enumTypes : Set(Type) = entities.ownedAttribute.type->filter(Enumeration)->union(entities.ownedOperation.ownedParameter.type->filter(Enumeration))->asSet() ]
			[for (enumType : Type | enumTypes)]
		[if (enumType.generateJavaPackage() <> 'tests.integration')]
import [if (enumType.generateJavaPackage().size()>0)][enumType.generateJavaPackage()/].[/if][enumType.name.toUpperFirst()/];
		[/if]
			[/for]
		[/let]
	[/let]
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.Collection;


public final class ServiceTestUtil {

	private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd");

	private ServiceTestUtil() {
	}
	
	public static Date increaseOneDay(Date firstDate) {
		Calendar calendar =  Calendar.getInstance();
		calendar.setTime(firstDate);
		calendar.set(Calendar.DATE, calendar.get(Calendar.DATE)+1);
		return calendar.getTime(); 
	}

	public static String createStringFieldValue(String fieldName, long index) {
		return fieldName+index; 
	}
	
	public static Boolean createBooleanFieldValue(String fieldName, long index) {
		return index % 2==1; 
	}

	public static Long createLongFieldValue(String fieldName, long index) {
		return Long.valueOf(index); 
	}
	public static Integer createIntegerFieldValue(String fieldName, int index) {
		return Integer.valueOf(index); 
	}
	public static Short createShortFieldValue(String fieldName, short index) {
		return Short.valueOf(index); 
	}
	public static Float createFloatFieldValue(String fieldName, float index) {
		return Float.valueOf(index); 
	}
	public static Double createDoubleFieldValue(String fieldName, double index) {
		return Double.valueOf(index); 
	}
	public static Byte createByteFieldValue(String fieldName, byte index) {
		return Byte.valueOf(index); 
	}
	
	public static Date createDateFieldValue(String fieldName, long index) {
		try {
			return ServiceTestUtil.dateFormat.parse("2012/01/"+index);
        } catch (ParseException ex) {
			throw new RuntimeException(ex);
        }
		
	}

	public static <T extends Object> T getBean(String beanName, Class<T> type) {
		return Impala.getModuleBean("[aModel.generateProjectFolder()/]", beanName, type);
	}

	[for (aEntityClass : Class | aModel.eAllContents(Class)->select(aClass:Class|aClass.isEntity()))]
	public static [aEntityClass.name.toUpperFirst()/]Dao get[aEntityClass.name.toUpperFirst()/]Dao() {
        return ServiceTestUtil.getBean("[aEntityClass.name.toLower()/]dao", [aEntityClass.name.toUpperFirst()/]Dao.class);
    }
	[/for]
	
	[for (anEnumeration : Enumeration | aModel.eAllContents(Enumeration))]
	public static [anEnumeration.name.toUpperFirst()/] create[anEnumeration.name.toUpperFirst()/]Value(String fieldName, long index) {
		switch(Long.valueOf(index%[anEnumeration.ownedLiteral->size()/]).intValue()) {
			[for (anEnumeration.ownedLiteral)]
			case [i-1/]: return [anEnumeration.name.toUpperFirst()/].[self.name.toUpper()/];
			[/for]
			default: throw new RuntimeException("Unknown problem");
		}
	}
	[/for]
	[aModel.eAllContents(Class)->select(aClass:Class|aClass.isEntity()).createObjectFuction()/]
}
[/file]
[/template]
[template public createObjectFuction(anEntity : Class)]
	[let refProperties : Sequence(Property) = anEntity.getAllEntityParents()->including(anEntity).getOppositeAttributes(false)->select(aProperty:Property|not aProperty.isPK() and not aProperty.type.isSimpleType() and not aProperty.type.oclIsTypeOf(Enumeration) and (((aProperty.oppositeAttribute().upper>1 or aProperty.oppositeAttribute().upper<0) and aProperty.upper=1) or ((aProperty.oppositeAttribute().upper>=0 or aProperty.oppositeAttribute().upper<=1) and aProperty.upper=1) and aProperty.isNavigable()))->asSequence()]
public static [anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if] create[anEntity.name.toUpperFirst()/]Object(long index) {
		[if (refProperties->notEmpty())]
			[let anOppositeProp : Property = refProperties->first()]
	return ServiceTestUtil.create[anEntity.name.toUpperFirst()/]ObjectRefTo[anOppositeProp.type.name.toUpperFirst()/]OfField[anOppositeProp.name.toUpperFirst()/](index, null);
			[/let]
		[else]
	Map<String, Long> childIndexMap = new HashMap<String, Long>();
	Long childIndex = null;
			
    [anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if] [anEntity.name.toLowerFirst()/] = new [anEntity.name.toUpperFirst()/]Impl();
			[let classStructures : Sequence(Class) = anEntity.getAllEntityParents()->including(anEntity)]
				[for (aProperty : Property | classStructures.ownedAttribute)]
					[if (aProperty.type.isSimpleType() or aProperty.type.oclIsTypeOf(Enumeration))]
    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/]([aProperty.type.generateSampleParameterValue(aProperty.name, 'index')/]);
					[else]
						//--[aProperty.type.name/]--
						[comment][let aRefProperty : Property =  classStructures.getAssociations()->select(anAss:Association|anAss.memberEnd->exists(aMemberEnd:Property|aMemberEnd=aProperty)).memberEnd->select(aMemberEnd:Property|aMemberEnd<>aProperty)->asSequence()->first()]
    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/](ServiceTestUtil.create[aProperty.type.name.toUpperFirst()/]ObjectRefTo[aRefProperty.type.name.toUpperFirst()/]OfField[aProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/]));
						[/let][/comment]								
					[/if]						
				[/for]
			[/let]
	ServiceTestUtil.get[anEntity.name.toUpperFirst()/]Dao().create([anEntity.name.toLowerFirst()/]);
	return [anEntity.name.toLowerFirst()/];	
		[/if]
}
//-------------
		[if (refProperties->notEmpty())]
			[for (refProperty : Property | refProperties)]
[anEntity.createObjectFuction(refProperty, refProperty.type.oclAsType(Class).getAllEntityParents()->including(refProperty.type.oclAsType(Class)).getAssociations()->select(anAss:Association|anAss.memberEnd->exists(aMemberEnd:Property|aMemberEnd=refProperty)).memberEnd->select(aMemberEnd:Property|aMemberEnd<>refProperty)->first())/]
			[/for]
		[/if]
//-------------
	[/let]
[/template]

[template public createObjectFuction(anEntity : Class, refProperty : Property, ownedProperty : Property)]
public static [anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if] create[anEntity.name.toUpperFirst()/]ObjectRefTo[refProperty.type.name.toUpperFirst()/]OfField[refProperty.name.toUpperFirst()/](long index, [refProperty.type.name.toUpperFirst()/] [refProperty.type.name.toLowerFirst()/]) {
	Map<String, Long> childIndexMap = new HashMap<String, Long>();
	Long childIndex = null;	
    [anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if] [anEntity.name.toLowerFirst()/] = new [anEntity.name.toUpperFirst()/]Impl();
	[let classStructures : Sequence(Class) = anEntity.getAllEntityParents()->including(anEntity)]
		[for (aProperty : Property | classStructures.ownedAttribute)]
			[if (aProperty.type.isSimpleType() or aProperty.type.oclIsTypeOf(Enumeration))]
    [anEntity.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/]([aProperty.type.generateSampleParameterValue(aProperty.name, 'index')/]);
			[else]
						[comment][let aRefProperty : Property = aStructureClass.getAssociations()->select(anAss : Association|anAss.memberEnd->exists(aMember : Property | aMember=aProperty)).memberEnd->select(aMember : Property | aMember<>aProperty)->asSequence()->first()]
							[if (aRefProperty.upper >= 0 and aRefProperty.upper <= 1)]
	[refProperty.type.name.toLowerFirst()/].set[aRefProperty.name.toUpperFirst()/](ServiceTestUtil.create[aProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[aProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/]));
							[elseif (aRefProperty.isOrdered)]
	[refProperty.type.name.toLowerFirst()/].set[aRefProperty.name.toUpperFirst()/](Arrays.asList(ServiceTestUtil.create[aProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[aProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/])));
							[elseif (aRefProperty.isUnique)]
	[refProperty.type.name.toLowerFirst()/].set[aRefProperty.name.toUpperFirst()/](new HashSet(Arrays.asList(ServiceTestUtil.create[aProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[aProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/]))));
							[elseif (not aRefProperty.isOrdered and not aRefProperty.isUnique)]
	[refProperty.type.name.toLowerFirst()/].set[aRefProperty.name.toUpperFirst()/](Arrays.asList(ServiceTestUtil.create[aProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[aProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/])));
							[/if]
						[/let][/comment]
			[/if]								
		[/for]
		[for (aRefProperty : Property | classStructures.getOppositeAttributes(false)->select(aField:Property | (aField.lower=1 or aField.lower=0) and ((aField.oppositeAttribute().upper<0 or aField.oppositeAttribute().upper>1) or aField.isNavigable())))]
	[anEntity.generateReferences(aRefProperty, refProperty)/]		
		[/for]
	ServiceTestUtil.get[anEntity.name.toUpperFirst()/]Dao().create([anEntity.name.toLowerFirst()/]);
	[/let]
	[comment][anEntity.name.toUpperFirst()/]DaoTest.get[anEntity.name.toUpperFirst()/]Dao().create([anEntity.name.toLowerFirst()/]);[/comment]
	return [anEntity.name.toLowerFirst()/];
}
[/template]

[template public generateObjectProperty(anEntity : Class, refProperty : Property, ownedProperty : Property, typeDeclare : Boolean) ]
childIndex = childIndexMap.get([anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if].class.getName()); 
if(childIndex == null) {
	childIndex = Long.valueOf(index);
} else {
	childIndex = Long.valueOf(childIndex.longValue() + 1);
}
childIndexMap.put([anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if].class.getName(), childIndex);
	[if (ownedProperty.isNavigable())]
[if (typeDeclare)][refProperty.type.name.toUpperFirst()/] [/if][refProperty.name.toLowerFirst()/] = ServiceTestUtil.create[refProperty.type.name.toUpperFirst()/]ObjectRefTo[anEntity.name.toUpperFirst()/]OfField[ownedProperty.name.toUpperFirst()/](childIndex, [anEntity.name.toLowerFirst()/]);
	[else]
[if (typeDeclare)][refProperty.type.name.toUpperFirst()/] [/if][refProperty.name.toLowerFirst()/] = ServiceTestUtil.create[refProperty.type.name.toUpperFirst()/]Object(childIndex);
	[/if] 
	[if (refProperty.upper = 1)]
		[if (refProperty.isNavigable())]
[anEntity.name.toLowerFirst()/].set[refProperty.name.toUpperFirst()/]([refProperty.name.toLowerFirst()/]);
		[/if]
	[elseif (ownedProperty.isOrdered)]
[anEntity.name.toLowerFirst()/].set[ownedProperty.name.toUpperFirst()/](Arrays.asList([refProperty.name.toLowerFirst()/]));
	[elseif (ownedProperty.isUnique)]
[anEntity.name.toLowerFirst()/].set[ownedProperty.name.toUpperFirst()/](new HashSet(Arrays.asList([refProperty.name.toLowerFirst()/])));
	[elseif (not ownedProperty.isOrdered and not ownedProperty.isUnique)]
[anEntity.name.toLowerFirst()/].set[ownedProperty.name.toUpperFirst()/](Arrays.asList([refProperty.name.toLowerFirst()/]));
	[/if]
[/template]

[template public generateReferences(anEntity : Class, aRefPropertyOfEntity : Property, refProperty : Property)]
	[let aProperty : Property = aRefPropertyOfEntity.oppositeAttribute()]							
		[if (not aRefPropertyOfEntity.type.isSimpleType() and aRefPropertyOfEntity.type.oclIsTypeOf(Class) and aRefPropertyOfEntity.type.oclAsType(Class).isEntity())]
			[if (aRefPropertyOfEntity = refProperty)]
				[if (aProperty.lower=1)]
					[if (aProperty.isNavigable())]
if([refProperty.type.name.toLowerFirst()/] == null) {
	childIndex = childIndexMap.get([anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if].class.getName()); 
	if(childIndex == null) {
		childIndex = Long.valueOf(index);
	} else {
		childIndex = Long.valueOf(childIndex.longValue() + 1);
	}
	childIndexMap.put([anEntity.name.toUpperFirst()/][if (anEntity.hasEntityParent())]Impl[/if].class.getName(), childIndex);
	[refProperty.type.name.toLowerFirst()/] = ServiceTestUtil.create[refProperty.type.name.toUpperFirst()/]Object(childIndex);
}
					[/if]
				[/if]
if([refProperty.type.name.toLowerFirst()/] != null) {
				[if (aProperty.upper >= 0 and aProperty.upper <= 1)]
					[if (aProperty.isNavigable())]
    [refProperty.type.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/]([anEntity.name.toLowerFirst()/]);
					[/if]
				[elseif (aProperty.isOrdered)]
	[refProperty.type.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/](Arrays.asList([anEntity.name.toLowerFirst()/]));
				[elseif (aProperty.isUnique)]
	[refProperty.type.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/](new HashSet(Arrays.asList([anEntity.name.toLowerFirst()/])));
				[elseif (not aProperty.isOrdered and not aProperty.isUnique)]
	[refProperty.type.name.toLowerFirst()/].set[aProperty.name.toUpperFirst()/](Arrays.asList([anEntity.name.toLowerFirst()/]));
				[/if]
				[let refAssociations : Sequence(Association) = refProperty.type.oclAsType(Class).getAllEntityParents()->including(refProperty.type.oclAsType(Class)).getAssociations()->select(anAss : Association|anAss.memberEnd->exists(aMember : Property | aMember=aProperty))->asSequence()]
					[if (refAssociations->notEmpty())]
						[let refField : Property = refAssociations.memberEnd->select(aMember : Property | aMember <> aProperty)->first()]
							[if (refField.upper >= 0 and refField.upper <= 1)]
								[comment][if (refField.isNavigable())][/comment]
	[anEntity.name.toLowerFirst()/].set[refField.name.toUpperFirst()/]([refProperty.type.name.toLowerFirst()/]);
								[comment][/if][/comment]
							[elseif (refField.isOrdered)]
	[anEntity.name.toLowerFirst()/].set[refField.name.toUpperFirst()/](Arrays.asList([refProperty.type.name.toLowerFirst()/]));
							[elseif (refField.isUnique)]
	[anEntity.name.toLowerFirst()/].set[refField.name.toUpperFirst()/](new HashSet(Arrays.asList([refProperty.type.name.toLowerFirst()/])));
							[elseif (not refField.isOrdered and not refField.isUnique)]
	[anEntity.name.toLowerFirst()/].set[refField.name.toUpperFirst()/](Arrays.asList([refProperty.type.name.toLowerFirst()/]));
							[/if]
						[/let]
					[else]
					[/if]								
				[/let]
				[if (aRefPropertyOfEntity.isNavigable())]
} else {
	[anEntity.generateObjectProperty(aRefPropertyOfEntity, aProperty, aRefPropertyOfEntity.name.toLowerFirst()<>refProperty.type.name.toLowerFirst())/]	
				[/if]
}
			[else]
[anEntity.generateObjectProperty(aRefPropertyOfEntity, aProperty, aRefPropertyOfEntity.name.toLowerFirst()<>refProperty.type.name.toLowerFirst())/]	
			[/if]								
		[/if]
	[/let]
[/template]
