[comment encoding = UTF-8 /]
[module generate('http://www.yakindu.org/sct/sgraph/2.0.0', 'http://www.eclipse.org/gmf/runtime/1.0.2/notation')]
[template public generateElement(aStatechart : Statechart)]
[comment @main/]
[file (aStatechart.name, false, 'UTF-8')]
	[generateGo(aStatechart)/]
	[generateIOCPP(aStatechart)/]
	[generateIOH(aStatechart)/]
	[generateTest(aStatechart)/]
	[generateIOMapping(aStatechart)/]
	[generateRunnerCPP(aStatechart)/]
	[generateRunnerH(aStatechart)/]
		[for(s:State | aStatechart.regions.vertices)]
			 [generateStatesCPP(s)/] [generateStatesH(s)/]
		[/for]
[/file]
[/template]
[template public generateGo(aStatechart : Statechart)]

[file ('go.cpp', false, 'UTF-8')]
#include <Arduino.h>
#include "runner.h"
#include "io.h"
#include <PS2Keyboard.h>
//https://www.pjrc.com/teensy/td_libs_PS2Keyboard.html
#include <Wire.h>


#define  LOG_WA_

#define KEY_ENTER			13

#define _PS2_F1				246
#define _PS2_F2				247
#define _PS2_F3				248
#define _PS2_F4				249
#define _PS2_F5				250
#define _PS2_F6				251
#define _PS2_F7				252
#define _PS2_F8				253
#define _PS2_F9				254
#define _PS2_F10			255

const PROGMEM PS2Keymap_t MyKeymap_French =
		{
		// without shift
				{ 0, _PS2_F9, 0, _PS2_F5, _PS2_F3, _PS2_F1, _PS2_F2, PS2_F12, 0,
				_PS2_F10, _PS2_F8, _PS2_F6, _PS2_F4, PS2_TAB,
				PS2_SUPERSCRIPT_TWO, 0, 0, 0 /*Lalt*/, 0 /*Lshift*/, 0,
						0 /*Lctrl*/, 'a', '&', 0, 0, 0, 'w', 's', 'q', 'z',
						PS2_e_ACUTE, 0, 0, 'c', 'x', 'd', 'e', '\'', '"', 0, 0,
						' ', 'v', 'f', 't', 'r', '(', 0, 0, 'n', 'b', 'h', 'g',
						'y', '-', 0, 0, 0, ',', 'j', 'u', PS2_e_GRAVE, '_', 0,
						0, ';', 'k', 'i', 'o', PS2_a_GRAVE, PS2_c_CEDILLA, 0, 0,
						':', '!', 'l', 'm', 'p', ')', 0, 0, 0, PS2_u_GRAVE, 0,
						'^', '=', 0, 0, 0 /*CapsLock*/, 0 /*Rshift*/,
						PS2_ENTER /*Enter*/, '$', 0, '*', 0, 0, 0, '<', 0, 0, 0,
						0, PS2_BACKSPACE, 0, 0, '1', 0, '4', '7', 0, 0, 0, '0',
						'.', '2', '5', '6', '8', PS2_ESC, 0 /*NumLock*/,
						PS2_F11, '+', '3', '-', '*', '9', PS2_SCROLL, 0, 0, 0,
						0, _PS2_F7 },
				// with shift
				{ 0, PS2_F9, 0, PS2_F5, PS2_F3, PS2_F1, PS2_F2, PS2_F12, 0,
				PS2_F10, PS2_F8, PS2_F6, PS2_F4, PS2_TAB, 0, 0, 0, 0 /*Lalt*/,
						0 /*Lshift*/, 0, 0 /*Lctrl*/, 'A', '1', 0, 0, 0, 'W',
						'S', 'Q', 'Z', '2', 0, 0, 'C', 'X', 'D', 'E', '4', '3',
						0, 0, ' ', 'V', 'F', 'T', 'R', '5', 0, 0, 'N', 'B', 'H',
						'G', 'Y', '6', 0, 0, 0, '?', 'J', 'U', '7', '8', 0, 0,
						'.', 'K', 'I', 'O', '0', '9', 0, 0, '/',
						PS2_SECTION_SIGN, 'L', 'M', 'P', PS2_DEGREE_SIGN, 0, 0,
						0, '%', 0, PS2_DIAERESIS, '+', 0, 0, 0 /*CapsLock*/,
						0 /*Rshift*/, PS2_ENTER /*Enter*/, PS2_POUND_SIGN, 0,
						PS2_MICRO_SIGN, 0, 0, 0, '>', 0, 0, 0, 0, PS2_BACKSPACE,
						0, 0, '1', 0, '4', '7', 0, 0, 0, '0', '.', '2', '5',
						'6', '8', PS2_ESC, 0 /*NumLock*/,
						PS2_F11, '+', '3', '-', '*', '9', PS2_SCROLL, 0, 0, 0,
						0, PS2_F7 }, 1,
				// with altgr
				{ 0, PS2_F9, 0, PS2_F5, PS2_F3, PS2_F1, PS2_F2, PS2_F12, 0,
				PS2_F10, PS2_F8, PS2_F6, PS2_F4, PS2_TAB, 0, 0, 0, 0 /*Lalt*/,
						0 /*Lshift*/, 0, 0 /*Lctrl*/, '@', 0, 0, 0, 0, 0, 0, 0,
						0, '~', 0, 0, 0, 0, 0, 0 /*PS2_EURO_SIGN*/, '{', '#', 0,
						0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '|', 0, 0,
						0, 0, 0, 0, '`', '\\', 0, 0, 0, 0, 0, 0, '@', '^', 0, 0,
						0, 0, 0, 0, 0, ']', 0, 0, 0, 0, 0, 0, 0, '}', 0,
						0 /*CapsLock*/, 0 /*Rshift*/, PS2_ENTER /*Enter*/,
						'Â¤', 0, '#', 0, 0, 0, '|', 0, 0, 0, 0, PS2_BACKSPACE,
						0, 0, '1', 0, '4', '7', 0, 0, 0, '0', '.', '2', '5',
						'6', '8', PS2_ESC, 0 /*NumLock*/,
						PS2_F11, '+', '3', '-', '*', '9', PS2_SCROLL, 0, 0, 0,
						0, PS2_F7 } };

/*
 #include "FirstBlinkSm.h"
 #include "SecondBlinkSm.h"

 */
#define CMD_SIZE 50
#define CMD_LEN CMD_SIZE - 1
boolean cmd_state = false;

char cmd_buffer['[CMD_SIZE]'/];

PS2Keyboard keyboard;

//int index = 0;
int cmd_index = 0;
boolean function_key = false;
boolean function_value = false;


int freeRam() {
	extern int __heap_start, *__brkval;
	int v;
	return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval);
}

void getRam(char* cmd, boolean lcd) {
#ifdef LOG_WA_
	char c['[]'/] = "                         ";
	if (lcd) {
		sprintf(c, "%d", freeRam());
	} else {
		sprintf(c, "freeRam=%d", freeRam());
	}
#endif
}




void setup() {

// Generated by Acceleo !! Penser à créer les configurations de votre programme ! 

	pinMode(8, OUTPUT);
    pinMode(9, OUTPUT);
    pinMode(10, OUTPUT);
    pinMode(11, OUTPUT);
	

	//pinMode(MOTOR, OUTPUT);
	pinMode(OUT3, OUTPUT);

	CONSOLE.begin(9600);
	CONSOLE.println(F("setup 0"));

	getRam(NULL, false);

	keyboard.begin(KBD_DATA, KBD_CLOCK, MyKeymap_French);
	
	pinMode(CHP, OUTPUT);
	pinMode(RST, OUTPUT);
//pinMode(LED, OUTPUT);

	//ESP.begin(ESP_BAUDS);
	/*
	 */
	CONSOLE.println(F("setup 1"));
	getRam(NULL, false);

	init_io();
	StateMachine_setup();
}

void clear_cmd_buffer() {
	for (int j = 0; j < CMD_SIZE; j++) {
		cmd_buffer['[j]'/] = 0;
	}
	cmd_index = 0;
}

void cmd_insert(char c) {
	if (cmd_index < CMD_LEN)
		cmd_buffer['[cmd_index++]'/] = c;
}

unsigned long cm = 0;





void loop() { // ca boucle à l'infini

#ifdef CONSOLE_PARSER


	char c = 0; // on donne le char 0
	function_value = false; // le function value sert a entrer dans la condition d'aprés !

	if (keyboard.available()) { // ici on prend une commande depuis le clavier et on l'affiche dans le lcd !

		c = keyboard.read();
		unsigned int k = c;
		if (k > 65461) {
			function_key = true;
		}
		if (function_key) {
			function_key = false;
			if (k != 65475) {
				function_value = true;
				char m['[4]'/];
				int fk = k - 65461;
				input_kb(fk);             // c'est ici que oppére le truc ! on met les variables à true si le numéro correspond !
				sprintf(m, "F%d", fk);
				Serial.println(fk);
				cm++;
	//if (cm % 10L == 0) {
				StateMachine_loop();
	//}

			}
		}
	}

	//lcd.lcdWrite(c);
	//}


#endif

	
}

[/file]
[/template]

[template public generateIOCPP(aStatechart : Statechart)]

[file ('io.cpp', false, 'UTF-8')]
#include <Arduino.h>
#include "runner.h"
#include "io.h"

unsigned long outcount = 0;

[for(o:State | aStatechart.eAllContents()) ] // generated by acceleo 

 	[for(out:Transition | o.outgoingTransitions)]
  /** Les entree sortie : [o.outgoingTransitions.specification.replace('IO.', '')/]**/ 
		boolean [out.specification.replace('IO.', '')/] = false;
		boolean ev_[out.specification.replace('IO.', '')/]=false;
		boolean prior_[out.specification.replace('IO.', '')/] = false;
		
		PROGMEM const char s_[out.specification.replace('IO.', '')/]['[]'/] = "[out.specification.replace('IO.', '')/]";
	
	[/for]
[/for]


void resetEvents() {
[for(o:State | aStatechart.eAllContents()) ] // generated by acceleo
	[for(out:Transition | o.outgoingTransitions)]
	  [out.specification.replace('IO.', '')/] = false;
	[/for]
[/for]
}

boolean in_ev(boolean v, boolean *p) {
	boolean result = !*p && v;
	*p = v;
	return result;
}

void acquireInputs() {

[for(o:State | aStatechart.eAllContents()) ]
	[for(out:Transition | o.outgoingTransitions)]
		in_event([out.specification.replace('IO.', '')/]);
		debug_event([out.specification.replace('IO.', '')/]);
	[/for]
[/for]
	
}


void resetInputs_nu() {
  
		[for(o:State | aStatechart.eAllContents()) ] // generated by acceleo
[for(out:Transition | o.outgoingTransitions)]
		[out.specification.replace('IO.', '')/] = false;
[/for]
		[/for]

}




void applyOutputs_nu() {
	//TODO extract from command queue ?
}

#ifdef CONSOLE_PARSER


boolean input_kb(int k) { // commenter les variable non utilisé ! 
	StateMachine_setEvent();
    

	if (k == 1) // la touche 1 
		master_start = true;
	else if (k==2) // la touche 2
		master_stop = true;

	else if (k==3) // la touche 3
			sb_start = true;
	else if (k==4) // la touche 4
			sb_stop = true;
	else if (k==5) // la touche 5
			fb_start = true;
	else if (k==6) // la touche 6
			fb_stop = true;
	else if (k==9) // la touche 9
			m_start = true;
	else if (k==10) // la touche 10
			m_stop = true;
	else if (k==7) // la touche 7
				all_start = true;
	else if (k==8) // la touche 8
				all_stop = true;
	else
		return false;
	return true;

}

boolean input_cmd_str(char* cmd) {
	//event = true;
	StateMachine_setEvent();


	[for(o:State | aStatechart.eAllContents()) ] // generated by acceleo
[for(out:Transition | o.outgoingTransitions)]
		if (strstr_P(cmd, s_[out.specification.replace('IO.', '')/]) == cmd){
			[out.specification.replace('IO.', '')/]=true;
		return true;
		}
[/for]
	[/for]

  return false;
}

#endif



void out(int outp, boolean value,int i) {
	outcount++;
	digitalWrite(outp, value);
}

void init_io() {
	//out(MOTOR, false);
}

[/file]
[/template]

[template public generateIOH(aStatechart : Statechart)]

[file ('io.h', false, 'UTF-8')]

#ifndef _io_H_
#define _io_H_
//end of add your includes here
#ifdef __cplusplus
extern "C" {
#endif
#ifdef __cplusplus
} // extern "C"
#endif

#ifdef CONSOLE_PARSER
extern boolean input_kb(int k);
extern boolean input_cmd_str(char* cmd);
#endif


//generated by acceleo

#define MOTOR 8 
#define SB 9
#define FB 10
#define M 11



[for(o:State | aStatechart.eAllContents()) ] // generated by acceleo
[for(out:Transition | o.outgoingTransitions)]
	extern PROGMEM const char s_[out.specification.replace('IO.', '')/]['[]'/];
[/for]
[/for]


[for(o:State | aStatechart.eAllContents()) ] // generated by acceleo
[for(out:Transition | o.outgoingTransitions)]
	extern boolean ev_[out.specification.replace('IO.', '')/];
[/for]
[/for]

//extern boolean exec_cmd_sm(char* cmd);
extern void out_nu(char* ouputName, boolean value);
void out(int outp, boolean value, int i);
extern void resetEvents();
extern void init_io();
extern void acquireInputs();
void resetInputs();
extern void masterStart();
extern void applyOutputs_nu();





#endif

[/file]
[/template]

[template public generateIOMapping(aStatechart : Statechart)]
[file ('iomapping.h', false, 'UTF-8')]

#ifndef IOMAPPING_H_
#define IOMAPPING_H_
//#define RST 8
//#define CHP 9
//#define LED 13
//#define SENSOR 0
/*
#define OUT0 8
#define OUT1 9
#define OUT2 10*/
#define OUT3 11
#define RST 12
#define CHP 13
#define SENSOR A3//A3 = 17;
#define LCD_SCL A5
#define LCD_SDA A4
const int KBD_DATA = 4; //DataPin
const int KBD_CLOCK = 3; //IRQpin
//#define M_RESET_PIN   10
//#define M_FLASH_PIN   11
#define CONSOLE Serial
#define CONSOLE_PARSER
#endif /* IOMAPPING_H_ */
[/file]
[/template]

[template public generateRunnerCPP(aStatechart : Statechart)]
[file ('runner.cpp', false, 'UTF-8')]
#include "runner.h"
#include "io.h"

#define CMD_SIZE 50
#define CMD_LEN CMD_SIZE - 1
#define MAX_MACHINES 15
unsigned long counter_ = 0L;
boolean event_ = false;
int cnt = 0;
int lin = 0;

StateMachine* machines['[MAX_MACHINES]'/];
int smIndex = 0;


// generated by acceleo !
[for(s:State | aStatechart.regions.vertices)] 
	[s.name/]*  [s.name.toLowerCase()/];
[/for]


void addSm(StateMachine* machine) {
	if (smIndex < MAX_MACHINES - 1)
		machines['[smIndex++]'/] = machine;
}

void exec_reset_nu() {
	counter_ = 0;
	event_ = false;
	resetEvents();
}

void StateMachine_setup() { // initialisation des machins d'états ! et ajout toutes les machines d'état dans la variable machines !

	for (int i=0;i<MAX_MACHINES;i++)
		machines['[i]'/] = NULL;

	// generated by acceleo !
	[for(s:State | aStatechart.regions.vertices)] 
		[s.name.toLowerCase()/] = new [s.name/](); 
		addSm([s.name.toLowerCase()/]);
	[/for]

}

void begin(){
// generated by acceleo ! 
[for(s:Entry | aStatechart.regions.vertices)]
	[s.outgoingTransitions.target.name.toLowerCase()/]->tick();
[/for]

}

void StateMachine_setEvent() {
	event_ = true;
}


void StateMachine_loop() { // cette fonction permet de de commencer l'execution de notre machine d'état !

	acquireInputs(); // initialiser les variable ev_master_start et prior_master_start (si ev_master_start = true alors qu'on doit doit executer l'event ! )

// generated by acceleo
	[for(s:State | aStatechart.regions.vertices)]
	   if([s.name.toLowerCase()/]->running && ![s.name.toLowerCase()/]->finished){
		  [s.name.toLowerCase()/]->tick();
	    }
	[/for]

	if(
	[for(s:State | aStatechart.regions.vertices)]
	[s.name.toLowerCase()/]->finished &&
	[/for]
	true){
	begin();
	}

	if (event_)
		counter_++;
	applyOutputs_nu();

	for (int i=0;i<MAX_MACHINES;i++)
		if (machines['[i]'/] != NULL)
			machines['[i]'/]->endCycle();

	resetEvents();
}

[/file]
[/template]

[template public generateRunnerH(aStatechart : Statechart)]
[file ('runner.h', false, 'UTF-8')]

#ifndef _runner_H_
#define _runner_H_
#include "Arduino.h"
#include "library/StateMachine.h"
#include "iomapping.h"

//geretated by acceleo ! 
[for(s:State | aStatechart.regions.vertices)] 
    #include "[s.name/].h"
[/for]


#ifdef __cplusplus
extern "C" {
#endif


#define FSIMULATE_RESET_DELAY


void SM_loop();
void SM_setup();


//by Acceleo
[for(s:State | aStatechart.regions.vertices)] 
    class [s.name/];
    extern [s.name/]* [s.name.toLowerCase()/];

[/for]


void nop();
void SM_setEvent();
void addSm(StateMachine* machine);
void StateMachine_loop();
void StateMachine_setup();
void StateMachine_setEvent();

#ifdef __cplusplus
} // extern "C"
#endif

#endif

[/file]
[/template]

[template public generateStatesCPP(myState : State)]
[file (myState.name+ '.cpp', false, 'UTF-8')]

#include "./runner.h"
#include "./io.h"
[for(s:State | myState.parentRegion.vertices)] // byAcceleo
    #include "./[s.name/].h"
[/for]
void [myState.name/]::initialize() {
	StateMachine::initialize();
}
[myState.name/]::[myState.name/]() :StateMachine() {
	initialize();
}
void [myState.name/]::activate() {
	StateMachine::activate();
[for(s:String | myState.specification.tokenize('\n'))]
[if(s.trim()<>'entry/')]
out([for(st:String | s.substitute('IO.', '').tokenize('='))][st.trim()/],[/for]-1);
[/if]
[/for]
	StateMachine::activate();
}
void [myState.name/]::handleActivation() {
	if (running && finished ) {
		activate();
	}
}

void [myState.name/]::handleExits() { 
[for(out:Transition | myState.outgoingTransitions)]
	if (running && !finished &&  ev_[out.specification.substitute('IO.', '')/]) { //emergency stop the FB machine
		finish();
		 [out.target.name.toLowerCase()/]->tick();
	}
[/for]
}
void [myState.name/]::tick() { 
        StateMachine::tick();
    	handleActivation();
    	handleExits();
}
[/file]
[/template]

[template public generateStatesH(myState : State)]
[file (myState.name+ '.h', false, 'UTF-8')]

#ifndef [myState.name/]_H_
#define [myState.name/]_H_

#include "./library/StateMachine.h"


class [myState.name/]: public StateMachine {

public:
	[myState.name/]();

	void activate();
	void handleExits();
	void handleActivation();
	void initialize();
	void tick();

private:
	void deactivate();
};

#endif

[/file]
[/template]

[template public generateTest(aStatechart : Statechart)]

[file ('test.h', false, 'UTF-8')]
[aStatechart.specification/]
[aStatechart.specification.index('var')/]
[aStatechart.specification.index('in event')/]
[aStatechart.specification.substring(aStatechart.specification.index('var'), aStatechart.specification.index('in event')-1).substitute('var', '').tokenize(':').current(2)/]
[for(o:String | aStatechart.specification.substring(aStatechart.specification.index('var'), aStatechart.specification.index('in event')-1).substitute('var', '').tokenize(':')) ]
    [if(o.trim()<>'boolean')]
      Boolean : [o/]
	[/if]
[/for]
'substring operation'.substring(11, 19)


----------------------------STATE TEST --------------------------


[for(s:State | aStatechart.regions.vertices)]
	[s.name/]
[/for]


------------------------------- Target Entry Test ---------------------------


[for(s:Entry | aStatechart.regions.vertices)]
	[s.outgoingTransitions.target.name/]
[/for]


--------------------------------Test Specification of state -----------------


[for(s:State | aStatechart.regions.vertices)]
	out([for(s:String | s.specification.substitute('entry/', '').trim().substitute('IO.', '').tokenize('='))][s/],[/for]-1);
[/for]
--------------------------------------------------TEST DE 3 ETAT -----------------------------------------------


[for(o:State | aStatechart.eAllContents()) ] // generated by acceleo 

 	[for(out:Transition | o.outgoingTransitions)]
  /** Les entree sortie : [o.outgoingTransitions.specification.replace('IO.', '')/]**/ 
		boolean [out.specification.replace('IO.', '')/] = false;
		boolean ev_[out.specification.replace('IO.', '')/]=false;
		boolean prior_[out.specification.replace('IO.', '')/] = false;
		
		PROGMEM const char s_[out.specification.replace('IO.', '')/]['[]'/] = "[out.specification.replace('IO.', '')/]";
	
	[/for]
[/for]

 {
----------------------------------------------------------

[aStatechart.specification.substring(aStatechart.specification.index('var'), aStatechart.specification.index('in event')-1).substitute('var', '').substitute('var', '').substitute('boolean','')/]

[for(o:String | aStatechart.specification.substring(aStatechart.specification.index('var'), aStatechart.specification.index('in event')-1).substitute('var', '').substitute('var', '').substitute('boolean','').tokenize(':')) ]
   
   
       #define [o.substitute('var', '').substitute('boolean', '').trim()/] 8// l'entree a change !! 
	
[/for]


[for(o:String | aStatechart.specification.substring(aStatechart.specification.index('var'), aStatechart.specification.index('in event')-1).substitute('var', '').substitute('var', '').substitute('boolean','').tokenize(':')) ]
   
       #define [o.substitute('var', '').substitute('boolean', '').trim()/] 8// l'entree a change !! 
	
[/for]

[/file]
[/template]