[comment]

    UML to upwork job python API generator (C) Vrayo Systems http://vrayo.com
    This code is licensed under the AGPL v.3 or higher

    Intro
    =====
    
    This generator emits python code that uses upwork python API
    to automatically post the jobs for freelancers to write some python 
    code based on UML in current project.

    This generator assumes that vrayo_UML2python is used to generate
    python code from UML and assumes that generated ZIP file and 
    report are saved to some external service accessible via attachment
    url link variable (see below).
    
    Also you will need to create upwork_key.txt file with upwork public
    and private keys separated by a whitespace.
    
    Example:
    $ cd job; ls -d
      ~/job/upwork_post_XXX.py # <-- script generated by this file
      ~/job/upwork_key.txt # <-- public and private key file
    $ sudo pip install python-upwork
    $ python ./upwork_post_XXX.py

    
    How it works
    ============
    
    Each package is a separate upwork job.
    
    Jobs are generated only for packages that have 'jobtitle' and 'budget'
    custom properties defined. Those set job title and budget in USD 
    respectively.
    
    'skills' custom property is used to set the skills required, in 'debian-os' 
    notation.
    
    TODO
    ====
    
    - schedule to post at certain time, at which it is more likely to 
      get good offerings (morning in India, morning in Ukraine, US)
    - validate the skills and category values against metadata before 
      executing a request
[/comment]

[module UML2UpworkJob('http://www.eclipse.org/uml2/4.0.0/UML')/]

[comment]
This is attachment location url.
[/comment]
[query public attach_url(m : Element) : String = 'https://drive.google.com/folderview?id=0B-2xhhL1p3OtVWVLMHRBN1Bwc1k&usp=sharing'/]

[query public hasProperty(m : Element, p : String) : Boolean = 
m.getEAnnotation('genmymodel').details->exists(key = p)
/]

[query public valueOf(m : Element, p : String) : String = 
if (m.hasProperty(p)) then
m.getEAnnotation('genmymodel').details->any(key = p).value
else 
null
endif
/]


[query public next(i : Integer) : Integer = self + 1/]

[template public genBody(c : Comment, prefix : String)]
[c._body/][if (not c.ownedComment->isEmpty())]['\n'/][prefix/] [c.ownedComment.genBody(prefix)->sep('\n ' + prefix)/][/if]
[/template]


[template public genComment(c : Comment, prefix : String)]
[prefix/][c.genBody(prefix).replaceAll('\n','\n' + prefix + ' ').replaceAll('<div>','\n' + prefix + ' ').replaceAll('</div>','').replaceAll('<br>','\n').replaceAll('<[^>]*>','').replaceAll('&nbsp;',' ')/]
[/template]


[comment]
 These templates are used to generate 'Classifier' code, i.e., Class, Interface and Enumeration.
[/comment]
[template public genClassif(e : Classifier)/]
[template public genClassif(c : Class) {counter : Integer = 0;}]
[let inherited : Bag(Classifier) = c.superClass->union(c.interfaceRealization.contract)]
class [c.name/]([if (not inherited->isEmpty())][for (cl : Classifier | inherited) separator(', ')][cl.name/][/for][else]object[/if]):
	[if (not c.ownedComment->isEmpty())]
	[c.ownedComment.genComment('')/]
	[/if]
	Class has these methods to implement:
	[if (not c.ownedOperation->isEmpty())]
		[for (ops : Operation | c.ownedOperation) {counter : Integer = counter + 1;}]
		[let counter : Integer = next(counter)]
		[c.ownedOperation->asOrderedSet()->indexOf(ops)/]. [ops.name/]
		[/let]
		[/for]
	[/if]
[/let]
[/template]

[template public genClassif(i : Interface)]
[let inherited : Bag(Classifier) = i.generalization.general]
class [i.name/]([if (not inherited->isEmpty())][for (cl : Classifier | inherited) separator(', ')][cl.name/][/for][else]object[/if]):
	[if (not i.ownedComment->isEmpty())]
	[i.ownedComment.genComment('')/]
	[/if]
[/let]
[/template]

[template public generate(e : Model)]
[comment @main/]
[file ('upwork_post_'.concat(e.name.concat('.py')), false, 'UTF-8')]
import upwork
public_key, secret_key = file("./upwork_key.txt").read().split()
client = upwork.Client(public_key, secret_key)
print client.auth.get_authorize_url()
verifier = raw_input('Enter oauth_verifier: ')
oauth_access_token, oauth_access_token_secret = client.auth.get_access_token(verifier)
client = upwork.Client(public_key, secret_key,
                      oauth_access_token=oauth_access_token,
                      oauth_access_token_secret=oauth_access_token_secret)
print client.auth.get_info()
print client.hr.get_teams()
team_id=['client.hr.get_teams()[0][\'reference\']'/]
attach_url = "[e.attach_url()/]"
    [for (m : Package | e.ownedElement->filter(Package))]
[m.generatePosting(e.ownedElement->asOrderedSet()->filter(Package)->indexOf(m))/]
    [/for]
[/file]
[/template]

[template public generatePosting(m : Package, i : Integer)]
[if (m.hasProperty('budget') and m.hasProperty('jobtitle'))]
[if (not m.ownedComment->isEmpty())]
# Package [m.buildNumber()/] [m.name/]
jobTitle="[m.valueOf('jobtitle')/]"
jobDescription="""
The task is to implement classes in module named "[m.name.concat('.py')/]" in python2.7 from the attached archive.

Full API SPEC in PDF format and abstract classes skeletons with mock objects as python code are attached.

The package to implement is named "[m.buildNumber()/] Package [m.name/]" in the PDF spec.

UML is attached for reference about the relations with other APIs used in the project.
For further details, please see the attached files at [m.attach_url()/]

Steps to do:

1. download the attached code archive and PDF spec (see link)
2. from the code archive, edit [m.name.concat('.py')/] file to provide code to all methods as described in the docstring
3. consult the UML and SPEC when needed. These contain pretty-printed docstring texts and visual diagrams.


Module that you will need to implement ([m.name.concat('.py')/]) has this description:
[m.ownedComment.genComment(' ')/]

You will need to implement these classes:

[comment Generate code for classes/interfaces /]
[let nonInherit : Set(Classifier) = 
	m.ownedElement->
		filter(Classifier)->
			select(generalization->isEmpty())->reject(oclIsKindOf(Class) and not oclAsType(Class).interfaceRealization->isEmpty())]
[for (e : Classifier | nonInherit->sortedBy(not oclIsKindOf(Enumeration)))]
[e.genClassif()/]
[/for]
[for (e : Classifier | m.ownedElement->filter(Classifier)
						->select(c | nonInherit->excludes(c))
						->sortedBy(getAllUsedInterfaces()->union(getGenerals())->size()))]
[e.genClassif()/]
[/for]
[/let]
For further details, please see the attached documentation at [m.attach_url()/]
"""
jobBudget = [m.valueOf('budget')/]

job_data = {
    'buyer_team_reference': team_id,
    'title': jobTitle,
    'job_type': 'fixed-price',
    'description': jobDescription,
    'visibility': 'public',
    'subcategory2': 'Other - Software Development',
    'category2': 'Web, Mobile & Software Dev',
    'budget': jobBudget,
[if (m.hasProperty('skills'))]
    'skills': ['['/]'python', [m.valueOf('skills')/][']'/]
[else]
    'skills': ['['/]'python'[']'/]
[/if]
}

#client.hr.post_job(team_id, jobTitle, 'fixed-price', jobDescription, 'public', category2='Web, Mobile & Software Dev', subcategory2='Other - Software Development', budget=jobBudget, skills=['['/]'python'[']'/])
print "===== posting job for [m.buildNumber()/] [m.name/]"
client.hr.post_job(**job_data)
[/if]
[/if]
[/template]

[**
 * '1' is for the diagram number, if only 1, that's it, if many, it will still be '1' unless you have
 * use case diagrams (class diagrams are always places after use case diagrams)
 */]
[query public buildNumber(_p : Package) : String =
    '1.' + (_p.getIndex() + 1).toString()
/]

[query public buildNumber(_c : Classifier) : String =
    '1.' + (_c._package.getIndex() + 1).toString() + '.' +  _c.getIndex().toString()
/]

[query public getIndex(_c : Classifier) : Integer =
    _c._package.eContents(Classifier)->reject(oclIsKindOf(Association))->indexOf(_c) 
/]

[query public getIndex(_p : Package) : Integer = 
    if (_p.nestingPackage = null) then 0
    else
        _p.nestingPackage.eContents(Package)->indexOf(_p) +
        _p.ancestors(Package)->collect(getIndex())->sum() +
        if (_p.nestingPackage <> null and _p.nestingPackage.oclIsKindOf(Model))
        then _p.siblings(Package).eAllContents(Package)->size()->sum()
        else
            _p.ancestors(Package)
            ->reject(oclIsKindOf(Model))
            ->last()
            .precedingSiblings(Package).eAllContents(Package)->size()->sum()
        endif
    endif
/]
